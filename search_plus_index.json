{"index.html":{"url":"index.html","title":"首页","keywords":"","body":"首页 欢迎来到 XXTouch 知识库, 请善用搜索, 尝试着自己解决问题. 搜索方式: Windows 平台按 Ctrl + F 可以输入文字, 在当前页面搜索. Mac 平台按 Command + F 可以输入文字, 在当前页面搜索. 知识库左上角输入文字, 进行知识库全文搜索. "},"ABC.html":{"url":"ABC.html","title":"使用入门","keywords":"","body":"使用入门 如何安装 XXTouch 到设备上？ 首先需要确保您的设备是 iOS 设备并且确保您的设备已经越狱从 Cydia 安装 XXTouch 图 授权码如何激活？ 授权码购买地址（XXTouch 授权码的费用不包含脚本开发及相关任何程序的教学费）购买到授权码之后如下图 主界面说明图示 如下图 如何运行已经选中的脚本？ 默认可以使用 按一下音量键 在任意界面弹出选择菜单如图然后选择 启动脚本 则可运行选中脚本注： 可于 更多-->按键设置 编辑更改快捷键设定 如何录制脚本？ 默认可以使用 按一下音量键 在任意界面弹出选择菜单如图 然后选择 录制 则可开始录制之后再次使用 按一下音量键 可以完成录制如图 注： 可于 更多-->按键设置 编辑更改快捷键设定 如何加密脚本？ 确保设备上已经安装最新版的 XXTouch确保设备与电脑处于同一局域网确保设备与电脑之间的网络访问是畅通的然后打开设备上的远程接口，参照 《如何打开远程接口？》然后如图 如何打开远程接口？ 打开 XXTouch 应用后，更多--远程服务 开关打开如图 "},"UpdateLogs.html":{"url":"UpdateLogs.html","title":"更新日志","keywords":"","body":"更新日志 [2018/06/04] 1.2-10 更新内容： 录制脚本的属性中增加播放速度及循环次数设置界面 XUI 拖动条控件增加步进值属性 增加 XUI 控件被更改事件 xxtouch.XUIEventValueChanged XUI 的 Radio 和 CheckBox 增加 numPerLine 字段表示每行个数 XUI 的 Radio 和 CheckBox 默认将使用等宽对齐，默认每行个数为 iPhone 2 个 iPad 4 个 脚本增加 xui 操作模块 plist 模块增加输出到 openstep 格式 minirsa 模块增加私钥签名和公钥校验签名函数 停止脚本弹窗增加“暂停”按钮 增加 ipa 安装器，优化 deb 安装器 增加 sqlite 数据库预览器 日志查看器优化，现为倒序浏览 更改 dialog 界面上的电话号码、地址、日期、邮件地址将不再高亮显示 优化 clear.idfav 针对 iOS 9 以上系统支持，增加 'read' 模式 优化 clear.all_keychain 针对 iOS 10 以上系统支持 优化增强剪贴板模块在 iOS 10 及以上操作系统的兼容性 优化处理针对 64 位设备 iOS 10 提示“该应用程序会导致设备变慢”的提示 优化提升 iOS 11 图色性能 修正了应用程序本地 pdf, docx, pages 等文档文件无法打开的问题 修正根目录访问部分应该显示的目录没显示的问题 修正了远程页面实时桌面不能正常映射数字键盘的问题 修正了针对某应用进行地理位置伪装后远程页面应用列表无法加载的问题 修正了 5S 10.3 以上取色需要加延迟的问题 修正了 os.date 在使用夏令时的时区结果不正确的问题 测试性特性 app.eval 修正了用字面量构造常用结构体报错的问题 [2018/03/30] 1.2-9 更新内容： 修正 1.2-4 版以来授权检查部分情况下会失效的问题 修正 1.2-4 版以来 os.execute 返回值可能不正确的问题 修正 1.2-8 版运行时间过长会导致按音量键无法通讯的问题 内置文字识别引擎滚回到 tesseract 3.02 远程页面实时桌面支持电脑键盘输入 [2018/03/26] 1.2-8 更新内容： 修正上一版中频繁使用 app.input_text 会导致系统变慢或应用闪退的问题 优化了加密接口对低内存设备的支持 修正 :binaryzation 对字符串偏色处理忽略 0 值问题 图中找色新增找色方向字段 [2018/03/17] 1.2-7 更新内容： 修正上一版 app.input_text 无效的问题 对 iOS 11 以上系统放大模式的兼容 [2018/03/17] 1.2-6 更新内容： 修正 utils.qr_encode 在 iOS 11 上会导致服务崩溃的问题 utils.qr_encode 生成的二维码不再与屏幕缩放比有关联 修正 1.2-3 开始 plist.read 文件不存在返回 false 而不是 nil 的问题 修正 app.run 在部分系统版本无法启动应用的问题 修正 XXTouch 本身可能导致开发者挂载在春板上的插件注册端口失败的问题 xpp.dismiss_ui() 效果不正确的问题 修正应用程序脚本编辑器自动补 tab 首行补全逻辑不正的问题 修正了 iOS 11 工具栏会跟随文件列表一起滚动的问题 修正了 iOS 11 以上部分模块抛错会导致服务崩溃的问题 修正了部分系统中守护者的 sys.alert 返回值固定为 3 的问题 禁用了 iOS 8 应用程序内的分享功能 [2018/03/02] 1.2-5 更新内容： 修正 iOS 11 快捷键阻止调整音量的问题 修正 :qr_decode 与旧版表现不一致的问题 App 细节优化 [2018/03/01] 1.2-4 更新内容： 兼容 iOS 11 前台应用程序 接入软猫云找脚本平台 XUI 单选多选控件新增 Popover 模式 XUI 中新增函数 screen.size、sys.version、sys.xtversion、device.type、xui.xui_path 应用程序更多增加查看日志入口 新建项目菜单中增加文件操作历史记录 应用程序文件操作权限增强 应用程序“全清设备”功能加入操作前防误操作弹窗 修正 App 取色器取范围宽高会一样的问题 脚本服务程序 新增 string.compare_version 函数 gps.fake 新增纬度偏差范围和经度偏差范围两个参数 修正 plist.write 函数没有返回操作成败的问题 优化 plist.write 逻辑支持符号链接并新增 plist.dump、plist.load 两个函数 新增 file.md5、file.sha1 utils.video_to_album 支持符号链接和相对路径视频文件 默认启停脚本快捷键更改为短按音量键，并新增从设备启停脚本开关，可通过该开关切换音量键监控状态 用户偏好默认将打开“隐藏无 SIM 弹窗”、“隐藏连接到 iTunes 以使用推送通知弹窗”开关 accelerometer.rotate_home_on_* 支持 iOS 10、11 部分文件修改接口及函数将更正文件权限到 mobile:mobile http 模块所有函数默认时长改为 10 秒 录制脚本文件名更改为 rec_YYYYmmddHHMMSS os.restart 支持脚本包格式脚本 修正部分设备屏幕找色区域为特定越界参数会导致服务崩溃的问题 更改 pasteboard.read 读取逻辑，遇到富文本内容默认将采用纯文本 ( public.text ) 方式读取而非富文本 ( public.rtf ) 方式读取 修正远程页面加密文件名中带点 (.) 处理扩展名逻辑不正确的问题 修正 32 位 iOS 10 设备使用 plist 函数可能导致系统卡死的问题 修正远程截图接口 compress 参数无法在 ext 不存在的时候生效 开机启动不再要求开机 5 分钟内触发，更改为激活越狱时触发 优化远程日志页面连接速度 测试性特性 app.eval 新增函数 toast 新增函数 log 将能使用 bid = 0 对本进程（服务进程）进行注入代码 [2017/12/24] 1.2-3 更新内容： 前台应用程序 剔除掉了无用的录制设置 辅助键盘栏更换，不再默认开启辅助小键盘 更正 iOS 8 以上 iPad 设备上安装 xpa 完成不会关闭的问题 修正在 iOS 8 使用文件预览器及打开链接会导致闪退的 Bug 修正在 iOS 8 使用代码片段选择图片会闪退的 Bug 修正连续代码片段在 iOS 8 以上设备会出现奇怪的问题的 Bug 脚本服务程序 内置了 vpnconf ( 快速配置 VPN ) 模块 增强了 app.input_text、app.set_speed_add 等函数的稳定性 修正一个在部分系统启动脚本可能会一直卡住只能停止脚本重新启动的 Bug 修正一个在部分系统上调用 touch.show_pose 太频繁会导致系统故障的问题 修正一个远古逻辑判断失误会导致所有旧版在 2018 年 2 月 11 日后服务崩溃的 Bug 我们对此非常抱歉，请及时更新以减少损失，不愿更新可从 Cydia 源降级安装补丁后的旧版 [2017/12/12] 1.2-2 更新内容： 前台应用程序 新增 创建项目后编辑 的功能 完善 XUI 主题功能，新增暗色模式示例 允许代码片段取色器从文件系统选取图片文件 应用字体及细节微调 导入文件 / 释放文件 / 安装 xpa / 导入图片，会自动选择项目 释放文件 / 安装 xpa 后文件管理器会自动滚动到新文件所在位置 修复从相册 iCloud 图库导入图片失败也提示成功的问题 修复剪贴板点击复制按钮后，工具条状态未更新的问题 修复了导入照片列表长按显示预览的错位问题 修复了仅插入代码片段时，文档不保存的问题 修复了代码片段选择界面，Cell 右侧有小 i 按钮的显示错误 脚本服务程序 file 模块文本处理函数以及部分远程接口将自动过滤 UTF8-BOM clear.caches 新增一个参数允许不使用 uicache 修复服务程序部分操作权限不足的问题 [2017/12/01] 1.2-1 更新内容： 全新高清重置的 App 焕然一新的界面 新增创新的脚本包（XPP）及优雅的脚本配置界面（XUI）方案 新增支持 deb 包安装 代码编辑器代码片段可使用 Lua 自定义格式 更多交互体验等你发现… 试用授权时间增加至 168 小时（仅限新版） 新增 device.join_wifi 用于加入一个自定义 WiFi webview 模块及 dialog 模块默认尺寸自适应放大模式 dialog 的 :timeout 方法新增第二个参数表示超时后返回提交还是没提交 dialog 新增 :set_config、:set_timeout、:set_title、:set_size、:set_frame、:set_corner_radius 方法 内置云打码模块 ( cloud_ocr ) 支持好爱答题平台 增强优化了脚本启动速度 sys.alert、sys.input_box 的标题默认改为 “脚本提示” 运行期错误弹窗标题改为 “脚本运行期错误” device.play_sound 逻辑优化，已可在录音时同时播放 app.install 对 iOS 10 系统版本判断不正确导致安装耗时增多的问题 修正 plist.write 没限制递归深度的问题，将限制递归深度为 50 层 修正远程页面触屏版脚本列表无法滚动的问题 修正 screen.image、screen.find_image、:crop 的区域参数超出屏幕或图像边界会导致服务崩溃的问题 [2017/09/10] 1.1.3-9 更新内容： 修正 if 块中 goto 标签生成代码错误的问题，参考 bug-fix 修正 sqlite3 模块提交 blob 数据会被 '\\0' 中断的问题 修正 sys.alert 设定了超时并在超时前被点掉会将之后的未设定超时的 alert 也 dismiss 的问题 修正了调用 dialog 模块的 :load 方法会将全局变量 alpha 设为 0 的 bug 修正了 cloud_ocr 在回报打码错误的时候可能抛出 -1 行错误的 bug 扩大了 lcurl 模块的支持范围新增支持 sftp 协议 优化了 app.input_text 的响应逻辑 优化了 plist 模块及 sys.mgcopyanswer 对整数的支持 更改找图找色对区域常量 (0, 0, 0, 0) 的判定为全屏范围 安装包剔除了未公开的 lzmq 及 unix 模块并以扩展库的方式在手册发布 [2017/08/07] 1.1.3-8 更新内容： 修正 1.1.3-1 版开始 :draw_image （也包括 image.oper_merge）红蓝反转的问题 修正 file.set_line、file.insert_line 在目录不存在的情况下会抛出不带行数错误的问题 修正 os.date 在使用叹号（!）开头的格式的情况下叹号不会被剔除的问题 修正服务未启动音量键提示为 Unkown Error #1 而不是可读信息的问题 修正 App 内操作提示不准确的问题（特指“无法连接到守护程序”提示错误） [2017/07/27] 1.1.3-7 更新内容： 修正 1.1.3-6 在 64 位 iOS 7 环境下点击会注销的 bug [2017/07/27] 1.1.3-6 更新内容： 修正 1.1.3-5 触摸次数过多会卡住无法停止脚本的 bug [2017/07/22] 1.1.3-5 更新内容： 修正 1.1.3-1 版开始多点触摸功能不正常的问题 优化 table.deep_print、table.load_string 增加对 json.null 常量的序列/反序列支持 [2017/07/17] 1.1.3-4 更新内容： 修正 1.1.3-1 版开始 http 系列函数对包含 Unicode 字符的 URL 支持出问题的 bug 修正 sys.toast 在部分设备上位置不正确的问题 [2017/07/11] 1.1.3-3 更新内容： 修正上一版 sys.net_time 无限返回 0 的问题 [2017/07/10] 1.1.3-2 更新内容： 修正 App “更多--应用列表” 显示不全的问题 修正 app.data_path('com.apple.springboard') 返回 nil 的问题 修正 touch 模块 :move 方法在移动目的地距离不足一步长情况下逻辑为立即到达 修正上一版本没有选择脚本按启动会出现奇怪提示并且会运行一个没有效果的脚本的问题 [2017/07/03] 1.1.3-1 更新内容： 新增 app.group_info 获取应用程序的组信息 新增 app.pop_banner 弹出一个应用通知 app.install 新增一个强制覆盖安装的参数 screen.ocr_text 及 :tess_ocr 新增第二个返回值描述识别结果中每个可见字符的位置 http 模块 get/post/put/head/delete 头信息若包含 cookie 字段则不再使用默认 cookie 修正在 iPad Pro 取色不够准确的问题 修正 App 在 iPad 上新建文件会闪退的问题 修正 :draw_image 透明图贴图处理错误的问题 修正 :add_checkbox 会因为配置文件中类型错误而抛出没有行信息的错误的问题 修正 iOS 7 上使用 app.data_path 获取到的 Safari 文档位置不正确的问题 修正 gps.fake 在部分设备抛出奇怪错误的问题 修正 string.base64_decode 参数不合法抛出不正确错误的问题 修正 string.from_hex 参数不合法返回越界内容的问题 require 兼容性增强 优化远程截图接口性能 OpenAPI 返回的 Content-Type 标准优化 [2017/04/10] 1.1.2-6 更新内容： 修正设备名称中包含双引号会导致 UDP 扫描获得不正确的返回值的问题 修正 webview.eval 执行的 js 不是 UTF8 编码情况下抛错的问题 修正 iPad Pro 启/停 脚本慢的问题 优化本机的 音量键/Activator 控制交互 远程管理页面集成 脚本加密 选项 [2017/03/13] 1.1.2-5 更新内容： 修正 远程管理页面上的授权充值无法工作的问题 修正 dialog 中没有 input 也没有 picker 的情况下倒数计时器不会随用户介入消失的问题 修正 默认不创建 log 目录的问题 修正 在应用安装的过程中使用 app.uninstall 会报错的问题 修正 一个 *find_color 找色边界少处理一个像素的问题 修正 *find_color 多点找色使用 find_all 模式但区域越界返回的不是 table 类型的问题 开机启动选项不再受MAC地址变更的影响 [2017/02/25] 1.1.2-4 更新内容： 修正 screen.find_image 高度设置不正确错误提示无行信息的问题 修正 :cv_find_image 主图高度小于要找的图片高度错误提示无行信息的问题 修正 /log.html 日志框没有下拉滚动条的问题 [2017/02/19] 1.1.2-3 更新内容： 修正部分函数处理 '0' 开头的字符串逻辑错误的问题 修正一个可能导致服务无响应的问题 [2017/02/08] 1.1.2-2 更新内容： os.restart 增加一个参数可以指定重启后执行某个脚本文件 修正 :add_switch 默认值优先权过高的问题 修正没有使用过 gps.fake 使用 gps.clear 会报错的问题 修正 screen.find_color 找色在单行或者单列搜索不到的问题 修正 ftp.upload 在非断点续传模式下返回结果错误的问题 修正上一版本中横屏截图也是竖屏的问题 [2017/02/01] 1.1.2-1 更新内容： 兼容 iOS 10 screen.find_image 的第一个参数将可以接受一个图片文件名 新增 utils.video_to_album 将 mp4、m4v、mov 视频保存到相册函数 优化 utils.add_contacts、utils.remove_all_contacts 对大批量通讯录操作的支持 优化远程服务接口性能及脚本启动速度 修正 软件授权激活时激活码输入错误或者时间错误的错误提示奇怪的问题 修正 ftp.download、ftp.upload 连接失败或中断时的返回 true 的八哥 修正 image 模块 :find_color 方法在使用旋转函数之后找不到结果的八哥 修正 string.aes128_* 函数设置的 key 长度为 16 位结果不正确的八哥 修正 device.assistive_touch_on/off 在 iOS8 以上设备不好使的八哥 修正 dialog 中字母 x 显示成一个打印机图标的八哥 修正 string.random 传入 0 长度的字符串报错奇怪的八哥 修正 app.uninstall 无限返回 false 的八哥 修正 proc_put 设置非空值不返回原值的八哥 修正 os.date 格式化的 %d %e %j %u %Z 几种格式不原生的八哥 修正 可选参数实参为 nil 的时候提示参数错误而不取默认值的问题 修正 require 引用加密模块表现不够原生的问题 修正运行期错误弹窗标题没有随本地化变化的问题 [2016/12/10] 1.1.1-1 更新内容： 修正 ocr 文字识别一处内存泄漏 修正在 iPhone 6(S)+ 上 touch.show_pose 显示的小圆点不圆的问题 修正 file.line_count、file.get_lines 对空文件操作逻辑不正确的问题 修正在中文语言环境下 dialog 模块添加控件字段重复时报错奇怪的问题 集成 地理位置伪装 模块（不再需要手动导入插件） 新增 file.remove_line 操作成功后将会返回被移除的行到第二个返回值 新增 device.assistive_touch_on/off 打开关闭小圆点函数 新增 device.set_autolock_time 设置自动锁屏分钟数函数 http 模块新增 http.head、http.delete、http.put 函数 dialog 模块新增 :add_range、:add_radio（数值选择器、单选组） 方法 App 细节优化，新增大量特性 所有设备新版首次联网运行脚本将获赠 3 天全功能使用时长 [2016/11/17] 1.1.0-5 更新内容： 修正 screen.ocr_text 第 6 个参数不合法抛错可能不会附带行信息的八哥 修正一个 utils.add_contacts 参数不合法可能导致安全模式的八哥 修正 sys.net_time 不会随系统时区变化的八哥 修正守护模式没卵用的八哥 修正 os.restart 重启脚本之后 ftp 函数不正常的八哥 修正 http.get、http.post 传入非法的 headers 可能导致奇怪错误的八哥 [2016/10/29] 1.1.0-4 更新内容： 修复横屏全屏找色有几率导致服务崩溃的八哥 [2016/10/29] 1.1.0-3 更新内容： 修复一处历史遗留内存泄漏 修复初次授权无法拉取的问题 [2016/10/28] 1.1.0-2 更新内容： 修复低性能设备(4、4S)停止脚本会显示缓慢的问题 [2016/10/28] 1.1.0-1 更新内容： 修复一个极端情况无法停止脚本的八哥 修复一个少见情况下 sys.alert 状态固定返回 3 的八哥 增强兼容性减少与部分第三方插件的冲突 优化部分屏幕图像相关函数性能 :binaryzation 方法支持用字符串色偏 screen.ocr_text 函数支持设置二值化色偏 dialog 模块新增 :add_image 方法 http 模块新增 http.download 函数 新增 ftp 模块、file 模块、lcurl 模块 前端应用程序4K超高清重制[害怕] [2016/10/12] 1.0.9-4 更新内容： 修正了 :binaryzation 函数结果不正确的问题 key.down 调用在脚本停止之时将会释放 sys.log 将会输出到文件 /log/sys.log 中（至多 4000 行） cloud_ocr 模块更新支持 dama2（打码兔） 优化增强服务器线路 [2016/10/01] 1.0.9-3 更新内容： 针对服务器无法连接更改验证逻辑防止授权验证失败 [2016/09/17] 1.0.9-2 更新内容： 修正 dialog 模块 input 控件按回车会跳转到 xxt 主页的问题 修正 开机启动 开关无法打开的问题 [2016/09/12] 1.0.9-1 更新内容： 新增 HID 事件监听 新增 dialog 模块 [2016/08/29] 1.0.8-2 更新内容： 修正上一版本 /spawn 接口启动长度太短的源码提示脚本损坏的问题 修正 device.battery 函数命名成 device.bettery 的问题 电量获取精度优化 前端应用程序细节优化 utils.add_contacts 函数新增 emails 字段 [2016/08/22] 1.0.8-1 更新内容： 修正在罕见情况下扫描到的设备的设备号与实际设备号不一致的问题 修正 http 服务在找不到接口的情况下状态码依然是 200 的问题 前端应用编辑器增强增加开发辅助取点抓色功能 [2016/08/15] 1.0.7-3 更新内容： 优化守护模式开关为开的情况下脚本启动速度 优化内存写入函数逻辑 优化内存搜索函数逻辑 扫码授权界面优化 [2016/08/09] 1.0.7-2 更新内容： 修正上一版本 :png_data 方法可能返回不正确的类型的问题 [2016/08/08] 1.0.7-1 更新内容： 修正 app.open_url 在部分设备上不好使的问题 更新加密格式 xxt 到第二版 远程接口 /snapshot 新增支持范围截图 新增函数 clear.app_data 用于清理一个应用程序的存档 [2016/08/01] 1.0.6-1 更新内容： 修正 device.play_sound 播放的文件不存在会导致服务崩溃的问题 优化增强脚本运行期错误提示 Activator 事件新增图标 新增远程接口 /image_to_album 用于导入图片到设备相册 [2016/07/25] 1.0.5-1 更新内容： 修正 utils.remove_all_contacts 需要在添加联系人函数调用过后才有效果的问题 修正 Activator 重启服务开关会弹出错误提示的问题 新增 Activator 回调事件 新增 utils.launch_args 用于获取当次脚本启动的参数 服务弹出提示窗观感更换 用户偏好设置新增脚本结束提示文字开关 1.0.4-2 更新内容： 修正上一版本 os.date 不支持 \"*t\" 参数的问题 前端应用录制设置细节更改 1.0.4-1 更新内容： 修正文件名少于四个字符前端应用会闪退的问题 修正频繁调用 os.date 会导致 iOS9 系统内核崩溃的问题 用户偏好 禁用 “无 SIM 卡” 弹窗 选项兼容 iOS9 用户偏好设置新增失眠模式与脚本守护模式开关 1.0.3-2 更新内容： 安全性更新 修正脚本没有运行的时候停止脚本依然会有输出的问题 前端应用细节强化 1.0.3-1 更新内容： 修正字库加载失败会导致崩溃的问题 修正 touch.show_pose 设置会影响到下一次脚本运行的问题 修正上一版本全清设备清理不干净的问题 修正 app.install 安装带括号的文件名会安装失败的问题 部分兼容触摸精灵函数 前端应用大量细节优化 cJSON 库调整支持整数类型 调整脚本的停止通碟到强杀的时间，降低停止慢脚本会重启服务的几率 前端应用新增清理单个应用存档的功能 1.0.2-1 更新内容： 前端应用程序细节强化 GC 逻辑调整 全清设备逻辑调整，不再会删除 .GlobalPreferences.plist webview 新增 can_drag 字段决定 webview 是否可以被拖拽移动 新增 device.brightness、device.set_brightness 新增 device.set_volume 1.0.1-1 更新内容： 修正 screen.find_image 范围设置不正确会产出奇怪的错误的问题 修正 :cv_find_image 主图尺寸小于要找的图片尺寸会产出奇怪的错误的问题 修正 :qr_decode 解码非英文字符乱码的问题 修正 一个 lua 解释器的问题，参考 bug-fix 修正前端程序重启设备按钮无效及大量细节问题 showUI 模块增加一个以字符串作参数的调用模式 1.0.0-1 更新内容： 增强 app.input_text 对一些不能输入的应用做了优化处理 发布全新的手机端前端程序 新增 key.send_text 函数 新增 扫一扫下载文件 功能 0.0.1-746 更新内容： 修正 image.oper_merge 不能设置输出图像质量的问题 修正 thread.register_event 会受全局变量 i 的影响的问题 修正 新版 IDE 调试会可能导致脚本无法终止的问题 0.0.1-745 更新内容： 修正 app.install 在部分系统上安装后 app 无法启动的问题 修正 app.quit 可能导致安全模式的问题 修正 扫一扫屏幕模式持续运行会造成内存占用过高的问题 修正 一个对少数应用的少数弹窗会产生负面作用的问题 修正 thread.register_event 在罕见情况下会报错的问题 兼容库性能优化 webview.show 新增 ignores_hit 字段 screen.init 新增返回值返回之前的 init 状态，脚本录制细节增强 新增 device.set_name 用于设置设备名称 新增 /set_device_name 远程接口 新增 touch.show_pose 用于调试 新增 webview.frame 用于获取某个 webview 的覆盖区域及层信息 新增 device.reduce_motion_on、device.reduce_motion_off 新增 /expire_date 返回本地缓存的最后一次获取的到期时间 0.0.1-744 更新内容： 修正 image 模块图像旋转后输出颜色会翻转的问题 修正 sys.alert、sys.input_box 两个函数可能会无条件返回 3 的问题 0.0.1-743 更新内容： 修正 plist 模块不能正确区分 real 和 integer 类型的问题 0.0.1-742 更新内容： sys.memory_info 返回值新增一个 physical_memory 的字段 webview 新增 opaque 字段 新增 app.quit 用于模拟上划关闭应用程序 新增 clear.all_photos 用于全清相册 新增 utils.qr_encode 用于生成一个二维码图片 新增 :qr_decode 解码一个二维码图片 新增 utils.open_code_scanner、utils.close_code_scanner 用于打开关闭扫码器 新增 device.flash_on、device.flash_off 用于打开关闭闪光灯 新增远程接口 /rename_file 新增扫一扫授权 0.0.1-741 更新内容： 修正远程接口返回值中 version 写成 vertion 的错误 备用线路优化，进一步提升反 DDoS 的能力 0.0.1-740 更新内容： 新增函数 app.localized_name、app.png_data_for_bid 新增函数 device.turn_on_vpn、device.turn_off_vpn 新增消息回调机制，暂时包含电话呼入呼出消息 0.0.1-739 更新内容： 修正前一版本 sys.sleep 不支持浮点数参数的问题 修正 cloud_ocr 模块默认参数会弹错的问题 优化大幅提升 webview 显示速度 新增开机启动脚本功能 新增简易通讯录操作功能 新增“无SIM卡”弹窗与“低电量”弹窗的开关 0.0.1-738 更新内容： 修正在设备IP更改之后广播回复的IP没有更新的问题 sys.toast 将会对输入数据做筛选防止非法数据传入导致安全模式 /read_file 接口逻辑更改、并新增 /write_file 接口 /get_file_list 接口逻辑更改 http.post 支持二进制数据 集成 cloud_ocr 模块 clear.idfav 函数新增了一个参数和一个返回值的调用方式 0.0.1-737 更新内容： 在手机端发生语法错误将会输出具体的错误信息 剔除了不稳定的地理位置伪装函数 0.0.1-736 更新内容： 修正地理位置伪装会造成部分 app 闪退的问题 0.0.1-735 更新内容： 修正 image.new 创建的图像不正确的问题 更改 sys.alert 和 sys.input_text 的逻辑，不可打印内容不再直接返回，而弹出一个空框 showUI 模块更新 简化封装一个函数 image.oper_merge 简易图像合并 新增 app.install、app.uninstall 安装、卸载应用程序 新增 gps.fake、gps.clear 伪装/清除伪装地理位置 0.0.1-734 更新内容： 修正 sys.net_time 不正常的问题 修正 webview 层级可能不正确的问题 主页面添加运行/停止脚本选项 新增开源模块 sqlite3 新增函数 accelerometer.rotate_home_on_left 改变当前重力方向为 home 在左 新增函数 accelerometer.rotate_home_on_right 改变当前重力方向为 home 在右 新增函数 accelerometer.rotate_home_on_top 改变当前重力方向为 home 在上 新增函数 accelerometer.rotate_home_on_bottom 改变当前重力方向为 home 在下 新增函数 table.deep_copy 深复制一个表 新增函数 table.deep_print 深打印一个表 初步兼容触动函数 0.0.1-732 更新内容： 新增 os.restart 重启脚本 新增 sys.rnd 产生一个真随机数 录制优化 "},"FAQ/index.html":{"url":"FAQ/index.html","title":"常见问题答疑 (FAQ)","keywords":"","body":"常见问题答疑 (FAQ) XXTouch 是什么？ 哪些设备可运行 XXTouch？ 如何安装 XXTouch 到设备上？ XXTouch 收费么？哪些部分收费？ 我购买了 XXTouch 授权码后会获得哪些权利？ 没有授权的 XXTouch 有什么限制？ 我电脑上有个脚本，如何使用 USB 连接导入到设备上？ 电脑端如何通过 USB 访问到完全文件系统？ XXTouch 的脚本及相关资源存在设备的哪个位置？ 如何在电脑上给 XXTouch 开发脚本？ 作为开发者，我编写了一个脚本想收费怎么办？ 从 Cydia 添加 XXTouch 源出现“此服务器的证书无效。”怎么办？ 从 Cydia 安装或更新 XXTouch 失败（出现红字/黄字）怎么办？ 在 Cydia 添加 XXTouch 官方源失败怎么办？ 在 Cydia 的 XXTouch 官方源中找不到任何软件包怎么办？ 安装 XXTouch 后闪退或桌面没有图标怎么办？ 安装 XXTouch 后无限提示同步失败怎么解决？ 安装 XXTouch 后无限提示需要注销、与服务器或守护进程通讯失败？ 使用一段时间突然出现“XXTouch 版本需要更新才能继续获得稳定的生产力”无限弹出并且无法操作？ 打开 X.X.T. 后弹窗提示 ‘“X.X.T.” 可能使 iPhone 变慢’ 怎么办？ 授权没有到期却弹出授权无效的提示？ 进入授权界面提示“无法连接到授权服务器。”或“阿里云网关错误：Timestamp Expired”怎么办？ iOS 系统时间在哪里调整？ 取色器/编辑器/局域网控制器 扫描不到设备怎么办？ 为何我扫一扫下载会出现 “帧框加载已失败”？ 如何录制脚本？ 如何运行脚本？ 如何选择脚本？ 如何在设备上编辑脚本？ 如何加密脚本？ 脚本可以做什么？ 加密的脚本可以被解密么？ XXTouch 可以在电脑上运行么？ XXTouch 可以在安卓系统上运行么？ XXTouch 可以在没有越狱的 iOS 设备上运行么？ 已知的与 XXTouch 一定会产生冲突的插件参考 "},"FAQ/faq-0001.html":{"url":"FAQ/faq-0001.html","title":"XXTouch 是什么？","keywords":"","body":"XXTouch 是什么？ 是一款用于越狱 iOS 环境下的自动化模拟操作的软件开发人员可以编写 Lua 脚本让 XXTouch 运行来完成一些日常自动化的工作。但它本身没有集成也不会自动编写具有针对性的具体的自动化工作脚本。 希望自行编写脚本，可参考《XXTouch iOS 开发手册》《Lua 5.3 参考手册 》 "},"FAQ/faq-0002.html":{"url":"FAQ/faq-0002.html","title":"哪些设备可运行 XXTouch？","keywords":"","body":"哪些设备可运行 XXTouch？ XXTouch 支持 iOS 7 以上所有可以越狱的 iOS 设备 XXTouch 不支持 Meridian 越狱，如果使用该工具越狱，请更换使用 doubleH3lix 或 g0blin 重新越狱 已经确认可以稳定越狱的设备型号及版本 设备型号 可以越狱系统版本区间 iPhone 4 iOS 7.0 及以上所有版本 iPhone 4S iOS 7.0 及以上所有版本 iPhone 5 iOS 7.0 及以上所有版本 iPhone 5C iOS 7.0 及以上所有版本 iPhone 5S 除 iOS 8.4.1、9.3.4、9.3.5、10.3 外所有 iOS 7.0 ~ 11.3.1 iPhone 6 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 8.0 ~ 11.3.1 iPhone 6S 除 iOS 9.3.4、9.3.5、10.3 外所有 iOS 9.0.1 ~ 11.3.1 iPhone 6 Plus 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 8.0 ~ 11.3.1 iPhone 6S Plus 除 iOS 9.3.4、9.3.5、10.3 外所有 iOS 9.0.1 ~ 11.3.1 iPhone SE 除 iOS 9.3.4、9.3.5 外所有 iOS 9.3 ~ 11.3.1 iPhone 7 iOS 11.0 ~ 11.3.1 iPhone 7 Plus iOS 11.0 ~ 11.3.1 iPhone 8 iOS 11.0 ~ 11.3.1 iPhone 8 Plus iOS 11.0 ~ 11.3.1 iPhone X iOS 11.0 ~ 11.3.1 iPod Touch 5 iOS 7.0 及以上所有版本 iPod Touch 6 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 8.4 ~ iOS 11.3.1 iPad 2 iOS 7.0 及以上所有版本 iPad 3 iOS 7.0 及以上所有版本 iPad 4 iOS 7.0 及以上所有版本 iPad mini 除 iOS 8.4.1 外所有 iOS 7.0 ~ iOS 9.0.2 iPad mini 2 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 7.0 ~ 11.3.1 iPad mini 3 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 8.1 ~ 11.3.1 iPad mini 4 除 iOS 9.3.4、9.3.5 外所有 iOS 9.0 ~ 11.3.1 iPad Air 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 7.0.2 ~ 11.3.1 iPad Air 2 除 iOS 8.4.1、9.3.4、9.3.5 外所有 iOS 8.1 ~ 11.3.1 iPad 9.7 (iPad6,11/iPad6,12) iOS 10.3 ~ 11.3.1 iPad Pro (12.9 寸) 除 9.3.4、9.3.5 外所有 iOS 9.2 ~ 11.3.1 iPad Pro (9.7 寸) 除 9.3.4、9.3.5 外所有 iOS 9.3 ~ 11.3.1 iPad Pro 2 (12.9 寸) iOS 10.0 ~ 11.3.1 iPad Pro 2 (10.5 寸) iOS 11.0 ~ 11.3.1 注意！！！ iPhone 7/7 Plus 的 iOS 10 越狱极度不稳定，等越狱完善才能稳定，与 XXTouch 无关 64 位设备 9.1 完美越狱需要非 OTA 升级到 9.1 的设备，可越狱状态取决于实际情形 32 位设备 8.4.1 越狱参考：https://www.abcydia.com/read-12513.html 32 位设备 9.3.5 越狱参考：https://www.abcydia.com/read-11613.html 32 位设备 10.3.x 越狱参考：https://www.abcydia.com/read-13734.html 64 位设备 10.0 ~ 10.2 越狱参考：https://www.abcydia.com/read-9986.html 64 位设备 10.2.1 越狱参考：https://www.abcydia.com/read-12783.html 64 位设备 10.3.x 越狱参考：https://www.i4.cn/news_detail_18892.html "},"FAQ/faq-0003.html":{"url":"FAQ/faq-0003.html","title":"如何安装 XXTouch 到设备上？","keywords":"","body":"如何安装 XXTouch 到设备上？ 图：如何安装 XXTouch 到设备上 "},"FAQ/faq-0004.html":{"url":"FAQ/faq-0004.html","title":"XXTouch 收费么？哪些部分收费？","keywords":"","body":"XXTouch 收费么？哪些部分收费？ XXTouch 是否收费？ 是的， XXTouch 是收费软件 XXTouch 哪部分收费？ 让脚本运行的功能收费 以下是参考价格 月卡（ 31 天）授权码 10 元每设备季卡（ 92 天）授权码 15 元每设备半年（183 天）授权码 20 元每设备年卡（366 天）授权码 30 元每设备 如何购买授权码？ 购买地址：https://www.xxtouch.com/buy 购买说明 授权码是您的购买于 XXTouch 唯一的凭据，不记名，丢失不补，购买后请自行保存好。授权码费用仅为 XXTouch 应用程序本体的使用费，不包含具体脚本功能开发费及相关任何程序的教学费，也不会赋予你在论坛、QQ 群等社区社交特权。请务必于购买授权码之前知晓您购买授权码后的权利以及购买后将解除的限制。 如何使用授权码？ "},"FAQ/faq-0005.html":{"url":"FAQ/faq-0005.html","title":"我购买了 XXTouch 授权码后会获得哪些权利？","keywords":"","body":"我购买了 XXTouch 授权码后会获得哪些权利？ 关于授权码及试用期 您可以用单个授权码激活任意一台已安装 XXTouch 并能正常运行的设备上的 XXTouch每台设备可获得 168 小时的一次性 全功能试用 授权，务必先试用确认后再购买（1.2-4 版以上可获得） 授权转移说明 每个零售授权码每 7 天可以自助转移到另外一台设备转移授权自助页面：https://www.xxtouch.com/transfer-licence转移授权需要授权码没有通过设备信息查询授权码的服务无法从授权剩余时间小于 7 天的设备上转出授权 授权有效性说明 更换电池、卸载重装及更新软件都 不会影响 设备的授权状态授权未到期再次激活新授权会在设备剩余授权时间的基础上累加授权时间（即使是试用期也会累加） "},"FAQ/faq-0006.html":{"url":"FAQ/faq-0006.html","title":"没有授权的 XXTouch 有什么限制？","keywords":"","body":"没有授权的 XXTouch 有什么限制？ 限制 没有授权的 XXTouch 将不能运行脚本 试用期说明 每台设备可获得 168 小时的一次性 全功能试用 授权（1.2-4 版以上可获得）每台设备第一次尝试运行脚本会获得试用授权同一设备获得试用授权的 360 天后运行脚本可再次获得一次试用试用授权到期之前没有任何功能限制，试用期和购买后，功能上无差别 不受限制的功能 以下一些功能是不需要授权也可以使用的使用远程接口（比如：远程截图、远程访问设备文件等）使用手机端的代码编辑器使用手机端及电脑端的取色工具 "},"FAQ/faq-0007.html":{"url":"FAQ/faq-0007.html","title":"我电脑上有个脚本，如何使用 USB 连接导入到设备上？","keywords":"","body":"我电脑上有个脚本，如何使用 USB 连接导入到设备上？ 使用 iTools（或者各种能连 iOS 设备的手机助手） 将脚本文件传到设备的这个目录 /1ferver/lua/scripts/ 注：此处 用户系统 仅为 iTools 上手机文件管理显示名，不同的手机助手上名字不相同，大概为 用户系统、文件系统（用户） "},"FAQ/faq-0008.html":{"url":"FAQ/faq-0008.html","title":"电脑端如何通过 USB 访问到完全文件系统？","keywords":"","body":"电脑端如何通过 USB 访问到完全文件系统？ iOS 11 无法做到，iOS 11 以下参考打开设备上的 Cydia搜索 Apple File Conduit \"2\" 安装上重启一次设备（可能重启好还需要重新激活越狱） "},"FAQ/faq-0009.html":{"url":"FAQ/faq-0009.html","title":"XXTouch 的脚本及相关资源存在设备的哪个位置？","keywords":"","body":"XXTouch 的脚本及相关资源存在设备的哪个位置？ 脚本存放目录为 /var/mobile/Media/1ferver/lua/scripts/插件存放目录为 /var/mobile/Media/1ferver/lib/资源存放目录为 /var/mobile/Media/1ferver/res/日志存放目录为 /var/mobile/Media/1ferver/log/文字识别字库存放目录为 /var/mobile/Media/1ferver/tessdata/内置脚本模块存放目录为 /var/mobile/Media/1ferver/lua/ "},"FAQ/faq-0010.html":{"url":"FAQ/faq-0010.html","title":"如何在电脑上给 XXTouch 开发脚本？","keywords":"","body":"如何在电脑上给 XXTouch 开发脚本？ 下载工具阅读手册与其它开发者交流（XXTouch 开发者 QQ 群：40898074） "},"FAQ/faq-0011.html":{"url":"FAQ/faq-0011.html","title":"作为开发者，我编写了一个脚本想收费怎么办？","keywords":"","body":"作为开发者，我编写了一个脚本想收费怎么办？ XXTouch 暂无官方代售及验证平台业务 可能的选择 作为开发者的您暂时可以选择自己部署验证服务，可参考 XXTouch 提供的网络授权工具自行在脚本中编写相关收费限制使用第三方验证平台供应商提供验证服务，例如 软猫验证平台 "},"FAQ/faq-0012.html":{"url":"FAQ/faq-0012.html","title":"从 Cydia 添加 XXTouch 源出现“此服务器的证书无效。”怎么办？","keywords":"","body":"从 Cydia 添加 XXTouch 源出现“此服务器的证书无效。”怎么办？ 首先，确认一下官方源地址 apt.xxtouch.com 停用设备上的网络代理及 VPN确保设备的网络连接畅通然后确定设备时间及时区是否正确 可以 百度搜索“时间” 然后 手动校准 "},"FAQ/faq-0013.html":{"url":"FAQ/faq-0013.html","title":"从 Cydia 安装或更新 XXTouch 失败（出现红字/黄字）怎么办？","keywords":"","body":"从 Cydia 安装或更新 XXTouch 失败（出现红字/黄字）怎么办？ 解决因系统分区空间不足导致的红字 如果红字中包含以下任意一条No space left on devicecannot copy extracted data forfailed in buffer_write(fd) (8, ret=-1)这种情况可能是设备系统分区没有足够的空间可尝试卸载掉一些不需要的插件或者删除一些无用的资源千万 不要删除 /.cydia_no_stash 这个文件来腾出空间，会白苹果 iOS 9.2 ~ 10.2.1 （非 9.3.5）可能可以解决空间不足的方案（低版本 iOS 不用试） 第一步，接通电源，并保证在完成前持续供电，删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 第二步，添加 apt.abcydia.com 这个源（雷锋源）第三步，通过 Cydia 选择卸载 Cydia Substrate 并将卸载列表截图，别点确认，先看下面两句话，重要！！ 该操作会同时卸载掉包括 XXTouch 在内的很多插件。理论上不存在风险，不过我们对此不接受任何甩锅，如果有顾虑请终止操作并请您信任的专业人士接手 理解上面那句话后，自行决定是否要确认卸载 第四步，从 Cydia 里搜索安装“Stashing 容量不足修正”这个插件第五步，空间已经很足了，如果需要，将第二步卸载掉的东西再装回来 使用 Etason JB 越狱的 iOS 8.4.1 可能可以解决空间不足的方案 第一步，打开设置，通用 -> 自动锁定 -> 永不第二步，接通电源，并保证在完成前持续供电，删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 第三步，添加 cydia.angelxwind.net 这个源（蔡明美源）第四步，从 Cydia 里搜索安装“Stashing for #etasonJB (8.4.1)”这个插件第五步，照提示重启设备第六步，开机后，打开 Cydia 并等待 Cydia 准备文件系统完成它会自动注销设备，完成 使用 Phœnix 越狱的 iOS 9.3.5 可能可以解决空间不足的方案 第一步，接通电源，并保证在完成前持续供电，删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 第二步，添加 cydia.angelxwind.net（蔡明美源）和 apt.abcydia.com（雷锋源）这两个源第三步，通过 Cydia 选择卸载 Cydia Substrate 并将卸载列表截图，别点确认，先看下面两句话，重要！！ 该操作会同时卸载掉包括 XXTouch 在内的很多插件。理论上不存在风险，不过我们对此不接受任何甩锅，如果有顾虑请终止操作并请您信任的专业人士接手 理解上面那句话后，自行决定是否要确认卸载 第四步，从 Cydia 里搜索安装“Stashing 容量不足修正”和“Stashing Fix for Phœnix (9.3.5)”这两个插件第五步，照提示重启设备第六步，重新激活越狱，空间已经很足了，如果需要，将第三步卸载掉的东西再装回来 删掉一些可能导致红黄字的源 删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） BigBoss、ModMyi、ZodTTD、Ultrasn0w 也要删掉，是的，确认。 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 没有任何损失的，不用怕，不用怕，不用怕 尝试在以下一些链接中找到解决办法 常见Cydia错误提示（红字/黄字）和解决办法Cydia常见错误和红黄字解决方法 尝试百度搜索红字内容解决问题 通常红字错误网上有丰富的解答可以先行尝试在网上找到答案 其它尝试 如果尝试无果，请将红字界面截图，然后找专业人士解决专业 Cydia 红字修复 "},"FAQ/faq-0014.html":{"url":"FAQ/faq-0014.html","title":"在 Cydia 添加 XXTouch 官方源失败怎么办？","keywords":"","body":"在 Cydia 添加 XXTouch 官方源失败怎么办？ 首先，确认一下官方源地址 apt.xxtouch.com 将时间的时区调整到北京时间的正确日期正确时间 可以 百度搜索“时间” 然后 手动校准 确认后可做出以下尝试 确保网络连接可用 删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 点一下 “软件源” 页面左上角的 “刷新” 并等待完成 出现了红字或者黄字参考 《从 Cydia 安装 XXTouch 失败（出现红字/黄字）怎么办？》 如果尝试无果，可整理自己做出的尝试，进群求助，但是有一些注意事项 请注意文明用语，互相尊重，这是 “求助” 不是去找麻烦 群内不一定能解决，您需要调整心态 调整之后，加 QQ 群，群号 483853614 "},"FAQ/faq-0015.html":{"url":"FAQ/faq-0015.html","title":"在 Cydia 的 XXTouch 官方源中找不到任何软件包怎么办？","keywords":"","body":"在 Cydia 的 XXTouch 官方源中找不到任何软件包怎么办？ 首先，确认一下官方源地址 apt.xxtouch.com 确认后可做出以下尝试 点一下 “软件源” 页面左上角的 “刷新” 并等待完成 查看 “已安装” 列表中的 XXTouch 版本 当设备安装了版本号大于源上版本的软件包的时候，源上会不显示这个软件包 这通常发生在设备上安装了 XXTouch 测试版的情况下 这是正常的，不用继续查原因了 如果不是上面情况请 确保网络连接可用 删除掉除 Cydia/Telesphoreo 及 XXTouch 以外所有的源（没有任何损失的，不用怕） 操作为点一下 “软件源” 右上角的 “编辑” 然后点源前面的 “红圈减号” 点一下 “软件源” 页面左上角的 “刷新” 并等待完成 出现了红字或者黄字参考 《从 Cydia 安装 XXTouch 失败（出现红字/黄字）怎么办？》 如果尝试无果，可整理自己做出的尝试，进群求助，但是有一些注意事项 请注意文明用语，互相尊重，这是 “求助” 不是去找麻烦 群内不一定能解决，您需要调整心态 调整之后，加 QQ 群，群号 483853614 "},"FAQ/faq-0016.html":{"url":"FAQ/faq-0016.html","title":"安装 XXTouch 后闪退或桌面没有图标怎么办？","keywords":"","body":"安装 XXTouch 后闪退或桌面没有图标怎么办？ 可 逐条 尝试下面的方案 尝试 1： 从 Cydia 重新安装（不用先卸载） XXTouch 最新版，确保 没有 出现红字（《从 Cydia 安装 XXTouch 失败（出现红字/黄字）怎么办？》）重启设备（可能还需要重新激活越狱） 尝试 2： iOS 7/8 删掉设备上这两个文件然后重启设备/var/mobile/Library/Caches/com.apple.LaunchServices-*.csstore/var/mobile/Library/Caches/com.apple.mobile.installation.plist 尝试 3： 通过 Cydia 安装 OpenSSH 并确保 没有 出现红字（若已安装则进入下一步）刷新 Cydia 源并更新所有基础依赖并确保 没有 出现红字如果是 iOS 11 以下则通过 Cydia 重新安装（不用先卸载） Cydia Substrate 和 UIKit Tools 和 XXTouch 并确保 没有 出现红字如果是 iOS 11 及以上则通过 Cydia 重新安装（不用先卸载） Tweak Injector、Substitute、Substrate Compatibility Layer 、UIKit Tools 和 XXTouch 并确保 没有 出现红字然后重启设备（可能还需要重新激活越狱） 尝试 4： 第一步，通过 Cydia 选择卸载 Cydia Substrate（iOS 11 及以上系统为 Substitute）并将卸载列表截图，别点确认，先看下面两句话，重要！！ 该操作会同时卸载掉包括 XXTouch 在内的很多插件。理论上不存在风险，不过我们对此不接受任何甩锅，如果有顾虑请终止操作并请您信任的专业人士接手 理解上面那句话后，自行决定是否要确认卸载 第二步，然后通过源安装 XXTouch（可能还需要重启设备和重新激活越狱）并确保 没有 出现红字第三步，再重启设备（可能还需要重新激活越狱）第四步，如果需要，根据第一步所截的图将卸载掉的东西再装回来 "},"FAQ/faq-0017.html":{"url":"FAQ/faq-0017.html","title":"安装 XXTouch 后无限提示同步失败怎么解决？","keywords":"","body":"安装 XXTouch 后无限提示同步失败怎么解决？ 可 逐条 尝试下面的方案 尝试 1： 点取消，选择一个脚本 尝试 2： 从 Cydia 重新安装（不用先卸载） XXTouch 最新版，确保 没有 出现红字（《从 Cydia 安装 XXTouch 失败（出现红字/黄字）怎么办？》）重启设备（可能还需要重新激活越狱） 尝试 3： 通过 Cydia 安装 OpenSSH 并确保 没有 出现红字（若已安装则进入下一步）刷新 Cydia 源并更新所有基础依赖并确保 没有 出现红字如果是 iOS 11 以下则通过 Cydia 重新安装（不用先卸载） Cydia Substrate 和 UIKit Tools 和 XXTouch 并确保 没 有 出现红字如果是 iOS 11 及以上则通过 Cydia 重新安装（不用先卸载） Tweak Injector、Substitute、Substrate Compatibility Layer、UIKit Tools 和 XXTouch 并确保 没有 出现红字然后重启设备（可能还需要重新激活越狱） 尝试 4： 第一步，通过 Cydia 选择卸载 Cydia Substrate（iOS 11 及以上系统为 Substitute）并将卸载列表截图，别点确认，先看下面两句话，重要！！ 该操作会同时卸载掉包括 XXTouch 在内的很多插件。理论上不存在风险，不过我们对此不接受任何甩锅，如果有顾虑请终止操作并请您信任的专业人士接手 理解上面那句话后，自行决定是否要确认卸载 第二步，然后通过源安装 XXTouch（可能还需要重启设备和重新激活越狱）并确保 没有 出现红字第三步，再重启设备（可能还需要重新激活越狱）第四步，如果需要，根据第一步所截的图将卸载掉的东西再装回来 尝试 5： 将 /var/mobile/Media/1ferver/caches/daemon_cache.db 删除，重启设备（可能还需要重新激活越狱） "},"FAQ/faq-0018.html":{"url":"FAQ/faq-0018.html","title":"安装 XXTouch 后无限提示需要注销、与服务器或守护进程通讯失败？","keywords":"","body":"安装 XXTouch 后无限提示需要注销、与服务器或守护进程通讯失败？ 可 逐条 尝试下面的方案 尝试 1： 从 Cydia 重新安装（不用先卸载） XXTouch 最新版，确保 没有 出现红字（《从 Cydia 安装 XXTouch 失败（出现红字/黄字）怎么办？》）重启设备（可能还需要重新激活越狱） 尝试 2： 通过 Cydia 安装 OpenSSH 并确保 没有 出现红字（若已安装则进入下一步）刷新 Cydia 源并更新所有基础依赖并确保 没有 出现红字如果是 iOS 11 以下则通过 Cydia 重新安装（不用先卸载） Cydia Substrate 和 UIKit Tools 和 XXTouch 并确保 没有 出现红字如果是 iOS 11 及以上则通过 Cydia 重新安装（不用先卸载） Tweak Injector、Substitute、Substrate Compatibility Layer 、UIKit Tools 和 XXTouch 并确保 没有 出现红字然后重启设备（可能还需要重新激活越狱） 尝试 3： 第一步，通过 Cydia 选择卸载 Cydia Substrate（iOS 11 及以上系统为 Substitute）并将卸载列表截图，别点确认，先看下面两句话，重要！！ 该操作会同时卸载掉包括 XXTouch 在内的很多插件。理论上不存在风险，不过我们对此不接受任何甩锅，如果有顾虑请终止操作并请您信任的专业人士接手 理解上面那句话后，自行决定是否要确认卸载 第二步，然后通过源安装 XXTouch（可能还需要重启设备和重新激活越狱）并确保 没有 出现红字第三步，再重启设备（可能还需要重新激活越狱）第四步，如果需要，根据第一步所截的图将卸载掉的东西再装回来 尝试 4： 将 /var/mobile/Media/1ferver/caches/daemon_cache.db 删除，重启设备（可能还需要重新激活越狱） "},"FAQ/faq-0019.html":{"url":"FAQ/faq-0019.html","title":"使用一段时间突然出现“XXTouch 版本需要更新才能继续获得稳定的生产力”无限弹出并且无法操作？","keywords":"","body":"使用一段时间突然出现“XXTouch 版本需要更新才能继续获得稳定的生产力”无限弹出并且无法操作？ 首先，我们对此问题的出现表示深切的歉意。实在是抱歉，这个问题是因为安装 XXTouch 导致的。如遇无法操作，解决方案如下 iOS 9.1 及以下解决步骤 关机 按住“音量加”键，启动设备直至进入桌面松开 进 Cydia 更新或卸载 XXTouch 重启设备 iOS 9.1 以上（不含）解决步骤 重启设备 激活越狱成功则按住“音量加”键直至再次进入桌面松开 进 Cydia 更新或卸载 XXTouch 重启设备 "},"FAQ/faq-0036.html":{"url":"FAQ/faq-0036.html","title":"打开 X.X.T. 后弹窗提示 ‘“X.X.T.” 可能使 iPhone 变慢’ 怎么办？","keywords":"","body":"打开 X.X.T. 后弹窗提示 ‘“X.X.T.” 可能使 iPhone 变慢’ 怎么办？ 不用管，点“好”即可，请不要担心 X.X.T. 会导致你的设备变慢这是苹果的一个欺骗性提示，不是真的，所有的仅 32 位应用在 64 位 iOS 10.0 ~ 10.2.1 设备都会提示这个为了缩减安装包体积，X.X.T. 仅包含了 32 位可执行文件（iOS 11 以上例外）在 10.3 以上，苹果将这个提示纠正为 “X.X.T.” 需要更新 而不再是吓人的可能使 iPhone 变慢 "},"FAQ/faq-0020.html":{"url":"FAQ/faq-0020.html","title":"授权没有到期却弹出授权无效的提示？","keywords":"","body":"授权没有到期却弹出授权无效的提示？ 将时间的时区调整到北京时间的正确日期正确时间 时间容差 5 分钟，可以 百度搜索“时间” 然后 手动校准 确保设备的网络连接畅通 设备上的网络代理及 VPN 连接可能导致网络连接不畅通 如以上尝试皆无效，可截图并联系经销商（如果是于 发卡平台 购买的找 QQ 1004695100） "},"FAQ/faq-0021.html":{"url":"FAQ/faq-0021.html","title":"进入授权界面提示“无法连接到授权服务器。”或“阿里云网关错误：Timestamp Expired”怎么办？","keywords":"","body":"进入授权界面提示“无法连接到授权服务器。”或“阿里云网关错误：Timestamp Expired”怎么办？ 将时间的时区调整到北京时间的正确日期正确时间 时间容差 5 分钟，可以 百度搜索“时间” 然后 手动校准 确保设备的网络连接畅通 设备上的网络代理及 VPN 连接可能导致网络连接不畅通 如以上尝试皆无效，可截图并联系经销商（如果是于 发卡平台 购买的找 QQ 1004695100） "},"FAQ/faq-0022.html":{"url":"FAQ/faq-0022.html","title":"iOS 系统时间在哪里调整？","keywords":"","body":"iOS 系统时间在哪里调整？ 打开“设置”应用进入“通用”子页面进入“日期与时间”子页面 "},"FAQ/faq-0023.html":{"url":"FAQ/faq-0023.html","title":"取色器/编辑器/局域网控制器 扫描不到设备怎么办？","keywords":"","body":"取色器/编辑器/局域网控制器 扫描不到设备怎么办？ 确保电脑端或路由器的防火墙规则没有拦截设备与电脑在同一局域网确保停用了设备上的网络代理及 VPN确保设备是解锁屏幕状态确保电脑能 ping 通设备 如果不懂可以 百度搜索“ping命令如何使用” 确保设备打开了 远程开关 "},"FAQ/faq-0024.html":{"url":"FAQ/faq-0024.html","title":"为何我扫一扫下载会出现 “帧框加载已失败”？","keywords":"","body":"为何我扫一扫下载会出现 “帧框加载已失败”？ 如果您是脚本分发者（脚本作者），请看 XXTouch 扫一扫协议如果您是脚本用户，请让您的脚本分发者（脚本作者）看上一条 "},"FAQ/faq-0025.html":{"url":"FAQ/faq-0025.html","title":"如何录制脚本？","keywords":"","body":"如何录制脚本？ 默认可以使用 按一下音量键 弹出选择录制脚本再次使用 按一下音量键 可以完成录制可于 更多-->按键设置 编辑更改快捷键设定图：如何录制脚本？ "},"FAQ/faq-0026.html":{"url":"FAQ/faq-0026.html","title":"如何运行脚本？","keywords":"","body":"如何运行脚本？ 启动 XXTouch 的 App 后可以看到 “我的脚本” 界面点一下需要选择的脚本文件名默认可以使用 按一下音量键 弹出选择启动选中脚本再次使用 按一下音量键 可以选择暂停或停止脚本可于 更多-->按键设置 编辑更改快捷键设定图：如何运行已经选中的脚本？ "},"FAQ/faq-0027.html":{"url":"FAQ/faq-0027.html","title":"如何选择脚本？","keywords":"","body":"如何选择脚本？ 启动 XXTouch 的 App 后可以看到 “我的脚本” 界面点一下需要选择的脚本文件名 "},"FAQ/faq-0028.html":{"url":"FAQ/faq-0028.html","title":"如何在设备上编辑脚本？","keywords":"","body":"如何在设备上编辑脚本？ 启动 XXTouch 的 App 后可以看到 “我的脚本” 界面点一下脚本文件右边的 ⓘ点一下左边出现的 按钮 "},"FAQ/faq-0029.html":{"url":"FAQ/faq-0029.html","title":"如何加密脚本？","keywords":"","body":"如何加密脚本？ 图：如何加密脚本 "},"FAQ/faq-0030.html":{"url":"FAQ/faq-0030.html","title":"脚本可以做什么？","keywords":"","body":"脚本可以做什么？ 《XXTouch iOS 开发手册》 "},"FAQ/faq-0031.html":{"url":"FAQ/faq-0031.html","title":"加密的脚本可以被解密么？","keywords":"","body":"加密的脚本可以被解密么？ 不可以从脚本源码到加密脚本这一过程是单向的，不可逆的源码可以加密成加密脚本，反之加密脚本是无法还原成源码的 "},"FAQ/faq-0032.html":{"url":"FAQ/faq-0032.html","title":"XXTouch 可以在电脑上运行么？","keywords":"","body":"XXTouch 可以在电脑上运行么？ 不可以XXTouch 只有 iOS 端 "},"FAQ/faq-0033.html":{"url":"FAQ/faq-0033.html","title":"XXTouch 可以在安卓系统上运行么？","keywords":"","body":"XXTouch 可以在安卓系统上运行么？ 不可以XXTouch 只有 iOS 端 "},"FAQ/faq-0034.html":{"url":"FAQ/faq-0034.html","title":"XXTouch 可以在没有越狱的 iOS 设备上运行么？","keywords":"","body":"XXTouch 可以在没有越狱的 iOS 设备上运行么？ 不可以XXTouch 必须要设备已经能够越狱获取完整系统权限方可运行 "},"FAQ/faq-0035.html":{"url":"FAQ/faq-0035.html","title":"已知的与 XXTouch 一定会产生冲突的插件参考","keywords":"","body":"已知的与 XXTouch 一定会产生冲突的插件参考 《按键精灵》 "},"Handbook/index.html":{"url":"Handbook/index.html","title":"XXTouch iOS 开发手册","keywords":"","body":"XXTouch iOS 开发手册 关于 XXTouch 如何阅读本手册 如何使用 XXTouch 保护脚本，正确接受 require 基本控制函数 结束脚本 (os.exit) 重启脚本 (os.restart) 脚本被终止时执行一些代码的方法 开发辅助函数 打印内容到缓冲区 (print) 将打印缓冲区的内容提出来 (print.out) 网络日志 (nLog) 屏幕模块 初始化旋转坐标系 (screen.init) 坐标旋转转换 (screen.rotate_xy) 获取屏幕尺寸 (screen.size) 保持屏幕 (screen.keep) 取消保持屏幕 (screen.unkeep) 获取屏幕上某点颜色 (screen.get_color) 获取屏幕上某点颜色 RGB (screen.get_color_rgb) 屏幕多点颜色匹配 (screen.is_colors) 多点相似度模式找色 (screen.find_color) 多点色偏模式找色 (screen.find_color) 获取屏幕图像 (screen.image) 屏幕区域文字识别 (screen.ocr_text) 屏幕找图 (screen.find_image) 模拟触摸模块 ! 模拟手指轻触一次屏幕 (touch.tap) 模拟手指接触屏幕 (touch.on) ! 模拟手指在屏幕上移动 (:move) ! 模拟手指在屏幕上施加压力 (:press) 模拟手指离开屏幕 (:off) 设置触摸事件对象移动步长 (:step_len) 设置触摸事件对象移动每步延迟 (:step_delay) ! 毫秒级延迟 (:msleep) 设置触摸圆点显示 (touch.show_pose) touch 示例代码 模拟按键模块 模拟按一下物理按键 (key.press) 模拟按下物理按键 (key.down) 松开按下的物理按键 (key.up) 模拟键入文本 (key.send_text) 示例及支持的键码列表 模拟重力加速计模块 模拟加速计数据 (accelerometer.simulate) 模拟摇一摇 (accelerometer.shake) 改变当前重力方向为 home 在左 (accelerometer.rotate_home_on_left) 改变当前重力方向为 home 在右 (accelerometer.rotate_home_on_right) 改变当前重力方向为 home 在上 (accelerometer.rotate_home_on_top) 改变当前重力方向为 home 在下 (accelerometer.rotate_home_on_bottom) 系统模块 显示提示文字 (sys.toast) 弹出系统提示 (sys.alert) 弹出输入提示 (sys.input_box) 输入文字 (sys.input_text) ! 毫秒级延迟 (sys.msleep) 获取当前毫秒级时间戳 (sys.mtime) ! 获取网络时间 (sys.net_time) 产生一个随机数 (sys.rnd) 获取设备当前内存状态信息 (sys.memory_info) 获取设备当前可用内存值 (sys.available_memory) 获取设备当前未使用的存储空间值 (sys.free_disk_space) 输出标准系统日志 (sys.log) 问系统一个问题 (sys.mgcopyanswer) 获取系统版本 (sys.version) 获取 XXTouch 版本 (sys.xtversion) 剪贴板模块 写内容进剪贴板 (pasteboard.write) 获取剪贴板中的数据 (pasteboard.read) 对话框模块 ! 建立一个对话框对象 (dialog) 配置对话框配置保存文件名 (:config) 配置对话框配置保存文件名 (:set_config) 配置对话框自动消失时间 (:timeout) 配置对话框自动消失时间 (:set_timeout) 配置对话框的标题 (:title) 配置对话框的标题 (:set_title) 配置对话框的尺寸 (:set_size) 配置对话框的位置及尺寸 (:set_frame) 配置对话框的圆角半径 (:set_corner_radius) 给对话框加上一个文本标签 (:add_label) 给对话框加上一个文本输入框 (:add_input) 给对话框加上一个图片 (:add_image) 给对话框加上一个开关 (:add_switch) 给对话框加上一个选择器 (:add_picker) 给对话框加上一个单选组 (:add_radio) 给对话框加上一个多选组 (:add_checkbox) 给对话框加上一个数值选择器 (:add_range) ! 将对话框弹出来并返回用户的选择 (:show) ! 在不弹出对话框的情况下获得对话框配置 (:load) 清理模块 清理某个或某组钥匙串信息 (clear.keychain) 清理所有应用程序钥匙串信息 (clear.all_keychain) 清理剪贴板 (clear.pasteboard) 清理浏览器Cookies (clear.cookies) 清理系统缓存 (clear.caches) 清除相册中所有本地照片 (clear.all_photos) 清理某个应用的存档数据 (clear.app_data) 清理 IDFA/V (clear.idfav) 应用程序模块 获取 App 的应用程序包路径 (app.bundle_path) 获取 App 的应用存档路径 (app.data_path) 获取 App 的应用分组信息 (app.group_info) 弹出一个应用通知 (app.pop_banner) 运行应用程序 (app.run) 关闭应用程序 (app.close) 模拟使用上划退出应用程序 (app.quit) 检测应用程序是否正在运行 (app.is_running) 输入文字 (app.input_text) 通过应用程序 bid 获取应用的本地化名字 (app.localized_name) 通过应用程序 bid 获取应用的图标数据 (app.png_data_for_bid) 通过应用程序 bid 获取其 pid (app.pid_for_bid) 获取应用程序当前内存消耗 (app.used_memory) 获取前台应用的 Bundle Identifier (app.front_bid) 获取前台应用的 Process Identifier (app.front_pid) 前台打开一个 URL (app.open_url) 获取设备所有的应用的 Bundle Identifier 列表 (app.bundles) 获取当前设备的进程列表 (app.all_procs) 设置前台应用程序加速齿轮 (app.set_speed_add) 安装IPA安装包 (app.install) 卸载一个应用 (app.uninstall) 备注 设备相关模块 重置自动锁屏倒计时 (device.reset_idle) 锁定屏幕 (device.lock_screen) 解锁屏幕 (device.unlock_screen) 获取屏幕锁定状态 (device.is_screen_locked) 获取前台应用的画面方向 (device.front_orien) 锁定设备屏幕旋转 (device.lock_orien) 解锁设备屏幕旋转锁 (device.unlock_orien) 获取屏幕旋转锁锁定状态 (device.is_orien_locked) 振动设备 (device.vibrator) 后台播放声音 (device.play_sound) 获取设备类型 (device.type) 获取设备名 (device.name) 设置设备名 (device.set_name) 获取设备UDID (device.udid) 获取设备的序列号 (device.serial_number) 获取设备的 WiFi MAC 地址 (device.wifi_mac) 获取设备所有的接口 IP (device.ifaddrs) 获取当前设备电池剩余电量 (device.battery_level) 获取当前设备充电状态 (device.battery_state) 打开设备 WiFi (device.turn_on_wifi) 关闭设备 WiFi (device.turn_off_wifi) 打开设备蜂窝数据 (device.turn_on_data) 关闭设备蜂窝数据 (device.turn_off_data) 打开设备蓝牙 (device.turn_on_bluetooth) 关闭设备蓝牙 (device.turn_off_bluetooth) 打开设备飞行模式 (device.turn_on_airplane) 关闭设备飞行模式 (device.turn_off_airplane) 连接到当前设置所选 VPN (device.turn_on_vpn) 断开已有的 VPN 连接 (device.turn_off_vpn) 判断当前是否打开了 VPN 开关 (device.is_vpn_on) 打开设备闪光灯 (device.flash_on) 关闭设备闪光灯 (device.flash_off) 打开“减少动态效果”开关 (device.reduce_motion_on) 关闭“减少动态效果”开关 (device.reduce_motion_off) 打开 AssistiveTouch (device.assistive_touch_on) 关闭 AssistiveTouch (device.assistive_touch_off) 获取背光亮度值 (device.brightness) 设置背光亮度 (device.set_brightness) 设置自动锁屏分钟数 (device.set_autolock_time) 设置设备音量 (device.set_volume) 加入到一个无线局域网 (device.join_wifi) 图片对象模块 判断一个值是否是图片对象 (image.is) 创建指定尺寸空白图片对象 (image.new) 图像合并 (image.oper_merge) 新建一个文本图片对象 (image.new_text_image) 从文件创建图片对象 (image.load_file) 从数据创建图片对象 (image.load_data) 从图片对象创建拷贝图片对象 (:copy) 从图片对象截取部分新建拷贝图片对象 (:crop) 保存图片对象到相册 (:save_to_album) 输出图片对象到一个 PNG 格式的文件 (:save_to_png_file) 输出图片对象到一个 JPEG 格式的文件 (:save_to_jpeg_file) 获取图片对象的 PNG 格式数据 (:png_data) 获取图片对象的 JPEG 格式数据 (:jpeg_data) 90度左旋图片对象 (:turn_left) 90度右旋图片对象 (:turn_right) 180度旋转图片对象 (:turn_upondown) 获取图片对象的尺寸 (:size) 获取图片对象某点颜色 (:get_color) 设置图片对象某点颜色 (:set_color) 颜色替换 (:replace_color) 图中贴图 (:draw_image) 二值化处理图片对象 (:binaryzation) 在图上找色 (:find_color) 图片多点颜色匹配 (:is_colors) 解码一个二维码图片 (:qr_decode) 销毁一个图片对象 (:destroy) cv - 图中找图 (:cv_find_image) cv - 图片自动二值化 (:cv_binaryzation) cv - 从图片创建一个拉伸的另外尺寸的图片 (:cv_resize) tesseract - 对图片进行 ocr 识别 (:tess_ocr) 进程字典 存储值到进程字典 (proc_put) 查看进程字典存储的值 (proc_get) 向进程队列词典中压入一个值 (proc_queue_push) 从进程队列词典中弹出一个值 (proc_queue_pop) 从进程队列词典中弹出所有值 (proc_queue_clear) 获取进程队列词典的尺寸 (proc_queue_size) 向进程队列词典头部压入一个值 (proc_queue_push_front) 向进程队列词典尾部压入一个值 (proc_queue_push_back) 从进程队列词典头部弹出一个值 (proc_queue_pop_front) 从进程队列词典尾部弹出一个值 (proc_queue_pop_back) 线程模块 前言 派发一个任务 (thread.dispatch) 获取当前任务的 ID (thread.current_id) 从队列中移除一项任务 (thread.kill) 阻塞等待一个任务完成 (thread.wait) 注册监听一个事件 (thread.register_event) 反注册监听一个事件 (thread.unregister_event) thread 示例代码 Web 视图模块 展现一个 webview (webview.show) 隐藏一个 webview (webview.hide) 在一个 webview 上执行一段 JS (webview.eval) 获取一个 webview 的区域及层级信息 (webview.frame) 销毁一个 webview (webview.destroy) webview 使用示例 XPP 脚本包模块 前言 获取当前脚本包的元信息 (xpp.info) 获取当前脚本包的包路径 (xpp.bundle_path) 获取当前脚本包中的资源路径 (xpp.resource_path) XUI 脚本配置界面模块 前言 展示一个配置界面 (xui.show) 收起正在展示的配置界面 (xui.dismiss) 校验配置界面的配置 (xui.setup) 重新加载当前正在展示的配置界面 (xui.reload) 获取配置界面的配置值 (xui.get) 设置配置界面上的某个控件的值 (xui.set) 读取某个配置分区所有配置 (xui.read) 覆盖写入配置表到某个配置分区 (xui.write) 清除某个配置分区所有的配置 (xui.clear) 扩展 table 模块 前言 深拷贝一个表 (table.deep_copy) 深打印一个表 (table.deep_print) 从字符串加载一个表 (table.load_string) 扩展 string 模块 前言 转成 16 进制文本 (string.to_hex) 从 16 进制文本转回 (string.from_hex) 将 GBK 编码的文本转成 UTF-8 编码的文本 (string.from_gbk) 计算字符串的 md5 哈希值 (string.md5) 计算字符串的 sha1 哈希值 (string.sha1) 对字符串进行 base64 编码 (string.base64_encode) 对 base64 编码的文本进行解码 (string.base64_decode) 对字符串进行加密 (string.aes128_encrypt) 解密一段已加密的字符串 (string.aes128_decrypt) 用分隔符规则分割一个字符串 (string.split) 去除文本左边空白字符 (string.ltrim) 去除文本右边空白字符 (string.rtrim) 去除文本左右两边空白字符 (string.trim) 去除文本中所有的空白字符 (string.atrim) 去除掉文本前的 UTF8-BOM (string.strip_utf8_bom) 生成随机字符串 (string.random) 比较两个版本号大小 (string.compare_version) 扩展 string 示例代码 ! HTTP 模块 前言 发起 GET 请求 (http.get) 发起 POST 请求 (http.post) HTTP 文件下载 (http.download) 发起 HEAD 请求 (http.head) 发起 DELETE 请求 (http.delete) 发起 PUT 请求 (http.put) ! FTP 模块 FTP 文件下载 (ftp.download) FTP 文件上传 (ftp.upload) JSON 模块 前言 将 Lua 值转成 JSON 字符串 (json.encode) 将 JSON 字符串转换成 Lua 值 (json.decode) JSON 中的 NULL 常量 (json.null) PLIST 文件读写模块 读取 plist 文件 (plist.read) 写入 plist 文件 (plist.write) 读取属性表数据 (plist.load) 取 Lua 表的属性表数据 (plist.dump) 小工具模块 给通讯录添加一个或多个联系人 (utils.add_contacts) 删除通讯录所有联系人 (utils.remove_all_contacts) 打开扫码器 (utils.open_code_scanner) 关闭扫码器 (utils.close_code_scanner) 将文本编码成二维码图片 (utils.qr_encode) 获得当前脚本的启动参数 (utils.launch_args) 判断当前脚本是否从 App 内启动 (utils.is_launch_via_app) 导入一个视频文件到相册 (utils.video_to_album) 文件操作模块 判断一个文件或目录是否存在 (file.exists) 获取目录所有文件名列表 (file.list) 获得一个文件的尺寸 (file.size) 读取一个文件中的所有数据 (file.reads) 将数据覆盖写入到文件 (file.writes) 将数据追加到文件末尾 (file.appends) 统计一个文本文件的总行数 (file.line_count) 获取一个文本文件指定行的数据 (file.get_line) 设置文本文件指定行的内容 (file.set_line) 在文本文件指定行前插入内容 (file.insert_line) 移除文件中指定行 (file.remove_line) 获取一个文本文件的所有行 (file.get_lines) 将一个顺序表转换逐行覆盖写入到文件中 (file.set_lines) 将一个顺序表转换逐行插入到文件指定行前 (file.insert_lines) VPN 配置模块 创建一个 VPN 配置 (vpnconf.create) 获取当前系统 VPN 的列表 (vpnconf.list) 选择一个 VPN 配置 (vpnconf.select) 删除一个 VPN 配置 (vpnconf.delete) 以当前选择的 VPN 建立连接 (vpnconf.connect) 断开当前的 VPN 连接 (vpnconf.disconnect) 获取当前选择的 VPN 的状态 (vpnconf.status) 云打码模块 初始化一个云打码平台 (cloud_ocr.ocr) 识别屏幕上的范围 (plat.ocr_screen) 识别图片文件 (plat.ocr_image) 识别图片对象 (plat.ocr_obj) 提交错误的识别 (plat.report_error) cloud_ocr 示例代码 系统回调消息 前言 电话呼入呼出回调消息 扫码结果回调消息 Activator 事件回调消息 HID 事件消息 地理位置伪装 伪装GPS位置 (gps.fake) 清除GPS伪装信息 (gps.clear) 外部扩展 大漠找字/文字识别 模块 已集成的开源扩展库 LuaCJSON 扩展库 LuaSocket 扩展库 luaiconv 编码转换扩展库 lpeg 扩展库 LuaFileSystem 扩展库 LuaSQLite3 模块 lcurl 模块 更多的编译好的开源扩展库 附录 开发及周边工具下载 扩展库及远程扩展接口 脚本守护模式是什么？ 开机启动的时机说明 \"URL Scheme\" 的相关应用 日期格式化相关 (os.date) 命令执行相关示例代码 (os.execute) string 库的相关应用 math 库的相关应用 学习 Lua 注意避开的坑 开发常见运行期错误参考 "},"Handbook/about-xxtouch/index.html":{"url":"Handbook/about-xxtouch/index.html","title":"关于 XXTouch","keywords":"","body":"关于 XXTouch XXTouch 使用 Lua 作为脚本语言，支持 Lua 5.3 版的所有语法与基本函数，并于其基础之上添加了一些扩展功能， 用于取色、找色、发送触摸、键盘事件等高级功能的实现。XXTouch 仅支持 UTF-8 编码的脚本。 "},"Handbook/how-to-read/index.html":{"url":"Handbook/how-to-read/index.html","title":"如何阅读本手册","keywords":"","body":"如何阅读本手册 入门需要拥有 Lua 基础，可以参考《Lua 5.3 中文手册》及《Lua 5.3 函数参考》 示例 代码中使用 0x 开头的数字为 16 进制数 ( 什么是 16 进制数? ) 参数描述中可选参数使用中括号包围 参数或返回值如果是表型固定结构值，则使用大括号表示表型结构 类型描述中 文本型 和 字符串型 都是 Lua 的 string 类型，但 文本型 一般是指可以打印的明文文字 章或节用叹号 ( ! ) 开头的说明这个函数或者这个模块的函数包含隐式 让出 (在这个函数返回之前，其它的 线程 可能会得到运行机会) 若无额外说明，手册内示例代码均不处理边界情况，不应该直接复制到自己的脚本中用 XXTouch-iOS-开发手册旧版文档XXTouch-iOS-开发手册离线档-20180604.zip "},"Handbook/how-to-use/index.html":{"url":"Handbook/how-to-use/index.html","title":"如何使用 XXTouch","keywords":"","body":"如何使用 XXTouch 脚本及相关资源存在设备的哪个位置？ 脚本存放目录为 /var/mobile/Media/1ferver/lua/scripts/ 插件存放目录为 /var/mobile/Media/1ferver/lib/ 资源存放目录为 /var/mobile/Media/1ferver/res/ 日志存放目录为 /var/mobile/Media/1ferver/log/ 文字识别字库存放目录为 /var/mobile/Media/1ferver/tessdata/ 内置脚本模块存放目录为 /var/mobile/Media/1ferver/lua/ 售前及安装答疑 前往查看 用户使用图文说明 前往查看 普通用户交流 QQ 群 与其它用户交流 483853614 开发相关及交流 QQ 群 开发及周边工具下载 与其它开发者交流 40898074 "},"Handbook/secure-require/index.html":{"url":"Handbook/secure-require/index.html","title":"保护脚本，正确接受 require","keywords":"","body":"保护脚本，正确接受 require 为何 require 可能带来安全风险？ XXTouch 加密的脚本模块可以被其它脚本或者模块以 require 方式引用 当您的加密脚本被 require 时，全局环境是不可信的，您的脚本调用的函数可能已经被替换 如何正确使用 require 呢？ XXTouch 保证部分模块的函数会在 require 之前恢复初始状态，这包括 os、io、string、device、http、file、table 模块所有函数 您可以深拷贝全局环境到模块内局部环境以确保安全调用上述模块中所有函数 例如 -- 在脚本的最前面加上这个代码 local _ENV = table.deep_copy(_ENV) -- 下面就是脚本的主体内容 -- -- 最后您可能还需要返回一些导出函数或者常量 并且保证当一个模块被 require 方式引用的时候，全局变量 been_require 会无条件置为 true 您可以通过这个全局变量的状态来判断自己是不是正在被 require 例如 -- 在脚本的最前面加上这个代码 if been_require then return -- 如果被 require 就直接退出 end -- 下面就是脚本的主体内容 "},"Handbook/control-flow/index.html":{"url":"Handbook/control-flow/index.html","title":"基本控制函数","keywords":"","body":"基本控制函数 结束脚本 (os.exit) 重启脚本 (os.restart) 脚本被终止时执行一些代码的方法 "},"Handbook/control-flow/os.exit.html":{"url":"Handbook/control-flow/os.exit.html","title":"结束脚本 (os.exit)","keywords":"","body":"结束脚本 (os.exit) 声明 os.exit() 说明 os.exit 是 lua 自带的结束进程的函数，在 XXTouch 是结束逻辑上的脚本进程在任意线程中调用都可以结束当前脚本进程，所有的线程、监听都会立即终止 示例 os.exit() "},"Handbook/control-flow/os.restart.html":{"url":"Handbook/control-flow/os.restart.html","title":"重启脚本 (os.restart)","keywords":"","body":"重启脚本 (os.restart) 声明 操作成败, 错误信息 = os.restart([ 脚本文件路径 ]) 参数及返回值 脚本文件路径 *1.1.2-2 新增 文本型，可选参数，当这里传入一个有效的脚本文件路径将会重启到目标脚本文件，默认为 \"\" 操作成败 布尔型，操作失败返回 false，只有传递了脚本文件路径的情况下才可能操作失败，操作成功则这个函数不会返回 错误信息 文本型，操作失败的情况下，会返回具体的错误信息 说明 在没有 脚本文件路径 参数的情况下这个函数调用会直接重启 当前脚本 进程，当前脚本会立即结束传入了有效的 脚本文件路径 参数的时脚本会结束并重新启动到 目标脚本文件操作失败的情况下，该函数会返回 false 并附带错误信息，操作失败通常是传入了非法参数 需要注意 当前脚本 的定义是启动的那份脚本，脚本文件被更改后使用 os.restart() 不会 启动更改之后的脚本文件如果可能，请 不要 在多线程环境使用该函数无延迟重启会导致的其它逻辑问题也需要作者规避当前函数暂 不支持 重启、启动 xpp 脚本包 脚本 示例 1 os.restart() -- 重启到 “当前脚本” (不是 “当前脚本文件”) 示例 2 os.restart(utils.launch_args().path) -- 重启到 “当前脚本文件” 注：上述代码中使用了非本章函数 utils.launch_args "},"Handbook/control-flow/terminate-callback.html":{"url":"Handbook/control-flow/terminate-callback.html","title":"脚本被终止时执行一些代码的方法","keywords":"","body":"脚本被终止时执行一些代码的方法 说明 这不是一个函数而是利用 Lua 的垃圾回收机制实现的，用于在脚本结束 (或被结束) 时执行一些代码的方法 原理 ：定义一个全局对象 (表型值) ，将其 析构函数 设为一个函数，当 Lua 虚拟机结束之时，所有 Lua 对象 (也包括你定义的这个) 的 析构函数 会被调用。Lua 中的 析构函数 是指对象的 __gc 元方法 简易示例 -- 关键词 脚本终止回调 脚本结束回调 随便取个变量名 = {} setmetatable(随便取个变量名, { __gc = function(...) sys.toast('被终止了！') sys.msleep(500) end }) -- while (true) do sys.toast(\"现在可尝试手动结束脚本\\n\\n\"..os.date(\"%Y-%m-%d %H:%M:%S\")) sys.msleep(1000) end 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、setmetatable 完整封装示例 function atexit(callback) -- 参数为一个函数，使用 atexit(一个函数) 注册一个函数在脚本结束时执行，建议不要耗时太长 ____atexit_guard____ = ____atexit_guard____ or {} if type(____atexit_guard____) == 'table' then if not getmetatable(____atexit_guard____) then setmetatable(____atexit_guard____, { __gc = function(self) if type(self.callback) == 'function' then pcall(self.callback) end end }) end ____atexit_guard____.callback = callback else error('别用 `____atexit_guard____` 命名你的变量。') end end -- 以上代码可拷贝到你的脚本的开头，以下为使用示例 -- -- 使用 atexit 注册一个终止回调函数 atexit(function() sys.toast('被终止了！') sys.msleep(500) end) -- while (true) do sys.toast(\"现在可尝试手动结束脚本\\n\\n\"..os.date(\"%Y-%m-%d %H:%M:%S\")) sys.msleep(1000) end 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、setmetatable "},"Handbook/develop-helper/index.html":{"url":"Handbook/develop-helper/index.html","title":"开发辅助函数","keywords":"","body":"开发辅助函数 打印内容到缓冲区 (print) 将打印缓冲区的内容提出来 (print.out) 网络日志 (nLog) "},"Handbook/develop-helper/print.html":{"url":"Handbook/develop-helper/print.html","title":"打印内容到缓冲区 (print)","keywords":"","body":"打印内容到缓冲区 (print) 声明 print([ 参数1, 参数2, ... ]) 参数及返回值 参数1, 参数2, ... 任意类型，可选参数，可变参数，将会转换成文本输出到缓冲区，参数之间用 \"\\t\" 隔开 说明 print 是 lua 自带的打印输入函数，在 XXTouch 是将内容打印到缓冲区 示例 print(\"hello world\") "},"Handbook/develop-helper/print.out.html":{"url":"Handbook/develop-helper/print.out.html","title":"将打印缓冲区的内容提出来 (print.out)","keywords":"","body":"将打印缓冲区的内容提出来 (print.out) 声明 缓冲区内容 = print.out() 说明 将 print 函数打印的缓冲区清空并返回缓冲区内容 示例 -- 使用一个弹窗显示 print 缓冲区内容 sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/develop-helper/nLog.html":{"url":"Handbook/develop-helper/nLog.html","title":"网络日志 (nLog)","keywords":"","body":"网络日志 (nLog) 声明 nLog(日志内容) 参数及返回值 日志内容 文本型，日志内容 说明 这个函数是协议函数 (空函数) ，默认执行不会产生任何效果，实现细节由配套开发环境决定当使用配套开发环境进行调试的时候这个函数将会将日志发回开发环境的日志框 示例 -- 将 print 缓冲区内容发回开发开发工具的日志窗 nLog(print.out()) "},"Handbook/screen/index.html":{"url":"Handbook/screen/index.html","title":"屏幕模块","keywords":"","body":"屏幕模块 初始化旋转坐标系 (screen.init) 坐标旋转转换 (screen.rotate_xy) 获取屏幕尺寸 (screen.size) 保持屏幕 (screen.keep) 取消保持屏幕 (screen.unkeep) 获取屏幕上某点颜色 (screen.get_color) 获取屏幕上某点颜色 RGB (screen.get_color_rgb) 屏幕多点颜色匹配 (screen.is_colors) 多点相似度模式找色 (screen.find_color) 多点色偏模式找色 (screen.find_color) 获取屏幕图像 (screen.image) 屏幕区域文字识别 (screen.ocr_text) 屏幕找图 (screen.find_image) "},"Handbook/screen/screen.init.html":{"url":"Handbook/screen/screen.init.html","title":"初始化旋转坐标系 (screen.init)","keywords":"","body":"初始化旋转坐标系 (screen.init) 声明 原坐标系 = screen.init(坐标系) 参数及返回值 坐标系 整数型，取值范围 0 表示竖屏 home 在下 1 表示横屏 home 在右 2 表示横屏 home 在左 3 表示竖屏 home 在上 原坐标系 整数型，返回这个函数调用之前使用的坐标系 说明 初始化取色或点击的坐标系使用以下别名调用也可以实现相同效果 screen.init_home_on_bottom() -- home 在下 screen.init_home_on_right() -- home 在右 screen.init_home_on_left() -- home 在左 screen.init_home_on_top() -- home 在上 示例 screen.init(0) -- home 在下 screen.init(1) -- home 在右 screen.init(2) -- home 在左 screen.init(3) -- home 在上 "},"Handbook/screen/screen.rotate_xy.html":{"url":"Handbook/screen/screen.rotate_xy.html","title":"坐标旋转转换 (screen.rotate_xy)","keywords":"","body":"坐标旋转转换 (screen.rotate_xy) 声明 旋转后的横坐标, 旋转后的纵坐标 = screen.rotate_xy(横坐标, 纵坐标, 旋转方向) 参数及返回值 横坐标, 纵坐标 整数型，需要旋转的坐标 旋转方向 整数型，旋转选项 0 表示不旋转 1 表示往左 90 度旋转 2 表示往右 90 度旋转 3 表示 180 度旋转 旋转后的横坐标, 旋转后的纵坐标 整数型，返回使用 旋转方向 作为选项旋转后的坐标 说明 坐标旋转转换，通常用于将竖屏坐标转换成横屏坐标这个函数在 1.1.1-1 版以上方可使用 示例 rx, ry = screen.rotate_xy(100, 200, 1) "},"Handbook/screen/screen.size.html":{"url":"Handbook/screen/screen.size.html","title":"获取屏幕尺寸 (screen.size)","keywords":"","body":"获取屏幕尺寸 (screen.size) 声明 屏宽, 屏高 = screen.size() 参数及返回值 屏宽 整数型 屏高 整数型 说明 这个函数的返回值不受当前设备的桌面或者应用的的横竖屏状态影响，也不受放大模式影响这个函数可以在 XUI 中使用 示例 -- 根据分辨率判断设备类型 width, height = screen.size() if width == 640 and height == 1136 then -- iPhone 5, 5S, iPod touch 5 elseif width == 640 and height == 960 then -- iPhone 4, 4S, iPod touch 4 elseif width == 750 and height == 1334 then -- iPhone 6, 6S, 7, 8 elseif width == 1242 and height == 2208 then -- iPhone 6+, 6S+, 7+, 8+ elseif width == 768 and height == 1024 then -- iPad 1, 2, mini 1 elseif width == 1536 and height == 2048 then -- iPad 3, 4, 5, mini 2 elseif width == 320 and height == 480 then -- 这个应该不可能 end "},"Handbook/screen/screen.keep.html":{"url":"Handbook/screen/screen.keep.html","title":"保持屏幕 (screen.keep)","keywords":"","body":"保持屏幕 (screen.keep) 声明 screen.keep() 说明 在脚本中保持当前屏幕内容不变，多次调用取色、找色、截图、找图等函数时，将直接调用保持的内容，而不会重复从屏幕获取图像，从而提升图色判断的性能。该函数为优化类函数，能够为大量的静态图像处理函数提供性能优化。调用仅会影响 XXTouch 截图取色函数的数据源，不会 导致屏幕画面卡住不动！！！ 示例 -- 遍历屏幕区块 screen.keep() for k = 1, 640, 10 do for j = 1, 960, 10 do - -格式化为十六进制文本 color = string.format(\"%X\", screen.get_color(k, j)); - -输出到系统日志 sys.log(\"(\"..k..\", \"..j..\") Color: \"..color..\".\"); end end screen.unkeep() 注：上述代码中使用了非本章函数 sys.log 小知识 针对同一位置两行连续单独的 screen.get_color 调用可能取到不同的值screen.keep 的情况下 screen.get_color 单独调用耗时会超过一次 screen.keep 的耗时调用 screen.keep 之后，再连续调用 50 次 screen.get_color 耗时可以等同于调用一次 screen.keep "},"Handbook/screen/screen.unkeep.html":{"url":"Handbook/screen/screen.unkeep.html","title":"取消保持屏幕 (screen.unkeep)","keywords":"","body":"取消保持屏幕 (screen.unkeep) 声明 screen.unkeep() 说明 取消 screen.keep 函数的效果，释放内存中的屏幕图像 示例 参考 screen.keep 示例 "},"Handbook/screen/screen.get_color.html":{"url":"Handbook/screen/screen.get_color.html","title":"获取屏幕上某点颜色 (screen.get_color)","keywords":"","body":"获取屏幕上某点颜色 (screen.get_color) 声明 颜色值 = screen.get_color(横坐标, 纵坐标) 参数及返回值 横坐标, 纵坐标 整数型，代表目标点的坐标 颜色值 整数型，返回目标点颜色的 RGB 值 说明 获取屏幕上某个坐标点的颜色 示例 local c = screen.get_color(512, 133) if c==0xffffff then sys.alert(\"512, 133 这个点是纯白色\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/screen/screen.get_color_rgb.html":{"url":"Handbook/screen/screen.get_color_rgb.html","title":"获取屏幕上某点颜色 RGB (screen.get_color_rgb)","keywords":"","body":"获取屏幕上某点颜色 RGB (screen.get_color_rgb) 声明 红, 绿, 蓝 = screen.get_color_rgb(横坐标, 纵坐标) 参数及返回值 横坐标, 纵坐标 整数型，代表目标点的坐标 红, 绿, 蓝 整数型，返回目标点颜色的 红、绿、蓝 值，取值范围 0~255 说明 获取屏幕上某个坐标点的颜色并拆分成 红(R) 绿(G) 蓝(B) 形式 示例 local r, g, b = screen.get_color_rgb(512, 133) if r==0xff and g==0xff and b==0xff then sys.alert(\"512, 133 这个点是纯白色\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/screen/screen.is_colors.html":{"url":"Handbook/screen/screen.is_colors.html","title":"屏幕多点颜色匹配 (screen.is_colors)","keywords":"","body":"屏幕多点颜色匹配 (screen.is_colors) 声明 是否完全匹配 = screen.is_colors({ {横坐标*, 纵坐标*, 颜色*}, {横坐标*, 纵坐标*, 颜色*}, ... }[, 颜色相似度]) 参数及返回值 横坐标*, 纵坐标* 整数型，代表其中某点坐标 颜色* 整数型，代表其中某点需要匹配的颜色值 颜色相似度 整数型，可选参数，代表需要的颜色的相似度，取值范围 1~100，默认 100 是否完全匹配 布尔型，所有点的颜色都匹配则返回 true，否则返回 false 说明 匹配屏幕上若干点的颜色 示例 if screen.is_colors({ { 509, 488, 0xec1c23}, -- 如果坐标 (509, 488) 的颜色与 0xec1c23 相似度在 90% 以上 { 514, 470, 0x00adee}, -- 同时坐标 (514, 470) 的颜色与 0x00adee 相似度在 90% 以上 { 508, 478, 0xffc823}, -- 同时坐标 (508, 478) 的颜色与 0xffc823 相似度在 90% 以上 { 511, 454, 0xa78217}, -- 同时坐标 (511, 454) 的颜色与 0xa78217 相似度在 90% 以上 { 521, 433, 0xd0d2d2}, -- 同时坐标 (521, 433) 的颜色与 0xd0d2d2 相似度在 90% 以上 }, 90) then -- 则匹配 sys.alert(\"匹配！\") else sys.alert(\"不匹配！\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/screen/screen.find_color-cs.html":{"url":"Handbook/screen/screen.find_color-cs.html","title":"多点相似度模式找色 (screen.find_color)","keywords":"","body":"多点相似度模式找色 (screen.find_color) 声明 横坐标, 纵坐标 = screen.find_color({ [find_all = 是否搜索多个结果], [max_results = 最大结果数], [max_miss = 允许最多未命中数], {起始点横坐标, 起始点纵坐标, 起始点颜色[, 起始点相似度]}, {偏移点横坐标*, 偏移点纵坐标*, 偏移点颜色*[, 偏移点相似度*]}, {偏移点横坐标*, 偏移点纵坐标*, 偏移点颜色*[, 偏移点相似度*]}, ... } [, 全局相似度, 左, 上, 右, 下 ]) 参数及返回值 是否搜索多个结果 布尔型，可选参数，这个标签设置为 true 会返回范围内所有匹配位置的一个表，格式为 {{x1, y1}, {x2, y2}, ...}，默认 false 最大结果数 整数型，可选参数，当 find_all (是否搜索多个结果) 标签设置为 true 的时候，这个表示最多返回结果数，最多可以设为 1000，默认 100 允许最多未命中数 *1.2-3 新增 整数型，可选参数，可以允许最多的不匹配的点的数量，默认为 0，也就是全命中才算找到 起始点横坐标, 起始点纵坐标 整数型，代表起始坐标，它并不是限制找色的范围为固定这一点，而仅仅是给偏移位置一个相对坐标，不理解就填 0, 0 起始点颜色 整数型，代表需要搜索的那一点的颜色 起始点相似度 整数型，可选参数，需要搜索的那一点颜色的相似度，取值范围 1~100，默认 100 偏移点横坐标*, 偏移点纵坐标* 整数型，代表一个偏移位置坐标 偏移点颜色* 整数型，代表偏移位置需要匹配的颜色 偏移点相似度* 整数型，可选参数，偏移位置的颜色的相似度，取值范围 -100~100，默认 100，负相似度意味着匹配小于该绝对值的相似度 全局相似度 整数型，可选参数，如果没有给单个点设置相似度，那么每一点都会用这个相似度，取值范围 1~100，默认 100 左, 上, 右, 下 整数型，可选参数，代表搜索区域，默认 全屏 横坐标, 纵坐标 整数型，返回匹配色的第一个色的坐标，搜索失败返回 -1, -1 说明 使用相似度模式查找，获取区域中第一个完全匹配的多点颜色结构的位置 示例 x, y = screen.find_color({ { 0, 0, 0xec1c23}, { 12, -3, 0xffffff, 85}, { 5, -18, 0x00adee}, { -1, -10, 0xffc823}, { 2, -34, 0xa78217}, { 12, -55, 0xd0d2d2}, }, 90, 0, 0, 100, 100) -- --[[ 在左上为 0, 0 右下为 100, 100 的区域找到第一点与 0xec1c23 相似度大于 90 且它的相对坐标 (12, -3) 的位置的颜色与 0xffffff 相似度大于 85 且它的相对坐标 (5, -18) 的位置的颜色与 0x00adee 相似度大于 90 且…… (后面的同理) 都能匹配的那个点 --]] -- -- 等效代码如下： -- x, y = screen.find_color({ { 509, 488, 0xec1c23}, { 521, 485, 0xffffff, 85}, { 514, 470, 0x00adee}, { 508, 478, 0xffc823}, { 511, 454, 0xa78217}, { 521, 433, 0xd0d2d2}, }, 90, 0, 0, 100, 100) -- --[[ 在左上为 0, 0 右下为 100, 100 的区域找到第一点与 0xec1c23 相似度大于 90 且它的相对坐标 (521-509, 485-488) 的位置的颜色与 0xffffff 相似度大于 85 且它的相对坐标 (514-509, 470-488) 的位置的颜色与 0x00adee 相似度大于 90 且…… (后面的同理) 都能匹配的那个点 --]] -- -- 不换行无缩进就是这个效果： x, y = screen.find_color({ {0,0,0xec1c23},{12,-3,0xffffff,85},{5,-18,0x00adee},{-1,-10,0xffc823},{2,-34,0xa78217},{12,-55,0xd0d2d2},},90,0,0,100,100) -- x, y = screen.find_color({ -- 反匹配演示，在 5C 主屏幕运行可获得结果 { 516, 288, 0xffffff }, { 519, 286, 0xffffff }, { 521, 289, 0xffffff }, { 516, 296, 0xffffff }, { 522, 297, 0xffffff }, { 520, 295, 0xffffff, -10 }, -- 这一点颜色与 0xffffff 相似度小于 10 才匹配，下同 { 515, 291, 0xffffff, -10 }, { 518, 284, 0xffffff, -10 }, { 523, 298, 0xffffff, -10 }, { 514, 298, 0xffffff, -10 }, { 514, 296, 0xffffff, -10 }, }, 90) -- 不写区域参数表示全屏找 -- results = screen.find_color({ -- 范围匹配全输出演示 { 527, 278, 0xde1d26 }, { 524, 285, 0x007aff }, { 555, 292, 0xe4ddc9 }, { 536, 314, 0xffde02 }, { 502, 291, 0xffde02 }, { 502, 283, 0xe4ddc9 }, find_all = true, -- 带这个标签将返回范围所有匹配的位置的一个表，格式为 { {x1, y1}, {x2, y2}, ...} }, 90) -- 不写区域参数表示全屏找 "},"Handbook/screen/screen.find_color-co.html":{"url":"Handbook/screen/screen.find_color-co.html","title":"多点色偏模式找色 (screen.find_color)","keywords":"","body":"多点色偏模式找色 (screen.find_color) 声明 横坐标, 纵坐标 = screen.find_color({ [find_all = 是否搜索多个结果], [max_results = 最大结果数], [max_miss = 允许最多未命中数], {起始点横坐标, 起始点纵坐标, {起始点颜色[, 起始点色偏]}}, {偏移点横坐标*, 偏移点纵坐标*, {偏移点颜色*, 偏移点色偏*}}, {偏移点横坐标*, 偏移点纵坐标*, {偏移点颜色*, 偏移点色偏*}}, ... } [, 左, 上, 右, 下 ]) 参数及返回值 是否搜索多个结果 布尔型，可选参数，这个标签设置为 true 会返回范围内所有匹配位置的一个表，格式为 {{x1, y1}, {x2, y2}, ...}，默认 false 最大结果数 整数型，可选参数，当 find_all (是否搜索多个结果) 标签设置为 true 的时候，这个表示最多返回结果数，最多可以设为 1000，默认 100 允许最多未命中数 *1.2-3 新增 整数型，可选参数，可以允许最多的不匹配的点的数量，默认为 0，也就是全命中才算找到 起始点横坐标, 起始点纵坐标 整数型，代表起始坐标，它并不是限制找色的范围为固定这一点，而仅仅是给偏移位置一个相对坐标，不理解就填 0, 0 起始点颜色 整数型，代表需要搜索的那一点的颜色 起始点色偏 整数型，需要搜索的颜色的最大色偏 (或偏色) ，大于 0xff000000 则为反匹配模式 偏移点横坐标*, 偏移点纵坐标* 整数型，代表一个偏移位置坐标 偏移点颜色* 整数型，代表偏移位置需要匹配的颜色 偏移点色偏* 整数型，偏移位置的颜色的色偏 (或偏色) ，大于 0xff000000 则为反匹配模式 左, 上, 右, 下 整数型，可选参数，代表搜索区域，默认 全屏 横坐标, 纵坐标 整数型，返回匹配色的第一个色的坐标，搜索失败返回 -1, -1 说明 使用色偏 (或偏色) 模式查找，获取区域中第一个完全匹配的多点颜色结构的位置色偏 (或偏色) 用于表示颜色偏差范围，一个颜色附带色偏 (或偏色) 是指该颜色的红、绿、蓝偏移范围内的所有颜色当 0x456789 色偏为 0x123456 的时候表示 0x456789 的红正负范围 0x12、绿正负范围 0x34、蓝正负范围 0x56，也就是其红色范围为 0x45 ± 0x12、绿色范围为 0x67 ± 0x34、蓝色的范围为 0x89 ± 0x56使用 0x 开头的数字为 16 进制数 ( 什么是 16 进制数? )如下表所述 {0x456789, 0x123456} 实际上就是表示从 0x333333 到 0x579BDF 之间所有的颜色 | 0x45 - 0x12 = 0x33 | 0x45 + 0x12 = 0x57 || 0x67 - 0x34 = 0x33 | 0x67 + 0x12 = 0x9B || 0x89 - 0x56 = 0x33 | 0x89 + 0x12 = 0xDF | 示例 x, y = screen.find_color({ { 0, 0, {0xec1c23, 0x000000}}, { 12, -3, {0xffffff, 0x101010}}, { 5, -18, {0x00adee, 0x123456}}, { -1, -10, {0xffc823, 0x101001}}, { 2, -34, {0xa78217, 0x101001}}, { 12, -55, {0xd0d2d2, 0x101001}}, }, 0, 0, 100, 100) -- --[[ 在左上为 0, 0 右下为 100, 100 的区域找到第一点与 0xec1c23 完全相似 (色偏为 0) 且它的相对坐标 (12, -3) 的位置的颜色与 0xffffff 的色偏小于 0x101010 且它的相对坐标 (5, -18) 的位置的颜色与 0x00adee 色偏小于 0x123456 且…… (后面的同理) 都能匹配的那个点 --]] -- -- 等效代码如下： -- x, y = screen.find_color({ { 509, 488, {0xec1c23, 0x000000}}, { 521, 485, {0xffffff, 0x101010}}, { 514, 470, {0x00adee, 0x123456}}, { 508, 478, {0xffc823, 0x101001}}, { 511, 454, {0xa78217, 0x101001}}, { 521, 433, {0xd0d2d2, 0x101001}}, }, 0, 0, 100, 100) -- --[[ 在左上为 0, 0 右下为 100, 100 的区域找到第一点与 0xec1c23 完全相似 (色偏为 0) 且它的相对坐标 (521-509, 485-488) 的位置的颜色与 0xffffff 的色偏小于 0x101010 且它的相对坐标 (514-509, 470-488) 的位置的颜色与 0x00adee 色偏小于 0x123456 且…… (后面的同理) 都能匹配的那个点 --]] -- -- 不换行无缩进就是这个效果： x, y = screen.find_color({ {0,0,{0xec1c23,0x000000} },{12,-3, {0xffffff,0x101010} },{5,-18, {0x00adee,0x123456} },{-1,-10,{0xffc823,0x101001} },{2,-34,{0xa78217,0x101001} },{12,-55,{0xd0d2d2,0x101001} }, },0,0,100,100) -- x, y = screen.find_color({ -- 反匹配演示，在 5C 主屏幕运行可获得结果 { 516, 288, {0xffffff, 0x101010} }, { 519, 286, {0xffffff, 0x101010} }, { 521, 289, {0xffffff, 0x101010} }, { 516, 296, {0xffffff, 0x101010} }, { 522, 297, {0xffffff, 0x101010} }, { 520, 295, {0xffffff, 0xff101010} }, -- 这一点颜色与 0xffffff 色差大于 0x101010 才匹配，下同 { 515, 291, {0xffffff, 0xff101010} }, { 518, 284, {0xffffff, 0xff101010} }, { 523, 298, {0xffffff, 0xff101010} }, { 514, 298, {0xffffff, 0xff101010} }, { 514, 296, {0xffffff, 0xff101010} }, }) -- 不写区域参数表示全屏找 -- results = screen.find_color({ -- 范围匹配全输出演示 { 527, 278, {0xde1d26, 0x101010} }, { 524, 285, {0x007aff, 0x101010} }, { 555, 292, {0xe4ddc9, 0x101010} }, { 536, 314, {0xffde02, 0x101010} }, { 502, 291, {0xffde02, 0x101010} }, { 502, 283, {0xe4ddc9, 0x101010} }, find_all = true, -- 带这个标签将返回范围所有匹配的位置的一个表，格式为 { {x1, y1}, {x2, y2}, ...} }) -- 不写区域参数表示全屏找 "},"Handbook/screen/screen.image.html":{"url":"Handbook/screen/screen.image.html","title":"获取屏幕图像 (screen.image)","keywords":"","body":"获取屏幕图像 (screen.image) 声明 图像 = screen.image([ 左, 上, 右, 下 ]) 参数及返回值 左, 上, 右, 下 整数型，可选参数，代表图像区域，默认 全屏 图像 图片对象，返回一个图片对象，用法参考 图片对象模块 (image) 说明 获取屏幕上区域或全部图像该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 示例 -- screen.image 的示例代码 -- screen.image():save_to_album() -- 全屏截图并保存到相册 -- screen.image():save_to_png_file(\"/var/mobile/1.png\") -- 全屏截图并保存到文件 /var/mobile/1.png -- screen.image(100, 100, 200, 200):save_to_album() -- 截取左上坐标为 100, 100 右下坐标为 200, 200 的区域图像保存到相册 -- pasteboard.write(screen.image(100, 100, 200, 200):png_data(), \"public.png\") -- 截取左上坐标为 100, 100 右下坐标为 200, 200 的区域图像写入到剪贴板 注：上述代码中使用了非本章函数 :save_to_album、:save_to_png_file、:png_data、pasteboard.write "},"Handbook/screen/screen.ocr_text.html":{"url":"Handbook/screen/screen.ocr_text.html","title":"屏幕区域文字识别 (screen.ocr_text)","keywords":"","body":"屏幕区域文字识别 (screen.ocr_text) 声明 识别结果, 结果详情 = screen.ocr_text(左, 上, 右, 下 [, 结果范围, 二值化选项 ]) 参数及返回值 左, 上, 右, 下 整数型，代表识别区域 结果范围 可以是 文本型 或 表型 参数 详情可参考 对图片进行 ocr 识别 二值化选项 *1.1.0-1 新增 可以是 实数型 或 文本型 或 表型 参数，分别代表 实数型，二值化阈值，可参考 图片自动二值化 表型，自定义二值化色偏，参考 图片手动二值化 文本型，自定义二值化色偏，参考 图片手动二值化 识别结果 文本型，识别返回的文字 结果详情 *1.1.3-1 新增 表型，识别结果的每个可见字符的位置描述 说明 识别屏幕区域上的文字，该函数会引用 image.tess_ocr 模块内置 OCR 识别库引擎为 tesseract 3.02 版，版本不对或者字库文件损坏会导致 XXTouch 脚本服务崩溃。这里提供适用于 XXTouch 的 tesseract 引擎版本为 3.05 版的 OCR 识别库 tess_ocr_1.2_with_tesseract_3.05.01.zipXXTouch 已内置 eng 识别库 [A-Za-z0-9] 能识别常规英文和数字如果需要做简体中文或是其它语言文字识别，需要手动导入相关的字库文件到设备的 /var/mobile/Media/1ferver/tessdata/ 目录这里提供 简体中文字库 (点击下载) 二值化选项 手动二值化在 1.1.0-1 版以上方可使用结果详情 在 1.1.3-1 版以上方可使用如果想自己进行 tesseract 字库训练可以 百度搜索“tesseract 训练” 示例 -- 示例 1： local txt = screen.ocr_text(187, 882, 298, 914) -- 默认配置是使用英文数字模式识别文字 sys.toast(\"识别结果：\"..txt:atrim()) -- -- 示例 2 (1.1.0-1 新增) ： local txt = screen.ocr_text(465, 241, 505, 269, \"eng\", \"9D5D39-0F1F26,D3D3D2-2C2C2D\") -- 使用色偏二值化识别 sys.toast(\"识别结果：\"..txt:atrim()) -- -- 示例 3 (1.1.0-1 新增) ： local txt = screen.ocr_text(465, 241, 505, 269, \"eng\", { {0x9D5D39, 0x0F1F26}, {0xD3D3D2, 0x2C2C2D} }) -- 使用色偏二值化识别，同上 sys.toast(\"识别结果：\"..txt:atrim()) -- -- 示例 4： local txt = screen.ocr_text(187, 882, 298, 914, { lang = \"chi_sim\", -- 使用简体中文库识别（注意，简体中文库不是内置的） white_list = \"你我他\", -- 白名单设为 \"你我他\" }) sys.toast(\"识别结果：\"..txt:atrim()) -- -- 示例 5 (1.1.0-1 新增) ： local txt = screen.ocr_text(187, 882, 298, 914, { lang = \"eng\", white_list = \"1234567890\", -- 自定义使用白名单限制仅识别为数字 }, \"9D5D39-0F1F26,D3D3D2-2C2C2D\") -- 使用色偏二值化识别 sys.toast(\"识别结果：\"..txt:atrim()) 注：上述代码中使用了非本章函数 sys.toast、string.atrim "},"Handbook/screen/screen.find_image.html":{"url":"Handbook/screen/screen.find_image.html","title":"屏幕找图 (screen.find_image)","keywords":"","body":"屏幕找图 (screen.find_image) 声明 横坐标, 纵坐标 = screen.find_image(图片 [, 相似度, 左, 上, 右, 下 ]) 参数及返回值 图片 字符串型 需要找的图片，可以是 png 或是 jpeg 格式的图片数据 图片对象 或是一个图片对象 (可参考 图片对象模块 (image) ) 文本型 *1.1.2-1 新增 需要找的图片文件路径，如果不是合法路径则会以数据方式解析 相似度 整数型，可选参数，需要找的图片的相似度，范围 1~100，默认为 95 左, 上, 右, 下 整数型，可选参数，搜索区域，默认 全屏 横坐标, 纵坐标 整数型，返回找到的图片的左上角坐标，搜索失败返回 -1, -1 说明 在屏幕上寻找一个图像的位置，该函数会引用 image.cv 模块注意： 如果需要做多分辨率兼容，那么建议是于分辨率最小的设备上截图；大分辨率上的截图会无法在小分辨率设备上找到 示例 XXT 取色器 1.0.12 Windows 版.zip -- 示例 1 (使用 XXT 取色器 Shift + 鼠标左键框选图像上的区域 可直接生成这样的代码) ： x, y = screen.find_image( -- 原图位置 左上: 354, 274 | 右下: 358, 284 \"\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x0a\\x08\\x02\\x00\\x00\\x00\\x1c\\x99\\x68\\x59\\x00\\x00\\x00\\x61\\x49\\x44\\x41\\x54\\x78\\xda\\x63\\x78\\xfd\\xf4\\xda\\xff\\xff\\xff\\xff\\xfd\\xfb\\xf7\\xed\\xcb\\x5b\\x86\\xf7\\xaf\\x1f\\xfc\\x87\\x01\\x86\\x2f\\x1f\\x5f\\x02\\xa9\\xef\\xa7\\xce\\x7c\\xdd\\xb1\\x9b\\xe1\\xe7\\xf7\\xcf\\x40\\xce\\xeb\\xb2\\xea\\x7b\\xb2\\x6a\\x0c\\x7f\\xff\\xfe\\x01\\x72\\x9e\\x78\\x06\\x82\\x38\\x20\\xdd\\xbf\\x7e\\xdd\\x57\\xd4\\x82\\x72\\x7e\\xdd\\xba\\x0d\\x64\\x41\\x39\\x08\\xd3\\x80\\x38\\x6b\\xe3\\x7f\\x86\\x2a\\x30\\x02\\x72\\x8c\\xa6\\x40\\x39\\x00\\xd5\\x7b\\x5f\\x2e\\xfd\\xba\\xd5\\x32\\x00\\x00\\x00\\x00\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\" , 95, 0, 0, 639, 1135) -- -- 示例 2： img = image.load_file(\"/var/mobile/1.png\") x, y = screen.find_image(img) x, y = screen.find_image(img, 95) -- -- 示例 4 (1.1.2-1 新增) ： x, y = screen.find_image(\"/var/mobile/1.png\", 95, 0, 0, 639, 1135) 说明：在 Lua 源码中，字符串中 \\x 开头，后面跟两位 16 进制数表示以该数字编码的单个字节。例如：\\x58 表示 X 这个字符，可打印字符部分参考《ASCII 编码》 复杂示例 -- 从网上下载个小图片 (一部分 XXTouch 图标) 然后从屏幕上找到它并点击 local c, h, r = http.get(\"https://www.xxtouch.com/img/find_image_test.png\", 10) if (c == 200) then local img = image.load_data(r) if img then x, y = screen.find_image(img, 95) if x~=-1 then touch.tap(x, y) else sys.alert(\"没有在屏幕上找到 XXTouch 图标\") end else sys.alert(\"可能下载到了一个假图片\") end else sys.alert(\"下载失败\") end 注：上述代码中使用了非本章函数 sys.alert、image.load_data、touch.tap、http.get "},"Handbook/touch/index.html":{"url":"Handbook/touch/index.html","title":"模拟触摸模块","keywords":"","body":"模拟触摸模块 ! 模拟手指轻触一次屏幕 (touch.tap) 模拟手指接触屏幕 (touch.on) ! 模拟手指在屏幕上移动 (:move) ! 模拟手指在屏幕上施加压力 (:press) 模拟手指离开屏幕 (:off) 设置触摸事件对象移动步长 (:step_len) 设置触摸事件对象移动每步延迟 (:step_delay) ! 毫秒级延迟 (:msleep) 设置触摸圆点显示 (touch.show_pose) touch 示例代码 "},"Handbook/touch/touch.tap.html":{"url":"Handbook/touch/touch.tap.html","title":"! 模拟手指轻触一次屏幕 (touch.tap)","keywords":"","body":"! 模拟手指轻触一次屏幕 (touch.tap) 声明 touch.tap(横坐标, 纵坐标 [, 延迟毫秒, 操作后等待毫秒 ]) 参数及返回值 横坐标, 纵坐标 整数型，需要轻触的点于当前旋转坐标系的坐标 延迟毫秒 整数型，可选参数，接触屏幕到离开屏幕之间的间隔时间，单位毫秒，默认 30 操作后等待毫秒 整数型，可选参数，轻触完成之后的等待时间，单位毫秒，默认 0 说明 模拟手指轻触一次屏幕指定位置这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会注: 该方法在调用完成之前会自动分配并占用一个手指 id，手指 id 的数量是有限的 (大约 30 个) ，超出限制再调用 touch.on 或 touch.tap 会抛出 finger pool overflow 错误，注意不要同时占用过多手指 id，及时调用 :off 方法释放手指 示例 touch.tap(100, 100) -- 点一下屏幕上 100, 100 这个位置 touch.tap(100, 100, 300) -- 在屏幕上的 100, 100 这个位置按下，等待 0.3 秒再抬起 touch.tap(100, 100, 300, 1000) -- 在屏幕上的 100, 100 这个位置按下，等待 0.3 秒再抬起，再等待 1 秒 "},"Handbook/touch/touch.on.html":{"url":"Handbook/touch/touch.on.html","title":"模拟手指接触屏幕 (touch.on)","keywords":"","body":"模拟手指接触屏幕 (touch.on) 声明 触摸事件 = touch.on(横坐标, 纵坐标) 参数及返回值 横坐标, 纵坐标 整数型，需要接触的点于当前旋转坐标系的坐标 触摸事件 触摸事件对象，通过调用 touch.on 函数可以并获得一个用于操控当前触摸的事件对象 说明 模拟手指接触屏幕指定位置，并返回一个用于操纵本次触摸过程的触摸事件对象注: 该函数会自动分配并占用一个手指 id，手指 id 的数量是有限的 (大约 30 个) ，超出限制再调用 touch.on 或 touch.tap 会抛出 finger pool overflow 错误，注意不要同时占用过多手指 id，及时调用 :off 方法释放手指该函数可同时使用以下方式调用（其中手指ID必须是范围在 1 ~ 29 的任意数字，这种方式要自行管理手指 id） touch.on(手指ID, 横坐标, 纵坐标) 示例 -- 模拟一个手指于点 100, 100 的位置接触屏幕，然后匀速滑动到点 200, 200 的位置，然后松开 touch.on(100, 100):move(200, 200):off() touch.on(1, 100, 100) -- 模拟编号为 1 的手指于点 100, 100 的位置接触屏幕 touch.off(1) -- 松开编号为 1 的手指 "},"Handbook/touch/_move.html":{"url":"Handbook/touch/_move.html","title":"! 模拟手指在屏幕上移动 (:move)","keywords":"","body":"! 模拟手指在屏幕上移动 (:move) 声明 触摸事件 = 触摸事件:move(横坐标, 纵坐标) 参数及返回值 横坐标, 纵坐标 整数型，需要移动至的点于当前旋转坐标系的坐标 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 模拟手指从当前位置移动到其它的位置这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会该函数可同时使用以下方式调用（其中手指ID必须是范围在 1 ~ 29 的任意数字） touch.move(手指ID, 横坐标, 纵坐标) touch.move(手指ID, 横坐标, 纵坐标, 压力值) 该调用方式与 :move 方法不同之处在于，它是立刻移动到目标位置，不能设置步进 示例 -- 模拟一个手指于点 100, 100 的位置接触屏幕，然后匀速滑动到点 200, 200 的位置，然后松开 touch.on(100, 100):move(200, 200):off() -- 另外一个用法 touch.on(1, 100, 100) -- 模拟编号为 1 的手指于点 100, 100 的位置接触屏幕 for i=1, 100 do -- 循环逐步移动编号为 1 的手指到点 100, 200 的位置 touch.move(1, 100, 100 + i) end touch.off(1) -- 松开编号为 1 的手指 "},"Handbook/touch/_press.html":{"url":"Handbook/touch/_press.html","title":"! 模拟手指在屏幕上施加压力 (:press)","keywords":"","body":"! 模拟手指在屏幕上施加压力 (:press) 声明 触摸事件 = 触摸事件:press([ 压力, 速度 ]) 参数及返回值 压力 整数型，可选参数，压力，范围 1~10000，默认 1000 速度 整数型，可选参数，施加压力的速度，范围 1~100，默认 最快速 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 模拟手指在当前位置施加压力，该方法仅能用于支持 3D Touch 的设备这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会 示例 touch.on(100, 100):press():off() -- 模拟一个手指于点 100, 100 的位置接触屏幕，然后用力按下去，然后松手 touch.on(100, 100):press(2000):off() -- 上面例子改一点压力 touch.on(100, 100):press(2000, 50):off() -- 上面例子改一点压力，按压速度放慢 "},"Handbook/touch/_off.html":{"url":"Handbook/touch/_off.html","title":"模拟手指离开屏幕 (:off)","keywords":"","body":"模拟手指离开屏幕 (:off) 声明 触摸事件:off([ 横坐标, 纵坐标 ]) 参数及返回值 横坐标, 纵坐标 整数型，可选参数，手指离开屏幕的点于当前旋转坐标系的坐标，默认 当前 te 事件记录的坐标 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 模拟手指从当前位置或指定位置离开屏幕，该方法调用会释放当前触摸事件对象该方法会释放掉 touch.on 返回的触摸事件对象所占用的手指 id该函数可同时使用以下方式调用（其中手指ID必须是范围在 1 ~ 29 的任意数字） touch.off(手指ID) touch.off(手指ID, 横坐标, 纵坐标) 示例 touch.on(100, 100):off() -- 模拟一个手指于点 100, 100 的位置接触屏幕，然后于当前位置离开屏幕 touch.on(100, 100):off(105, 95) -- 模拟一个手指于点 100, 100 的位置接触屏幕，然后于 105, 95 这个位置离开屏幕 -- 另外一个用法 touch.on(1, 100, 100) -- 模拟编号为 1 的手指于点 100, 100 的位置接触屏幕 for i=1, 100 do -- 循环逐步移动编号为 1 的手指到点 100, 200 的位置 touch.move(1, 100, 100 + i) end touch.off(1) -- 松开编号为 1 的手指 "},"Handbook/touch/_step_len.html":{"url":"Handbook/touch/_step_len.html","title":"设置触摸事件对象移动步长 (:step_len)","keywords":"","body":"设置触摸事件对象移动步长 (:step_len) 声明 触摸事件 = 触摸事件:step_len(步长) 参数及返回值 步长 整数型，可选参数，默认为 2 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 设置当前触摸事件对象使用 move 方法滑动的步长 示例 -- 模拟一个手指于点 100, 100 的位置接触屏幕，以步长为 3 、每步延迟为 0.2 毫秒的速度滑动到点 200, 200 的位置离开屏幕 touch.on(100, 100):step_len(3):step_delay(0.2):move(200, 200):off() "},"Handbook/touch/_step_delay.html":{"url":"Handbook/touch/_step_delay.html","title":"设置触摸事件对象移动每步延迟 (:step_delay)","keywords":"","body":"设置触摸事件对象移动每步延迟 (:step_delay) 声明 触摸事件 = 触摸事件:step_delay(每步延迟) 参数及返回值 每步延迟毫秒 实数型，可选参数，每步延迟时间，单位毫秒，默认 0.1 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 设置当前触摸事件对象使用 move 方法滑动的每步延迟 示例 -- 模拟一个手指于点 100, 100 的位置接触屏幕，以步长为 3 、每步延迟为 0.2 毫秒的速度滑动到点 200, 200 的位置离开屏幕 touch.on(100, 100):step_len(3):step_delay(0.2):move(200, 200):off() "},"Handbook/touch/_msleep.html":{"url":"Handbook/touch/_msleep.html","title":"! 毫秒级延迟 (:msleep)","keywords":"","body":"! 毫秒级延迟 (:msleep) 声明 触摸事件 = 触摸事件:msleep(毫秒数) 参数及返回值 毫秒数 实数型，可选参数，延迟时间，单位毫秒，默认 0.1 触摸事件 触摸事件对象，通过调用 touch.on 函数可以获得一个用于操控当前触摸的事件对象 说明 延迟函数，这个函数不会对对象有影响，仅仅起个阻塞当前线程的作用，该方法有个别名 :delay这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会 示例 -- 模拟一个手指于点 100, 100 的位置接触屏幕，等待 300 毫秒，离开屏幕 touch.on(100, 100):msleep(300):off() "},"Handbook/touch/touch.show_pose.html":{"url":"Handbook/touch/touch.show_pose.html","title":"设置触摸圆点显示 (touch.show_pose)","keywords":"","body":"设置触摸圆点显示 (touch.show_pose) 声明 touch.show_pose(是否显示) 参数及返回值 是否显示 布尔型，true 为显示；false 为不显示 说明 设置 touch 模块函数调用时是否显示圆点在屏幕上打开圆点显示会极大降低 touch 模块函数的效率，并且长时间使用会影响系统稳定性，建议仅用于调试环境 示例 touch.show_pose(true) touch.tap(100, 100) "},"Handbook/touch/samples-1.html":{"url":"Handbook/touch/samples-1.html","title":"touch 示例代码","keywords":"","body":"touch 示例代码 示例 -- 可以这样： touch.on(306, 300):step_len(2):step_delay(0):move(350, 800):msleep(1000):off() -- -- 上面那个例子也能写成这样： touch.on(306, 300) -- 模拟手指在 306,300 这个坐标点接触屏幕 :step_len(2) -- 设置移动步长为 2 :step_delay(0) -- 设置移动每步延迟为 0 :move(350, 800) -- 以上面两个参数所设置移动到 350,800 这个坐标 :msleep(1000) -- 等 1000 毫秒 (也就是 1 秒) :off() -- 手指离开屏幕 -- -- 或是这样： local te = touch.on(306,300) te:step_len(2) te:step_delay(0) te:move(350, 800) te:msleep(1000) te:off() -- -- 通常情况下，滑动代码可以写成这样 touch.on(306, 300) :move(350, 800) :msleep(1000) :off() -- -- 等效于 touch.on(306, 300):move(350, 800):msleep(1000):off() -- -- 也可以这样用于模拟轻触屏幕一次 touch.on(306, 300):msleep(30):off() -- 快速精确滑动技巧 -- 快速精确滑动可能需要一些技巧，看下面的例子以及注释 touch.on(125, 2000) -- 在起始坐标按下 :step_len(10) -- 步长设长以便加速滑动 :move(125, 555) -- 快速移动到接近目标位置 :step_len(1) -- 步长设短缓冲防止惯性 :move(125, 505) -- 慢速移动目标位置 :delay(100) -- 抬起前等待一段时间 :off() -- 抬起手指 "},"Handbook/key/index.html":{"url":"Handbook/key/index.html","title":"模拟按键模块","keywords":"","body":"模拟按键模块 模拟按一下物理按键 (key.press) 模拟按下物理按键 (key.down) 松开按下的物理按键 (key.up) 模拟键入文本 (key.send_text) 示例及支持的键码列表 "},"Handbook/key/key.press.html":{"url":"Handbook/key/key.press.html","title":"模拟按一下物理按键 (key.press)","keywords":"","body":"模拟按一下物理按键 (key.press) 声明 key.press(按键码) 参数及返回值 按键码 文本型，物理按键的按键码，键码在 示例及支持的键码列表 一节查看 说明 模拟按下物理按键然后松开它与此函数已知的冲突插件：Background Manager 示例 本章结尾 "},"Handbook/key/key.down.html":{"url":"Handbook/key/key.down.html","title":"模拟按下物理按键 (key.down)","keywords":"","body":"模拟按下物理按键 (key.down) 声明 key.down(按键码) 参数及返回值 按键码 文本型，物理按键的按键码，键码在 示例及支持的键码列表 一节查看 说明 模拟按下物理按键注意 这个函数应当有对应的 key.up 调用，否则在脚本终止之后，会发生按键一直不释放的问题。与此函数已知的冲突插件：Background Manager 示例 本章结尾 "},"Handbook/key/key.up.html":{"url":"Handbook/key/key.up.html","title":"松开按下的物理按键 (key.up)","keywords":"","body":"松开按下的物理按键 (key.up) 声明 key.up(按键码) 参数及返回值 按键码 文本型，物理按键的按键码，键码在 示例及支持的键码列表 一节查看 说明 模拟松开按下物理按键与此函数已知的冲突插件：Background Manager 示例 本章结尾 "},"Handbook/key/key.send_text.html":{"url":"Handbook/key/key.send_text.html","title":"模拟键入文本 (key.send_text)","keywords":"","body":"模拟键入文本 (key.send_text) 声明 key.send_text(文本 [, 每键延迟 ]) 参数及返回值 文本 文本型，待输入的文字，只能是英文数字和半角字符还有 \"\\b\" \"\\r\" \"\\t\" 每键延迟 整数型，输入每次按键延迟，默认没有延迟以设备性能极限输入 说明 该函数可用于所有的 input_text 函数都无效的情况下，强行模拟键盘键入亲测可以输入支付宝的支付密码与此函数已知的冲突插件：Background Manager 示例 key.send_text(\"AbC12#\") -- 尽可能快的键入文本 -- key.send_text(\"AbC12#\", 300) -- 每键入一次延迟 0.3 秒 "},"Handbook/key/samples.html":{"url":"Handbook/key/samples.html","title":"示例及支持的键码列表","keywords":"","body":"示例及支持的键码列表 模拟按 HOME 键 key.press(\"HOMEBUTTON\") 模拟长按 HOME 键 key.down(\"HOMEBUTTON\") -- 按下 HOME 键 sys.msleep(1000) -- 等待 1 秒 key.up(\"HOMEBUTTON\") -- 松开 HOME 键 模拟双击 HOME 键 key.press(\"HOMEBUTTON\") key.press(\"HOMEBUTTON\") 模拟按锁屏键 (电源键) key.press(\"LOCK\") 模拟按回车键 key.press(\"RETURN\") 其它模拟 -- 下面这个例子是模拟组合键 [command + v] 粘贴剪贴板的文本 (不是 windows 上的 control + v ) key.down(\"LEFTCOMMAND\") -- 按下 command 键 sys.msleep(20) -- 等待 20 毫秒 key.press(\"V\") -- 按一下 v 键 sys.msleep(20) -- 等待 20 毫秒 key.up(\"LEFTCOMMAND\") -- 松开 command 键 -- key.press(\"VOLUMEUP\") -- 按一下音量 + 键 key.press(\"VOLUMEDOWN\") -- 按一下音量 - 键 -- key.down(\"VOLUMEUP\") -- 按下音量 + 键 sys.msleep(1000) -- 等待 1 秒 key.up(\"VOLUMEUP\") -- 松开音量 + 键 -- key.down(\"LOCK\") -- 按下锁屏键 (电源键) sys.msleep(3000) -- 等待 3 秒 key.up(\"LOCK\") -- 松开锁屏键 (电源键) -- key.press(\"SHOW_HIDE_KEYBOARD\") -- 按一下[隐藏/显示键盘键]隐藏虚拟键盘 -- key.press(\"SHOW_HIDE_KEYBOARD\") -- 再按一下[隐藏/显示键盘键]显示虚拟键盘 -- -- 下面这个例子是模拟组合键 [锁屏键 + HOME键] 实现截屏到相册 key.down(\"LOCK\") -- 按下锁屏键 (电源键) sys.msleep(100) -- 等待 100 毫秒 key.press(\"HOMEBUTTON\") -- 按一下 HOME 键 sys.msleep(100) -- 等待 100 毫秒 key.up(\"LOCK\") -- 松开锁屏键 (电源键) -- -- iOS7、iOS8 切换输入法的组合键 key.down(\"LEFTCOMMAND\") sys.msleep(50) key.press(\" \") sys.msleep(50) key.up(\"LEFTCOMMAND\") -- -- iOS9 切换输入法的组合键 key.down(\"LEFTCONTROL\") sys.msleep(50) key.press(\"SPACE\") sys.msleep(50) key.up(\"LEFTCONTROL\") 注：上述代码中使用了非本章函数 sys.msleep 支持的键码列表 -- 字母键： \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\" -- -- 数字键： \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"0\" -- -- 功能键： \"F1\" \"F2\" \"F3\" \"F4\" \"F5\" \"F6\" \"F7\" \"F8\" \"F9\" \"F10\" \"F11\" \"F12\" -- -- 其它键： \"RETURN\" --\" 键 \"SLASH\" -- "},"Handbook/accelerometer/index.html":{"url":"Handbook/accelerometer/index.html","title":"模拟重力加速计模块","keywords":"","body":"模拟重力加速计模块 模拟加速计数据 (accelerometer.simulate) 模拟摇一摇 (accelerometer.shake) 改变当前重力方向为 home 在左 (accelerometer.rotate_home_on_left) 改变当前重力方向为 home 在右 (accelerometer.rotate_home_on_right) 改变当前重力方向为 home 在上 (accelerometer.rotate_home_on_top) 改变当前重力方向为 home 在下 (accelerometer.rotate_home_on_bottom) "},"Handbook/accelerometer/accelerometer.simulate.html":{"url":"Handbook/accelerometer/accelerometer.simulate.html","title":"模拟加速计数据 (accelerometer.simulate)","keywords":"","body":"模拟加速计数据 (accelerometer.simulate) 声明 accelerometer.simulate(横坐标, 纵坐标, 垂直坐标, 附加选项) 参数及返回值 横坐标 实数型， x 轴加速度 纵坐标 实数型， y 轴加速度 垂直坐标 实数型， z 轴加速度 附加选项 整数型 0 为普通 1 为摇晃 说明 模拟加速器数据这个函数不支持 iOS 10 及以上版本操作系统 示例 for i = 1, 100 do accelerometer.simulate(i, i, i, 0) end "},"Handbook/accelerometer/accelerometer.shake.html":{"url":"Handbook/accelerometer/accelerometer.shake.html","title":"模拟摇一摇 (accelerometer.shake)","keywords":"","body":"模拟摇一摇 (accelerometer.shake) 声明 accelerometer.shake() 说明 对 accelerometer.simulate 的封装，模拟摇一摇手机这个函数不支持 iOS 10 及以上版本操作系统 示例 for i = 1, 10 do -- 摇十下 accelerometer.shake() sys.msleep(1000) end 注：上述代码中使用了非本章函数 sys.msleep "},"Handbook/accelerometer/accelerometer.rotate_home_on_left.html":{"url":"Handbook/accelerometer/accelerometer.rotate_home_on_left.html","title":"改变当前重力方向为 home 在左 (accelerometer.rotate_home_on_left)","keywords":"","body":"改变当前重力方向为 home 在左 (accelerometer.rotate_home_on_left) 声明 accelerometer.rotate_home_on_left() 说明 对 accelerometer.simulate 的封装如果前台 App 并不支持横屏，那这个调用无效果这个函数不支持 iOS 10 及以上版本操作系统 示例 accelerometer.rotate_home_on_left() "},"Handbook/accelerometer/accelerometer.rotate_home_on_right.html":{"url":"Handbook/accelerometer/accelerometer.rotate_home_on_right.html","title":"改变当前重力方向为 home 在右 (accelerometer.rotate_home_on_right)","keywords":"","body":"改变当前重力方向为 home 在右 (accelerometer.rotate_home_on_right) 声明 accelerometer.rotate_home_on_right() 说明 对 accelerometer.simulate 的封装如果前台 App 并不支持横屏，那这个调用无效果这个函数不支持 iOS 10 及以上版本操作系统 示例 accelerometer.rotate_home_on_right() "},"Handbook/accelerometer/accelerometer.rotate_home_on_top.html":{"url":"Handbook/accelerometer/accelerometer.rotate_home_on_top.html","title":"改变当前重力方向为 home 在上 (accelerometer.rotate_home_on_top)","keywords":"","body":"改变当前重力方向为 home 在上 (accelerometer.rotate_home_on_top) 声明 accelerometer.rotate_home_on_top() 说明 对 accelerometer.simulate 的封装如果前台 App 并不支持竖屏，那这个调用无效果这个函数不支持 iOS 10 及以上版本操作系统 示例 accelerometer.rotate_home_on_top() "},"Handbook/accelerometer/accelerometer.rotate_home_on_bottom.html":{"url":"Handbook/accelerometer/accelerometer.rotate_home_on_bottom.html","title":"改变当前重力方向为 home 在下 (accelerometer.rotate_home_on_bottom)","keywords":"","body":"改变当前重力方向为 home 在下 (accelerometer.rotate_home_on_bottom) 声明 accelerometer.rotate_home_on_bottom() 说明 对 accelerometer.simulate 的封装如果前台 App 并不支持竖屏，那这个调用无效果这个函数不支持 iOS 10 及以上版本操作系统 示例 accelerometer.rotate_home_on_bottom() "},"Handbook/sys/index.html":{"url":"Handbook/sys/index.html","title":"系统模块","keywords":"","body":"系统模块 显示提示文字 (sys.toast) 弹出系统提示 (sys.alert) 弹出输入提示 (sys.input_box) 输入文字 (sys.input_text) ! 毫秒级延迟 (sys.msleep) 获取当前毫秒级时间戳 (sys.mtime) ! 获取网络时间 (sys.net_time) 产生一个随机数 (sys.rnd) 获取设备当前内存状态信息 (sys.memory_info) 获取设备当前可用内存值 (sys.available_memory) 获取设备当前未使用的存储空间值 (sys.free_disk_space) 输出标准系统日志 (sys.log) 问系统一个问题 (sys.mgcopyanswer) 获取系统版本 (sys.version) 获取 XXTouch 版本 (sys.xtversion) "},"Handbook/sys/sys.toast.html":{"url":"Handbook/sys/sys.toast.html","title":"显示提示文字 (sys.toast)","keywords":"","body":"显示提示文字 (sys.toast) 声明 sys.toast(文字内容 [, 旋转方向 ]) 参数及返回值 文字内容 文本型， 代表需要显示的文字 旋转方向 整数型，屏幕旋转方向，可选参数，默认为最后一次调用 screen.init 所设的那个方向 0 表示竖屏 home 在下 1 表示横屏 home 在右 2 表示横屏 home 在左 3 表示竖屏 home 在上 -1 表示立刻隐藏 toast 说明 在当前旋转坐标系的屏幕下方显示提示文字该函数是异步进行的，提示文字总计显示时间为 2.8 秒，会影响取色，不会拦截点击 示例 -- 显示一个 toast sys.toast(\"果断 hello world\") 示例 -- 实时显示当前日期时间 while (true) do sys.toast(\"默认长按音量键可停止脚本\\n\\n\"..os.date(\"%Y年%m月%d日%H点%M分%S秒\"), device.front_orien()) sys.msleep(1000) end 注：上述代码中使用了非本章函数 device.front_orien、os.date "},"Handbook/sys/sys.alert.html":{"url":"Handbook/sys/sys.alert.html","title":"弹出系统提示 (sys.alert)","keywords":"","body":"弹出系统提示 (sys.alert) 声明 选择 = sys.alert(文字内容 [, 自动消失秒数, 标题, 按钮0标题, 按钮1标题, 按钮2标题 ]) 参数及返回值 文字内容 文本型， 代表弹出提示内容 自动消失秒数 实数型，可选参数，代表弹窗自动消失时间，单位秒，设置 0 不自动消失，默认 0 标题 文本型，可选参数，代表弹出提示的标题，默认 \"XXT\" * 1.2-1 版以上默认标题为 \"脚本提示\" 按钮0 (取消按钮) 标题 文本型， 可选参数，代表弹出提示窗的默认按钮的标题，默认为 \"好\" 按钮1标题 文本型， 可选参数，代表弹出提示窗的额外的第 1 个按钮标题，默认不显示这个按钮 按钮2标题 文本型， 可选参数，代表弹出提示窗的额外的第 2 个按钮标题，默认不显示这个按钮 选择 整数型 返回 0 代表选择了 按钮0 (取消按钮) 返回 1 代表选择了 按钮1 返回 2 代表选择了 按钮2 返回 3 代表超时自动消失 返回 71 代表春板 (SpringBoard) 挂了 说明 弹出一个系统提示对话框，最多可以有 3 个按钮，阻塞所有线程等待返回 示例 local choice = sys.alert('你现在将要干啥？', 10, '你的选择', '取消', '吃饭', '睡觉') if choice==0 then sys.alert('你选择‘取消’') elseif choice==1 then sys.alert('你选择‘吃饭’') elseif choice==2 then sys.alert('你选择‘睡觉’') elseif choice==3 then sys.alert('你没有选择，超时了') else sys.alert('春板挂了') end "},"Handbook/sys/sys.input_box.html":{"url":"Handbook/sys/sys.input_box.html","title":"弹出输入提示 (sys.input_box)","keywords":"","body":"弹出输入提示 (sys.input_box) 说明 弹出一个系统输入对话框，最多可以有 3 个按钮，2 个文本框，阻塞所有线程等待返回标题默认为 \"XXT\"* 1.2-1 版以上默认标题为 \"脚本提示\" 示例 输入的内容 = sys.input_box(\"描述内容\") -- 输入的内容 = sys.input_box(\"标题\", \"这是描述内容\") -- 输入的内容 = sys.input_box(\"标题\", \"这是描述内容\", 0) -- 输入的内容 = sys.input_box(\"标题\", \"描述内容\", \"文本框阴影提示\", 0) -- 输入的内容 = sys.input_box(\"标题\", \"描述内容\", \"文本框阴影提示\", \"文本框里面的内容\", 0) -- 输入的内容 = sys.input_box(\"标题\", \"描述内容\", \"文本框阴影提示\", \"文本框里面的内容\", \"默认按钮标题\", 0) -- 输入的内容, 做出的选择 = sys.input_box(\"标题\", \"描述内容\", \"文本框阴影提示\", \"文本框里面的内容\", \"默认按钮标题\", \"按钮1标题\", 0) -- 输入的内容, 做出的选择 = sys.input_box(\"标题\", \"描述内容\", \"文本框阴影提示\", \"文本框里面的内容\", \"默认按钮标题\", \"按钮1标题\", \"按钮2标题\", 0) -- 输入的内容1, 输入的内容2 = sys.input_box(\"标题\", \"描述内容\", {\"文本框1阴影提示\", \"文本框2阴影提示\"}, 0) -- 输入的内容1, 输入的内容2 = sys.input_box(\"标题\", \"描述内容\", {\"文本框1阴影提示\", \"文本框2阴影提示\"}, {\"文本框1里面的内容\", \"文本框2里面的内容\"}, 0) -- 输入的内容1, 输入的内容2, 做出的选择 = sys.input_box(\"标题\", \"描述内容\", {\"文本框1阴影提示\", \"文本框2阴影提示\"}, {\"文本框1里面的内容\", \"文本框2里面的内容\"}, \"默认按钮标题\", \"按钮1标题\", \"按钮2标题\", 0) "},"Handbook/sys/sys.input_text.html":{"url":"Handbook/sys/sys.input_text.html","title":"输入文字 (sys.input_text)","keywords":"","body":"输入文字 (sys.input_text) 声明 sys.input_text(文字内容 [, 输入完成按回车 ]) 参数及返回值 文字内容 文本型，需要输入的文字，不支持 \"\\b\" (退格键) 输入完成按回车 布尔型，是否在输入完毕后按下键盘上的回车键 (发送、搜索等) ，默认 false 说明 在前台程序的可以输入文本的地方输入文字该函数原理为先将文本写入剪贴板，然后调用粘贴快捷键 (command + v) 粘贴文本该函数的调用会影响公共剪贴板，请注意在调用之前备份好剪贴板中的重要数据在系统公共剪贴板损坏的情况下，该函数的文字输入会失效。也就是不能复制粘贴文字，就不能用与此函数已知的冲突插件：Background Manager如果遇到无法作用的情况可以参考 app.input_text 或许能解决 示例 sys.input_text(\"我爱你\") -- 在当前光标所在文本框输入“我爱你” -- sys.input_text(\"我爱你\", true) -- 在QQ聊天界面输入“我爱你”然后按下回车发送出去 "},"Handbook/sys/sys.msleep.html":{"url":"Handbook/sys/sys.msleep.html","title":"! 毫秒级延迟 (sys.msleep)","keywords":"","body":"! 毫秒级延迟 (sys.msleep) 声明 sys.msleep(毫秒数) 参数及返回值 毫秒数 实数型， 需要延迟等待的时间，单位毫秒 说明 让当前线程阻塞等待一定时间这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会 示例 sys.msleep(1000) -- 等待 1 秒 "},"Handbook/sys/sys.mtime.html":{"url":"Handbook/sys/sys.mtime.html","title":"获取当前毫秒级时间戳 (sys.mtime)","keywords":"","body":"获取当前毫秒级时间戳 (sys.mtime) 声明 时间戳 = sys.mtime() 参数及返回值 时间戳 整数型， 返回毫秒级 UNIX 时间戳 示例 local ms = sys.mtime() screen.keep() sys.alert('一次 screen.keep 耗时：'..sys.mtime()-ms..'毫秒') 注：上述代码中使用了非本章函数 screen.keep "},"Handbook/sys/sys.net_time.html":{"url":"Handbook/sys/sys.net_time.html","title":"! 获取网络时间 (sys.net_time)","keywords":"","body":"! 获取网络时间 (sys.net_time) 声明 秒级时间戳 = sys.net_time([ 超时时间 ]) 参数及返回值 超时时间 实数型，可选参数，用于设置获取网络时间联网的最大等待时间 (单位：秒) ，默认 2 秒级时间戳 整数型， 成功则返回当前网络时间的秒级 UNIX 时间戳，连接超时或未能成功获取网络时间返回 0 说明 这个方法可能会让出，在这个方法返回之前，其它的 线程 可能会得到运行机会 示例 local nt = sys.net_time() -- 获取网络时间，默认 2 秒超时，超时返回 0 -- local nt = sys.net_time(5) -- 获取网络时间，5 秒超时，超时返回 0 if nt==0 then sys.alert('获取网络时间失败') else sys.alert(os.date('当前网络时间\\n%Y-%m-%d %H:%M:%S', nt)) end 注：上述代码中使用了 os.date 日期格式化相关 "},"Handbook/sys/sys.rnd.html":{"url":"Handbook/sys/sys.rnd.html","title":"产生一个随机数 (sys.rnd)","keywords":"","body":"产生一个随机数 (sys.rnd) 声明 随机数字 = sys.rnd() 参数及返回值 随机数字 整数型，返回一个随机数字，范围 0~4294967295 说明 产生一个真随机数 示例 math.randomseed(sys.rnd()) -- 初始化随机因子为一个真随机数 local r = math.random(1, 100) -- 产生一个 1~100 范围的随机数 "},"Handbook/sys/sys.memory_info.html":{"url":"Handbook/sys/sys.memory_info.html","title":"获取设备当前内存状态信息 (sys.memory_info)","keywords":"","body":"获取设备当前内存状态信息 (sys.memory_info) 声明 内存状态 = sys.memory_info() 参数及返回值 内存状态 表型，返回的内存状态信息，里面的 key - value 对应自己理解吧 示例 sys.alert(table.deep_print(sys.memory_info())) 注：上述代码中使用了非本章函数 table.deep_print "},"Handbook/sys/sys.available_memory.html":{"url":"Handbook/sys/sys.available_memory.html","title":"获取设备当前可用内存值 (sys.available_memory)","keywords":"","body":"获取设备当前可用内存值 (sys.available_memory) 声明 可用内存 = sys.available_memory() 参数及返回值 可用内存 实数型，返回当前设备的空闲内存值 (单位：MB) 示例 sys.alert('当前可用内存为：'..sys.available_memory()..'MB') "},"Handbook/sys/sys.free_disk_space.html":{"url":"Handbook/sys/sys.free_disk_space.html","title":"获取设备当前未使用的存储空间值 (sys.free_disk_space)","keywords":"","body":"获取设备当前未使用的存储空间值 (sys.free_disk_space) 声明 剩余空间 = sys.free_disk_space([挂载点]) 参数及返回值 挂载点 文本型，默认有效取值范围为 \"/var\" 或是 \"/\"，分别代表用户空间和系统空间。有外部存储比如内存卡的时候可以有其它值 剩余空间 实数型，返回设备当前未使用的存储空间值 (单位：MB) 示例 sys.alert( '当前系统空间剩余\\n'..sys.free_disk_space('/')..'MB\\n\\n'.. '当前用户空间剩余\\n'..sys.free_disk_space('/var')..'MB' ) "},"Handbook/sys/sys.log.html":{"url":"Handbook/sys/sys.log.html","title":"输出标准系统日志 (sys.log)","keywords":"","body":"输出标准系统日志 (sys.log) 声明 sys.log(日志内容) 参数及返回值 日志内容 文本型，代表需要输出的日志内容 说明 输出标准系统日志日志可以使用电脑浏览器打开远程接口 http://:46952/log.html 实时查看日志会同时存储到设备上的 /var/mobile/Meida/1ferver/log/sys.log 文件中/var/mobile/Meida/1ferver/log/sys.log 记录的日志最多不会超过 4000 行，超过则删前面的 示例 sys.log(\"当然是 Hello World 啦\") "},"Handbook/sys/sys.mgcopyanswer.html":{"url":"Handbook/sys/sys.mgcopyanswer.html","title":"问系统一个问题 (sys.mgcopyanswer)","keywords":"","body":"问系统一个问题 (sys.mgcopyanswer) 声明 答案 = sys.mgcopyanswer(问题) 参数及返回值 问题 文本型，问题名字，一些 问题名字 参考 MobileGestalt.h 或 《MGCopyAnswer 字段参考》 答案 字符串型 或 表型 或 实数型 或 整数型 或 布尔型 或 nil，系统的回复，如果问题不被支持，则返回 nil 说明 这个函数在 1.1.2-1 版以上方可使用获取一些系统信息，底层使用 MGCopyAnswer 完成获取系统信息 读取系统信息 获取设备信息 读取设备信息 设备标识 获取手机号 读取手机号 示例 sys.alert(\"设备的序列号是：\"..sys.mgcopyanswer(\"SerialNumber\")) sys.alert(\"设备的 IMEI 是：\"..sys.mgcopyanswer(\"InternationalMobileEquipmentIdentity\")) sys.alert(\"设备的 MEID 是：\"..sys.mgcopyanswer(\"MobileEquipmentIdentifier\")) local infos = sys.mgcopyanswer('CarrierBundleInfoArray') if type(infos) == 'table' then local info = infos[1] if #infos > 0 and if type(info.InternationalMobileSubscriberIdentity) == 'string' andthen type(info.IntegratedCircuitCardIdentity) == 'string' then sys.alert( sys.alert(\"运营商 IMSI 是：\"..info.InternationalMobileSubscriberIdentity) else sys.alert(\"无法读取运营商 IMSI，或许你应该插入一张 SIM 卡\") end \"IMSI：\"..if type(info.InternationalMobileSubscriberIdentity..\"\\n\".. \"ICCID：\"..info.IntegratedCircuitCardIdentity ) == 'string' then sys.alert(\"运营商 IMSI 是：\"..info.InternationalMobileSubscriberIdentity) else sys.alert(\"无法读取运营商 IMSI、ICCID，或许你应该给设备插入一张正常的 SIM 卡\") end else sys.alert(\"无法读取运营商信息，或许你应该给设备插入一张正常的 SIM 卡\") end local phone_number = sys.mgcopyanswer('PhoneNumber') if sys.mgcopyanswer('SIMTrayStatus') == 'kCTSIMSupportSIMTrayInsertedWithSIM' and type(phone_number) == 'string' then sys.alert(\"手机号是：\"..phone_number) else sys.alert(\"无法读取手机号，或许你应该给设备插入一张正常的 SIM 卡\") end "},"Handbook/sys/sys.version.html":{"url":"Handbook/sys/sys.version.html","title":"获取系统版本 (sys.version)","keywords":"","body":"获取系统版本 (sys.version) 声明 系统版本 = sys.version() 参数及返回值 系统版本 文本型，返回系统版本号 说明 这个函数可以在 XUI 中使用 示例 sys.alert('当前系统版本：'..sys.version()) "},"Handbook/sys/sys.xtversion.html":{"url":"Handbook/sys/sys.xtversion.html","title":"获取 XXTouch 版本 (sys.xtversion)","keywords":"","body":"获取 XXTouch 版本 (sys.xtversion) 声明 版本号 = sys.xtversion() 参数及返回值 版本号 文本型，返回 XXTouch 版本号 说明 这个函数可以在 XUI 中使用 示例 sys.alert('当前 XXTouch 版本：'..sys.xtversion()) "},"Handbook/pasteboard/index.html":{"url":"Handbook/pasteboard/index.html","title":"剪贴板模块","keywords":"","body":"剪贴板模块 写内容进剪贴板 (pasteboard.write) 获取剪贴板中的数据 (pasteboard.read) "},"Handbook/pasteboard/pasteboard.write.html":{"url":"Handbook/pasteboard/pasteboard.write.html","title":"写内容进剪贴板 (pasteboard.write)","keywords":"","body":"写内容进剪贴板 (pasteboard.write) 声明 pasteboard.write(数据 [, 通用类型标识 ]) 参数及返回值 数据 字符串型，需要写入到剪贴板的内容 通用类型标识 文本型，可选参数，Uniform Type Identifiers，默认 \"public.utf8-plain-text\" 说明 写内容进系统剪贴板（关键字： 写入剪贴板 写入剪切板 写入粘贴板 写入黏贴板） 示例 pasteboard.write(\"演示啊\") -- 将“演示啊” (不含引号) 写入到剪贴板中 -- pasteboard.write(screen.image():png_data(), 'public.png') -- 将当前屏幕截图写入到剪贴板 注：上述代码中使用了非本章函数 screen.image "},"Handbook/pasteboard/pasteboard.read.html":{"url":"Handbook/pasteboard/pasteboard.read.html","title":"获取剪贴板中的数据 (pasteboard.read)","keywords":"","body":"获取剪贴板中的数据 (pasteboard.read) 声明 数据 = pasteboard.read([ 通用类型标识 ]) 参数及返回值 通用类型标识 文本型，可选参数，Uniform Type Identifiers，默认 自动判断格式存在 通用类型标识 参数的情况下，会强制以该 通用类型标识 格式读取剪贴板中数据，若是剪贴板中数据无法以该 通用类型标识 读取，则返回空字符串 数据 字符串型，返回剪贴板中的数据，可能是文本，也可能是二进制数据，如果不能以该方式读取，则返回 \"\" (空文本) 说明 从系统剪贴板中读取内容（关键字： 读取剪贴板 读取剪切板 获取剪切板 读取粘贴板 获取粘贴板 读取黏贴板 获取黏贴板） 示例 sys.alert(\"剪贴板中的内容：\"..pasteboard.read()) -- sys.alert(\"剪贴板中的内容：\"..pasteboard.read('public.text')) -- 富文本也强行以文本方式读取剪贴板 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/dialog/index.html":{"url":"Handbook/dialog/index.html","title":"对话框模块","keywords":"","body":"对话框模块 ! 建立一个对话框对象 (dialog) 配置对话框配置保存文件名 (:config) 配置对话框配置保存文件名 (:set_config) 配置对话框自动消失时间 (:timeout) 配置对话框自动消失时间 (:set_timeout) 配置对话框的标题 (:title) 配置对话框的标题 (:set_title) 配置对话框的尺寸 (:set_size) 配置对话框的位置及尺寸 (:set_frame) 配置对话框的圆角半径 (:set_corner_radius) 给对话框加上一个文本标签 (:add_label) 给对话框加上一个文本输入框 (:add_input) 给对话框加上一个图片 (:add_image) 给对话框加上一个开关 (:add_switch) 给对话框加上一个选择器 (:add_picker) 给对话框加上一个单选组 (:add_radio) 给对话框加上一个多选组 (:add_checkbox) 给对话框加上一个数值选择器 (:add_range) ! 将对话框弹出来并返回用户的选择 (:show) ! 在不弹出对话框的情况下获得对话框配置 (:load) "},"Handbook/dialog/dialog.html":{"url":"Handbook/dialog/dialog.html","title":"! 建立一个对话框对象 (dialog)","keywords":"","body":"! 建立一个对话框对象 (dialog) 声明 对话框对象 = dialog() 参数及返回值 对话框对象 对话框，返回一个对话框对象 说明 建立一个对话框对象注意 这个函数没有参数，请不要 给任何参数，带参数调用是弹出一个弹窗，声明如下 dialog(弹窗内容:文本型, 超时秒:实数型) 例如 dialog('Hello, XXTouch!', 10) 示例 dialog():show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_config.html":{"url":"Handbook/dialog/_config.html","title":"配置对话框配置保存文件名 (:config)","keywords":"","body":"配置对话框配置保存文件名 (:config) 声明 对话框对象 = 对话框对象:config(配置名) 参数及返回值 配置名 文本型，配置对话框对象的选项配置保存名 对话框对象 对话框，返回对话框本身 说明 对话框显示出来，并且用户按下 提交 后会保存配置选项，再次显示出来的时候默认选上保存好的配置配置将以文件形式保存在 /private/var/mobile/Media/1ferver/uicfg/.xcfg 示例 dialog():config('配置名'):show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_set_config.html":{"url":"Handbook/dialog/_set_config.html","title":"配置对话框配置保存文件名 (:set_config)","keywords":"","body":"配置对话框配置保存文件名 (:set_config) 声明 对话框对象 = 对话框对象:set_config(配置名) 参数及返回值 配置名 文本型，配置对话框对象的选项配置保存名 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用对话框显示出来，并且用户按下 提交 后会保存配置选项，再次显示出来的时候默认选上保存好的配置配置将以文件形式保存在 /private/var/mobile/Media/1ferver/uicfg/.xcfg与旧版 :config 方法等效 示例 dialog():set_config('配置名'):show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_timeout.html":{"url":"Handbook/dialog/_timeout.html","title":"配置对话框自动消失时间 (:timeout)","keywords":"","body":"配置对话框自动消失时间 (:timeout) 声明 对话框对象 = 对话框对象:timeout(超时秒[, 是否提交]) 参数及返回值 超时秒 实数型，对话框对象自动消失时间，单位秒 是否提交 * 1.2-1 新增 布尔型，可选参数，对话框自动消失是否算提交，true 为是，false 为否，默认 false 超时算不提交 对话框对象 对话框，返回对话框本身 说明 配置对话框自动消失时间 示例 dialog():timeout(3):show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_set_timeout.html":{"url":"Handbook/dialog/_set_timeout.html","title":"配置对话框自动消失时间 (:set_timeout)","keywords":"","body":"配置对话框自动消失时间 (:set_timeout) 声明 对话框对象 = 对话框对象:set_timeout(超时秒[, 是否提交]) 参数及返回值 超时秒 实数型，对话框对象自动消失时间，单位秒 是否提交 布尔型，可选参数，对话框自动消失是否算提交，true 为是，false 为否，默认 false 超时算不提交 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用配置对话框自动消失时间，与旧版 :timeout 方法等效 示例 dialog():set_timeout(3):show() -- 3 秒超时取消提交 -- dialog():set_timeout(3, true):show() -- 3 秒超时并提交 "},"Handbook/dialog/_title.html":{"url":"Handbook/dialog/_title.html","title":"配置对话框的标题 (:title)","keywords":"","body":"配置对话框的标题 (:title) 声明 对话框对象 = 对话框对象:title(标题文本) 参数及返回值 标题文本 文本型，对话框的标题 对话框对象 对话框，返回对话框本身 说明 配置对话框的标题 示例 dialog():title('标题'):show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_set_title.html":{"url":"Handbook/dialog/_set_title.html","title":"配置对话框的标题 (:set_title)","keywords":"","body":"配置对话框的标题 (:set_title) 声明 对话框对象 = 对话框对象:set_title(标题文本) 参数及返回值 标题文本 文本型，对话框的标题 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用配置对话框的标题，与旧版 :title 方法等效 示例 dialog():set_title('标题'):show() "},"Handbook/dialog/_set_size.html":{"url":"Handbook/dialog/_set_size.html","title":"配置对话框的尺寸 (:set_size)","keywords":"","body":"配置对话框的尺寸 (:set_size) 声明 对话框对象 = 对话框对象:set_size(宽度, 高度) 参数及返回值 宽度, 高度 整数型，对话框对象宽高，如果不设置默认是全屏宽高 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用设置对话框的尺寸，如果对话框不是全屏，则会居中于屏幕，并使用半径为 10 的圆角 示例 local dlg = dialog() dlg:set_size(600, 800) dlg:show() "},"Handbook/dialog/_set_frame.html":{"url":"Handbook/dialog/_set_frame.html","title":"配置对话框的位置及尺寸 (:set_frame)","keywords":"","body":"配置对话框的位置及尺寸 (:set_frame) 声明 对话框对象 = 对话框对象:set_frame(横坐标, 纵坐标, 宽度, 高度) 参数及返回值 横坐标, 纵坐标 整数型，对话框对象左上角位置的横坐标及纵坐标 宽度, 高度 整数型，对话框对象宽高，如果不设置默认是全屏宽高 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用配置对话框的位置及尺寸，使用方角 示例 local dlg = dialog() dlg:set_frame(0, 0, 600, 800) dlg:show() "},"Handbook/dialog/_set_corner_radius.html":{"url":"Handbook/dialog/_set_corner_radius.html","title":"配置对话框的圆角半径 (:set_corner_radius)","keywords":"","body":"配置对话框的圆角半径 (:set_corner_radius) 声明 对话框对象 = 对话框对象:set_corner_radius(圆角半径) 参数及返回值 圆弧半径 整数型，圆角半径，0 为方角 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.2-1 版以上方可使用配置对话框的圆角半径，需要使用圆角对话框的时候可以派上用场 示例 local dlg = dialog() dlg:set_frame(0, 0, 600, 800) dlg:set_corner_radius(50) dlg:show() "},"Handbook/dialog/_add_label.html":{"url":"Handbook/dialog/_add_label.html","title":"给对话框加上一个文本标签 (:add_label)","keywords":"","body":"给对话框加上一个文本标签 (:add_label) 声明 对话框对象 = 对话框对象:add_label(标签内容) 参数及返回值 标签内容 文本型，标签显示的文本 对话框对象 对话框，返回对话框本身 说明 给对话框加上一个文本标签 示例 dialog():add_label('一个文本标签'):show() 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_input.html":{"url":"Handbook/dialog/_add_input.html","title":"给对话框加上一个文本输入框 (:add_input)","keywords":"","body":"给对话框加上一个文本输入框 (:add_input) 声明 对话框对象 = 对话框对象:add_input(输入框标签 [, 输入框默认内容 ]) 参数及返回值 输入框标签 文本型，文本框左侧标签显示的文本 输入框默认内容 文本型 或 实数型，文本框中的默认值 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 文本型，返回输入的内容 说明 给对话框加上一个文本输入框 示例 local c, s = dialog():add_input('一个输入框', '默认内容'):show() sys.alert('输入的内容是：'..s['一个输入框']) 注：上述代码中使用了非本章函数 sys.alert 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_image.html":{"url":"Handbook/dialog/_add_image.html","title":"给对话框加上一个图片 (:add_image)","keywords":"","body":"给对话框加上一个图片 (:add_image) 声明 对话框对象 = 对话框对象:add_image(图片) 参数及返回值 图片 图片对象，需要添加到对话框的图片 对话框对象 对话框，返回对话框本身 说明 这个方法在 1.1.0-1 版以上方可使用给对话框加上一个图片 示例 dialog():add_image(screen.image()):show() -- 弹出一张屏幕截图 注：上述代码中使用了非本章函数 screen.image 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_switch.html":{"url":"Handbook/dialog/_add_switch.html","title":"给对话框加上一个开关 (:add_switch)","keywords":"","body":"给对话框加上一个开关 (:add_switch) 声明 对话框对象 = 对话框对象:add_switch(开关标签 [, 开关默认状态 ]) 参数及返回值 开关标签 文本型，开关左侧标签显示的文本 开关默认状态 布尔型，可选参数，开关的开启状态，默认 false (关) 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 布尔型，返回这个开关被开启的状态 说明 给对话框加上一个开关 示例 local c, s = dialog():add_switch('一个开关', false):show() sys.alert(s[\"一个开关\"]) 注：上述代码中使用了非本章函数 sys.alert 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_picker.html":{"url":"Handbook/dialog/_add_picker.html","title":"给对话框加上一个选择器 (:add_picker)","keywords":"","body":"给对话框加上一个选择器 (:add_picker) 声明 对话框对象 = 对话框对象:add_picker(选择器标签, 选择器的选项们 [, 默认选择 ]) 参数及返回值 选择器标签 文本型，选择器左侧标签显示的文本 选择器的选项们 表型，选择器中的顺序选项名列表，不能有一样的 默认选择 文本型，可选参数，选择器的默认选项名，默认为第一个 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 文本型，返回被选择的选项名 说明 给对话框加上一个选择器 示例 local c, s = dialog():add_picker('一个选择器', {'选择1', '选择2', '选择3'}):show() sys.alert('你的选择是：'..s['一个选择器']) 注：上述代码中使用了非本章函数 sys.alert 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_radio.html":{"url":"Handbook/dialog/_add_radio.html","title":"给对话框加上一个单选组 (:add_radio)","keywords":"","body":"给对话框加上一个单选组 (:add_radio) 声明 对话框对象 = 对话框对象:add_radio(单选组标签, 单选组选项们 [, 默认选择 ]) 参数及返回值 单选组标签 文本型，单选组标题标签显示的文本 单选组选项们 表型，单选组中的顺序选项名列表，不能有一样的 默认选择 文本型，可选参数，被选中的选项名，默认为 单选组选项们 中第一项 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 文本型，返回被选中的选项名 说明 这个方法在 1.1.1-1 版以上方可使用给对话框加上一个单选组 示例 local c, s = dialog():add_radio('一个单选组', {'单选1', '单选2', '单选3'}):show() sys.alert('你的选择是：'..s['一个单选组']) 注：上述代码中使用了非本章函数 sys.alert 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_checkbox.html":{"url":"Handbook/dialog/_add_checkbox.html","title":"给对话框加上一个多选组 (:add_checkbox)","keywords":"","body":"给对话框加上一个多选组 (:add_checkbox) 声明 对话框对象 = 对话框对象:add_checkbox(多选组标签, 多选组选项们 [, 默认选择们 ]) 参数及返回值 多选组标签 文本型，多选组标题标签显示的文本 多选组选项们 表型，多选组中的顺序选项名列表，不能有一样的 默认选择们 表型，可选参数，多选组的默认选项名列表，默认为 空表 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 表型，返回所有包含所有被选择的选项的一个顺序表 说明 给对话框加上一个多选组 示例 local c, s = dialog() :add_checkbox('一个多选组', {'选项1', '选项2', '选项3', '选项4'}, {'选项1', '选项3'}) :show() print('一共选中了 '..#(s['一个多选组'])..' 个选项') print('选中列表如下') for _, oname in ipairs(s['一个多选组']) do print(oname) end sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert、print、print.out 完整示例 本章结尾 :show() "},"Handbook/dialog/_add_range.html":{"url":"Handbook/dialog/_add_range.html","title":"给对话框加上一个数值选择器 (:add_range)","keywords":"","body":"给对话框加上一个数值选择器 (:add_range) 声明 对话框对象 = 对话框对象:add_range(范围选择器标签, 范围选择器参数 [, 默认位置 ]) 参数及返回值 范围选择器标签 文本型，数值选择器标题标签显示的文本 范围选择器参数 表型，用于描述范围以及步进的一个表，格式为 {最小值, 最大值, 步进值} 最小值 实数型，为数值选择条最左边的位置 最大值 实数型，为数值选择条最右边的位置 步进值 实数型，可选参数，为选择条拖动的最小单位，默认为 1 默认位置 实数型，可选参数，默认值，默认为最小值 对话框对象 对话框，返回对话框本身 使用 :show() 返回类型 实数型，返回所选择的数字 说明 这个方法在 1.1.1-1 版以上方可使用给对话框加上一个数值选择器 示例 local c, s = dialog():add_range('一个数值', {222, 666, 1}, 333):show() sys.alert('数值是：'..s['一个数值']) 注：上述代码中使用了非本章函数 sys.alert 完整示例 本章结尾 :show() "},"Handbook/dialog/_show.html":{"url":"Handbook/dialog/_show.html","title":"! 将对话框弹出来并返回用户的选择 (:show)","keywords":"","body":"! 将对话框弹出来并返回用户的选择 (:show) 声明 是否提交, 选项关联表 = 对话框对象:show() 参数及返回值 对话框对象 对话框，需要弹出的对话框 是否提交 布尔型，返回是否按下了提交按钮，超时或点右上角叉返回 false 选项关联表 表型，返回一个以选项标签映射的键值表 说明 这个方法在 1.1.1-1 版以上方可使用将对话框弹出来并返回用户的选择当对话框设置了配置保存 (:config(配置名)) 的情况下，按下 提交 会保存配置，按下右上的 × 或超时则不会保存 简单示例 local c, s = dialog():add_switch('一个开关', false):show() sys.alert(s[\"一个开关\"]) 注：上述代码中使用了非本章函数 sys.alert 复杂示例 local dlg = dialog() -- 创建一个 dialog 对象 -- -- 以下为此 dialog 对象配置 dlg:config('test') -- 配置保存ID dlg:timeout(30) dlg:add_label('简易的效果展示') dlg:add_range('血量', {0, 1000, 1}, 300) dlg:add_input('账号', 'ccc') dlg:add_input('密码', 'aaaa') dlg:add_picker('性别', {'男', '女', '未知'}, '男') dlg:add_switch('你是变态?', false) dlg:add_checkbox('喜欢的游戏', {'守望先锋', '魔兽世界', '炉石传说'}, {'守望先锋', '魔兽世界'}) dlg:add_radio('最喜欢的游戏', {'守望先锋', '魔兽世界', '炉石传说'}, '魔兽世界') -- local confirm, selects = dlg:show() -- 显示 dialog 对象到前台并获得其返回值 -- if (confirm) then print(\"你按下了提交\") else print(\"你没有按下提交\") end -- print(\"账号\", selects[\"账号\"]) print(\"密码\", selects[\"密码\"]) print(\"性别\", selects[\"性别\"]) print(\"血量\", selects[\"血量\"]) -- if (selects['你是变态?']) then print(\"你承认了自己是变态\") else print(\"你不承认自己是变态\") end -- print(\"你喜欢游戏列表\") for _,gamename in ipairs(selects['喜欢的游戏']) do print(gamename) end -- print(\"你最喜欢游戏:\"..selects[\"最喜欢的游戏\"]) -- sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert、print、print.out "},"Handbook/dialog/_load.html":{"url":"Handbook/dialog/_load.html","title":"! 在不弹出对话框的情况下获得对话框配置 (:load)","keywords":"","body":"! 在不弹出对话框的情况下获得对话框配置 (:load) 声明 是否提交, 选项关联表 = 对话框对象:load() 参数及返回值 对话框对象 对话框，需要获取返回值的对话框 是否提交 布尔型，返回是否按下了提交按钮，这里将会无限返回 false 选项关联表 表型，返回一个以选项标签映射的键值表 说明 这个方法在 1.1.1-1 版以上方可使用在不弹出对话框的情况下获得对话框配置，如果对话框当前没有保存配置，则加载默认值 示例 local dlg = dialog() -- dlg:config('test') -- 配置保存ID dlg:timeout(30) dlg:add_label('简易的效果展示') dlg:add_range('血量', {0, 1000, 1}, 300) dlg:add_input('账号', 'ccc') dlg:add_input('密码', 'aaaa') dlg:add_picker('性别', {'男', '女', '未知'}, '男') dlg:add_switch('你是变态?', false) dlg:add_checkbox('喜欢的游戏', {'守望先锋', '魔兽世界', '炉石传说'}, {'守望先锋', '魔兽世界'}) dlg:add_radio('最喜欢的游戏', {'守望先锋', '魔兽世界', '炉石传说'}, '魔兽世界') -- local _, selects -- if (utils.is_launch_via_app()) then -- 判断当前是否从 app 启动 _, selects = dlg:show() -- 从 app 启动的脚本则弹出配置窗 else _, selects = dlg:load() -- 音量键或其它方式启动的脚本则不再弹出 end -- print(\"账号\", selects[\"账号\"]) print(\"密码\", selects[\"密码\"]) print(\"性别\", selects[\"性别\"]) print(\"血量\", selects[\"血量\"]) -- if (selects['你是变态?']) then print(\"你承认了自己是变态\") else print(\"你不承认自己是变态\") end -- print(\"你喜欢游戏列表\") for _,gamename in ipairs(selects['喜欢的游戏']) do print(gamename) end -- print(\"你最喜欢游戏:\"..selects[\"最喜欢的游戏\"]) -- sys.alert(print.out()) 注：上述代码中使用了非本章函数 utils.is_launch_via_app、 sys.alert、print、print.out "},"Handbook/clear/index.html":{"url":"Handbook/clear/index.html","title":"清理模块","keywords":"","body":"清理模块 清理某个或某组钥匙串信息 (clear.keychain) 清理所有应用程序钥匙串信息 (clear.all_keychain) 清理剪贴板 (clear.pasteboard) 清理浏览器Cookies (clear.cookies) 清理系统缓存 (clear.caches) 清除相册中所有本地照片 (clear.all_photos) 清理某个应用的存档数据 (clear.app_data) 清理 IDFA/V (clear.idfav) "},"Handbook/clear/clear.keychain.html":{"url":"Handbook/clear/clear.keychain.html","title":"清理某个或某组钥匙串信息 (clear.keychain)","keywords":"","body":"清理某个或某组钥匙串信息 (clear.keychain) 声明 clear.keychain(信息关联名) 参数及返回值 信息关联名 文本型，一般传入公司反域名，例如 \"com.tencent\"，切不可乱传参数 说明 清理某个应用程序或分组的钥匙串信息，若不懂请直接用 clear.all_keychain警告：这个函数调用产生的效果不可逆转警告：切不可乱传参数！！！警告：该函数在给不正确的参数的情况下可能产生极其严重的后果！！！ 示例 clear.keychain(\"com.tencent\") -- 清理掉与 com.tencent 相关的 keychain 信息 "},"Handbook/clear/clear.all_keychain.html":{"url":"Handbook/clear/clear.all_keychain.html","title":"清理所有应用程序钥匙串信息 (clear.all_keychain)","keywords":"","body":"清理所有应用程序钥匙串信息 (clear.all_keychain) 声明 clear.all_keychain() 说明 清理所有应用程序钥匙串信息该函数可能在 iOS 10 及以上系统中导致重启需要重新激活的问题警告：这个函数调用产生的效果不可逆转 示例 clear.all_keychain() "},"Handbook/clear/clear.pasteboard.html":{"url":"Handbook/clear/clear.pasteboard.html","title":"清理剪贴板 (clear.pasteboard)","keywords":"","body":"清理剪贴板 (clear.pasteboard) 声明 clear.pasteboard() 说明 清理剪贴板信息，一些信息会存在剪贴板中，比如 OpenUDID该函数在 iOS 10 及以上版本的操作系统中使用会导致剪贴板服务失去连接，表现为前台程序不能使用剪贴板，需要重启前台程序方能恢复警告：这个函数调用产生的效果不可逆转 示例 clear.pasteboard() "},"Handbook/clear/clear.cookies.html":{"url":"Handbook/clear/clear.cookies.html","title":"清理浏览器Cookies (clear.cookies)","keywords":"","body":"清理浏览器Cookies (clear.cookies) 声明 clear.cookies() 说明 清理浏览器Cookies警告：这个函数调用产生的效果不可逆转警告：暂不确定是否兼容 iOS 11 示例 clear.cookies() "},"Handbook/clear/clear.caches.html":{"url":"Handbook/clear/clear.caches.html","title":"清理系统缓存 (clear.caches)","keywords":"","body":"清理系统缓存 (clear.caches) 声明 clear.caches() 说明 清理系统缓存，这个函数执行会卡顿一段时间，而且卡顿期间所有线程都阻塞该函数耗时可能会非常长，并且该函数执行的过程中使用强行停止脚本会导致停止缓慢（被强杀） 示例 clear.caches() -- clear.caches{no_uicache = true} -- 1.2-2 以上版本支持不使用 uicache 清理，uicache 耗时很长，可使用 os.execute('su mobile -c uicache') 来代替 "},"Handbook/clear/clear.all_photos.html":{"url":"Handbook/clear/clear.all_photos.html","title":"清除相册中所有本地照片 (clear.all_photos)","keywords":"","body":"清除相册中所有本地照片 (clear.all_photos) 声明 clear.all_photos() 说明 清除相册中所有本地照片，不会影响 iCloud 照片流该函数耗时可能会非常长，并且该函数执行的过程中使用强行停止脚本会导致停止缓慢（被强杀）警告：这个函数调用产生的效果不可逆转 示例 clear.all_photos() "},"Handbook/clear/clear.app_data.html":{"url":"Handbook/clear/clear.app_data.html","title":"清理某个应用的存档数据 (clear.app_data)","keywords":"","body":"清理某个应用的存档数据 (clear.app_data) 声明 是否成功 = clear.app_data(应用程序包名) 参数及返回值 应用程序包名 文本型，应用程序包名 是否成功 布尔型，清理成功返回 true；否则返回 false 说明 清理应用存档，清理期间所有线程都阻塞该函数耗时可能会非常长，并且该函数执行的过程中使用强行停止脚本会导致停止缓慢（被强杀）警告：这个函数调用产生的效果不可逆转 示例 clear.app_data(\"com.tencent.xin\") "},"Handbook/clear/clear.idfav.html":{"url":"Handbook/clear/clear.idfav.html","title":"清理 IDFA/V (clear.idfav)","keywords":"","body":"清理 IDFA/V (clear.idfav) 声明 旧IDFAV信息 = clear.idfav([ 新IDFAV信息 ]) 参数及返回值 新IDFAV信息 文本型，可选参数，表示指定使用这些信息作为设备的新的 idfav 信息，不传入参数表示清理后让系统自动生成。1.2-10 版新增可传入 \"read\" 表示不清理仅读取设备的 IDFAV 信息 旧IDFAV信息 文本型 或 nil，返回设备原来的 idfav 信息，如果操作失败，则返回 nil 说明 重置设备 IDFA 和 IDFV 等标识信息传入了不正确的 idfav 信息的情况下，会操作失败返回 nil不传入参数的情况下，会清除掉设备原来的 idfav 信息，iOS系统会在之后重新随机分配 idfav返回的 idfav 信息文本可以自行保存在文件中，等到需要恢复的时候，再当作参数传回即可 示例 -- 备份 idfav 信息 app.quit('*') -- 关闭所有应用 local old_idfavs = clear.idfav() local f = io.open(\"/var/mobile/Media/1ferver/res/old_idfavs.txt\", \"wb\") if f then f:write(old_idfavs) f:close() clear.caches() -- 清理一下系统缓存 sys.alert(\"备份成功\") else clear.idfav(old_idfavs) -- 无法备份的情况下立马恢复 clear.caches() -- 清理一下系统缓存 sys.alert(\"备份失败\") end -- -- 从文件中恢复 idfav 信息 local f = io.open(\"/var/mobile/Media/1ferver/res/old_idfavs.txt\", \"rb\") if f then local old_idfavs = f:read(\"*a\") f:close() close_all_app() -- 关闭所有应用 local current_idfavs = clear.idfav(old_idfavs) if current_idfavs then f = io.open(\"/var/mobile/Media/1ferver/res/current_idfavs.txt\", \"wb\") f:write(current_idfavs) -- 将现有的 idfav 信息保存到另一个文件 f:close() clear.caches() -- 清理一下系统缓存 sys.alert(\"恢复 idfav 信息成功\") else sys.alert(\"恢复 idfav 信息失败\") end else sys.alert(\"文件打开失败\") end 注：上述代码中使用了非本章函数 sys.alert、app.quit "},"Handbook/app/index.html":{"url":"Handbook/app/index.html","title":"应用程序模块","keywords":"","body":"应用程序模块 获取 App 的应用程序包路径 (app.bundle_path) 获取 App 的应用存档路径 (app.data_path) 获取 App 的应用分组信息 (app.group_info) 弹出一个应用通知 (app.pop_banner) 运行应用程序 (app.run) 关闭应用程序 (app.close) 模拟使用上划退出应用程序 (app.quit) 检测应用程序是否正在运行 (app.is_running) 输入文字 (app.input_text) 通过应用程序 bid 获取应用的本地化名字 (app.localized_name) 通过应用程序 bid 获取应用的图标数据 (app.png_data_for_bid) 通过应用程序 bid 获取其 pid (app.pid_for_bid) 获取应用程序当前内存消耗 (app.used_memory) 获取前台应用的 Bundle Identifier (app.front_bid) 获取前台应用的 Process Identifier (app.front_pid) 前台打开一个 URL (app.open_url) 获取设备所有的应用的 Bundle Identifier 列表 (app.bundles) 获取当前设备的进程列表 (app.all_procs) 设置前台应用程序加速齿轮 (app.set_speed_add) 安装IPA安装包 (app.install) 卸载一个应用 (app.uninstall) 备注 "},"Handbook/app/app.bundle_path.html":{"url":"Handbook/app/app.bundle_path.html","title":"获取 App 的应用程序包路径 (app.bundle_path)","keywords":"","body":"获取 App 的应用程序包路径 (app.bundle_path) 声明 包路径 = app.bundle_path(应用程序包名) 参数及返回值 应用程序包名 文本型，需要定位的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 包路径 文本型 或 nil，返回的应用程序包路径，如果应用不存在则返回 nil 说明 获取 App 的应用程序包路径 示例 path = app.bundle_path(\"com.tencent.mqq\") -- 获得 QQ 的应用包路径 "},"Handbook/app/app.data_path.html":{"url":"Handbook/app/app.data_path.html","title":"获取 App 的应用存档路径 (app.data_path)","keywords":"","body":"获取 App 的应用存档路径 (app.data_path) 声明 存档路径 = app.data_path(应用程序包名) 参数及返回值 应用程序包名 文本型，需要定位的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 存档路径 文本型 或 nil，返回应用程序的存档路径，如果应用不存在则返回 nil 说明 获取 App 的应用存档路径 示例 path = app.data_path(\"com.tencent.mqq\") -- 获得 QQ 的应用存档路径 "},"Handbook/app/app.group_info.html":{"url":"Handbook/app/app.group_info.html","title":"获取 App 的应用分组信息 (app.group_info)","keywords":"","body":"获取 App 的应用分组信息 (app.group_info) 声明 应用分组信息 = app.group_info(应用程序包名) 参数及返回值 应用程序包名 文本型，需要定位的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 应用分组信息 表型，返回应用程序的分组信息，如果不存在返回空表 说明 软件版本在 1.1.3-1 或以上方可使用注意：应用程序分组信息 是 iOS 8 开始才有的概念，iOS 7 没有这个概念 示例 local function sh_escape(path) -- XXTouch 原创函数，未经 XXTouch 许可，可以用于商业用途 path = string.gsub(path, \"([ \\\\()<>'\\\"`#&*;?~$])\", \"\\\\%1\") return path end -- local info = app.group_info(\"com.tencent.mqq\") -- 获得 QQ 的分组信息 -- -- 循环删除所有分组目录中的内容 for _,v in pairs(info) do os.execute('rm -rf '..sh_escape(v)..'/Library/*') os.execute('rm -rf '..sh_escape(v)..'/Documents/*') os.execute('rm -rf '..sh_escape(v)..'/tmp/*') os.execute('rm -rf '..sh_escape(v)..'/share/*') end "},"Handbook/app/app.pop_banner.html":{"url":"Handbook/app/app.pop_banner.html","title":"弹出一个应用通知 (app.pop_banner)","keywords":"","body":"弹出一个应用通知 (app.pop_banner) 声明 app.pop_banner(应用程序包名, 标题, 内容) 参数及返回值 应用程序包名 文本型，应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 标题 文本型，通知的标题 内容 文本型，通知的内容 说明 软件版本在 1.1.3-1 或以上方可使用 示例 app.pop_banner('com.tencent.mqq', 'QQ', '[QQ红包]您收到一个假红包') "},"Handbook/app/app.run.html":{"url":"Handbook/app/app.run.html","title":"运行应用程序 (app.run)","keywords":"","body":"运行应用程序 (app.run) 声明 状态 = app.run(应用程序包名) 参数及返回值 应用程序包名 文本型，需要定位的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 状态 整数型，返回运行状态 返回 0 表示启动成功 返回 其它值 表示启动失败 说明 如果该函数在您的脚本中表现不佳，可尝试使用 runApp 函数替代它 示例 -- 打开内置天气应用，然后退出 local r = app.run(\"com.apple.weather\") -- 启动应用 包名可在 XXT 应用程序--更多--应用列表 中查看 sys.msleep(10 * 1000) -- 等 10 秒 if r == 0 then app.close(\"com.apple.weather\") -- 退出应用 else sys.alert(\"启动失败\", 3) end 注：上述代码中使用了非本章函数 sys.msleep、sys.alert "},"Handbook/app/app.close.html":{"url":"Handbook/app/app.close.html","title":"关闭应用程序 (app.close)","keywords":"","body":"关闭应用程序 (app.close) 声明 app.close(应用程序包名 或 进程号) 参数及返回值 应用程序包名 文本型，需要关闭的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 进程号 整数型，需要关闭的应用的 process identifier (进程标识符) 说明 关闭应用程序，参数可以是 应用程序包名 也可以是 进程号，如果应用不在运行则什么都不发生，该操作不会失败这个关闭应用是不可拒绝的强杀，目标应用在被关闭的时候不会收到任何通知iOS 8 及以上系统版本推荐使用 app.quit 来代替本函数 示例 参考 app.run 示例参考 app.bundles 示例 "},"Handbook/app/app.quit.html":{"url":"Handbook/app/app.quit.html","title":"模拟使用上划退出应用程序 (app.quit)","keywords":"","body":"模拟使用上划退出应用程序 (app.quit) 声明 app.quit(应用程序包名) 参数及返回值 应用程序包名 文本型，需要退出的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看传入 \"*\" 表示退出所有 说明 这个当然也是强杀，但是与 app.close 不同的是，应用在退出前会收到通知，应用在完全关闭之前有至多 10 秒时间保存存档，并且它会清除掉多任务切换界面的标签请不要在锁屏状态使用，该函数可能不能良好退出 root 权限的 App，使用该函数退出 root 权限程序可能会导致屏幕卡住点图标无响应等现象，root 权限的 App 推荐使用 app.close 强杀 示例 -- 退出所有的 App app.quit(\"*\") -- -- 退出QQ，如果QQ正在运行的话 app.quit(\"com.tencent.mqq\") "},"Handbook/app/app.is_running.html":{"url":"Handbook/app/app.is_running.html","title":"检测应用程序是否正在运行 (app.is_running)","keywords":"","body":"检测应用程序是否正在运行 (app.is_running) 声明 状态 = app.is_running(应用程序包名) 参数及返回值 应用程序包名 文本型，需要定位的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 状态 布尔型，是否正在运行 说明 本函数用于检查一个应用程序是否正在运行，它不区分前后台如果要判断一个应用是否在前台运行，可以使用 app.front_bid 获取前台应用 bid 进行对比，如下 if \"com.tencent.mqq\" == app.front_bid() then sys.alert('QQ 正在前台运行') end 注：上述代码中使用了非本章函数 sys.alert 示例 if app.is_running(\"com.tencent.mqq\") then sys.alert('QQ 正在运行') end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.input_text.html":{"url":"Handbook/app/app.input_text.html","title":"输入文字 (app.input_text)","keywords":"","body":"输入文字 (app.input_text) 声明 app.input_text(文本内容) 参数及返回值 文本内容 文本型，需要输入的文字，支持 \"\\b\"（退格键） 说明 在 App 中弹出键盘的情况下输入文字已知的无法输入的位置有 AppStore 的评论如果遇到无法作用的情况可以参考 sys.input_text 或许能解决 示例 -- 示例 1： app.input_text(\"嘿嘿嘿\") -- 弹出键盘后可以输入文字 -- -- 示例 2： app.input_text(\"\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\") -- 删除文本框原来的内容 "},"Handbook/app/app.localized_name.html":{"url":"Handbook/app/app.localized_name.html","title":"通过应用程序 bid 获取应用的本地化名字 (app.localized_name)","keywords":"","body":"通过应用程序 bid 获取应用的本地化名字 (app.localized_name) 声明 本地化名字 = app.localized_name(应用程序包名) 参数及返回值 应用程序包名 文本型，应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 本地化名字 文本型 或 nil，返回应用的本地化名字，如果应用不存在则返回 nil 示例 local name = app.localized_name(\"com.tencent.xin\") sys.alert(name) -- 弹出显示 “微信” 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.png_data_for_bid.html":{"url":"Handbook/app/app.png_data_for_bid.html","title":"通过应用程序 bid 获取应用的图标数据 (app.png_data_for_bid)","keywords":"","body":"通过应用程序 bid 获取应用的图标数据 (app.png_data_for_bid) 声明 PNG图片数据 = app.png_data_for_bid(应用程序包名) 参数及返回值 应用程序包名 文本型，应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 PNG图片数据 字符串型 或 nil，应用的图标的 png 数据 (二进制数据) ，如果应用不存在则返回 nil 示例 -- 将微信的图标保存到相册 image.load_data(app.png_data_for_bid(\"com.tencent.xin\")):save_to_album() 注：上述代码中使用了非本章函数 image.load_data、:save_to_album "},"Handbook/app/app.pid_for_bid.html":{"url":"Handbook/app/app.pid_for_bid.html","title":"通过应用程序 bid 获取其 pid (app.pid_for_bid)","keywords":"","body":"通过应用程序 bid 获取其 pid (app.pid_for_bid) 声明 进程号 = app.pid_for_bid(应用程序包名) 参数及返回值 应用程序包名 文本型，需要检测的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 进程号 整数型，如果应用程序正在运行，则返回其 pid，否则返回 0 示例 local qqpid = app.pid_for_bid(\"com.tencent.mqq\") if qqpid~=0 then sys.alert(\"当前QQ正在运行，进程号是：\"..qqpid) else sys.alert(\"当前QQ没有在运行\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.used_memory.html":{"url":"Handbook/app/app.used_memory.html","title":"获取应用程序当前内存消耗 (app.used_memory)","keywords":"","body":"获取应用程序当前内存消耗 (app.used_memory) 声明 内存占用 = app.used_memory(应用程序包名 或 进程号) 参数及返回值 应用程序包名 文本型，需要检测的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 进程号 整数型，需要检测的应用的 process identifier (进程标识符) 内存占用 实数型 或 nil，如果应用正在运行则返回其所占用的内存 (单位 MB) ，否则返回 nil 示例 local qqmem = app.used_memory(\"com.tencent.mqq\") sys.alert(\"当前QQ进程所占用的内存是：\"..qqmem..\"MB\") 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.front_bid.html":{"url":"Handbook/app/app.front_bid.html","title":"获取前台应用的 Bundle Identifier (app.front_bid)","keywords":"","body":"获取前台应用的 Bundle Identifier (app.front_bid) 声明 应用程序包名 = app.front_bid() 参数及返回值 应用程序包名 文本型，返回前台应用的 bundle identifier 没有应用处于前台但桌面服务已加载返回 \"com.apple.springboard\" 没有应用处于前台且桌面服务尚未启动返回 \"com.apple.backboardd\" 说明 获取前台应用的 bundle identifier (应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看) 示例 local bid = app.front_bid() sys.alert(\"前台应用的应用包名是：\"..bid) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.front_pid.html":{"url":"Handbook/app/app.front_pid.html","title":"获取前台应用的 Process Identifier (app.front_pid)","keywords":"","body":"获取前台应用的 Process Identifier (app.front_pid) 声明 进程号 = app.front_pid() 参数及返回值 进程号 整数型，返回前台应用的 process identifier (进程标识符) ，前台没有应用返回 0 说明 获取前台应用的 process identifier (进程标识符)前台没有应用返回 0 而不是桌面服务的进程号要获取桌面进程 pid 请用 local desktop_pid = app.pid_for_bid('com.apple.springboard') sys.alert(\"桌面服务的进程号是：\"..desktop_pid) 示例 local pid = app.front_pid() sys.alert(\"前台应用的进程号是：\"..pid) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/app/app.open_url.html":{"url":"Handbook/app/app.open_url.html","title":"前台打开一个 URL (app.open_url)","keywords":"","body":"前台打开一个 URL (app.open_url) 声明 app.open_url(URL) 参数及返回值 URL 文本型，需要打开的 URL ，可以打开 URL Scheme (“URL Scheme” 的相关应用) 说明 前台打开一个 URL，可以打开 URL Scheme (“URL Scheme” 的相关应用)部分 URL 用该 API 跳转可能不是想要的效果，可试试 local function sh_escape(path) -- XXTouch 原创函数，未经 XXTouch 许可，可以用于商业用途 path = string.gsub(path, \"([ \\\\()<>'\\\"`#&*;?~$])\", \"\\\\%1\") return path end os.execute('uiopen '..sh_escape('http://www.google.com')) os.execute('uiopen '..sh_escape('prefs:root=General&path=ACCESSIBILITY')) 示例 app.open_url(\"http://www.google.com\") -- 用 Safari 打开 Google 的主页，当然，不一定打得开 -- app.open_url(\"prefs:root=General&path=ACCESSIBILITY\") -- 跳转到 设置--通用--辅助功能 "},"Handbook/app/app.bundles.html":{"url":"Handbook/app/app.bundles.html","title":"获取设备所有的应用的 Bundle Identifier 列表 (app.bundles)","keywords":"","body":"获取设备所有的应用的 Bundle Identifier 列表 (app.bundles) 声明 应用程序包名数组 = app.bundles() 参数及返回值 应用程序包名数组 顺序表型，返回很多应用包标识符的一个表，也包括系统自带的 说明 获取设备所有的应用的 bundle identifier (应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看) 列表 示例 -- 遍历关闭所有的 app for _,bid in ipairs(app.bundles()) do app.close(bid) end "},"Handbook/app/app.all_procs.html":{"url":"Handbook/app/app.all_procs.html","title":"获取当前设备的进程列表 (app.all_procs)","keywords":"","body":"获取当前设备的进程列表 (app.all_procs) 声明 进程信息数组 = app.all_procs() 参数及返回值 进程信息数组 顺序表型，返回进程列表，结构是这样{ {pid = 进程号1, name = 进程名1 }, {pid = 进程号2, name = 进程名2 }, ... } 说明 该函数不保证能获取到进程名全名 示例 proc_list = app.all_procs() "},"Handbook/app/app.set_speed_add.html":{"url":"Handbook/app/app.set_speed_add.html","title":"设置前台应用程序加速齿轮 (app.set_speed_add)","keywords":"","body":"设置前台应用程序加速齿轮 (app.set_speed_add) 声明 app.set_speed_add(需要加的速度 [, 强力模式 ]) 参数及返回值 需要加的速度 实数型，代表加速齿轮倍数，负数为减速，正数为加速，0为不加速也不减速。前台应用重新开启后，加速效果消失 强力模式 布尔型，可选参数，是否需要支持 unity 引擎加速，默认 false 说明 强力模式 参数需要软件版本在 1.1.2-2 或以上方可使用设置前台应用程序加速齿轮加速并不是对所有的应用都有效果，确切的说，只对小部分游戏有效使用该函数可能导致严重后果 (包括但不限于应用卡死崩溃、系统崩溃、脚本停止、账号被封、被请喝茶) 不得将此函数用于非法用途，使用则代表同意 示例 app.set_speed_add(3) -- 给前台 cocos2d 的游戏加速 3 倍 -- app.set_speed_add(3, true) -- 给前台 unity3d 的游戏加速 3 倍 "},"Handbook/app/app.install.html":{"url":"Handbook/app/app.install.html","title":"安装IPA安装包 (app.install)","keywords":"","body":"安装IPA安装包 (app.install) 声明 安装成败 = app.install(文件路径 [, 强行安装 ]) 参数及返回值 文件路径 文本型，需要安装的 App 安装包 (ipa 格式) 绝对路径 强行安装 *1.1.3-1 新增 布尔型，可选参数，是否强行安装，true 为强行安装，false 为大于当前 ipa 版本不覆盖安装，默认为 false 安装成败 布尔型，安装成功返回 true，安装失败返回 false 说明 后台安装一个 ipa 格式的安装包安装的完成之前脚本不能被自然终止并会一直阻塞调用此函数前需确保在目标设备中已安装过 AppSync 插件 兼容 iOS 7~11 的 IPA 补丁.deb可用最新版 X.X.T. 扫描下面二维码下载并安装 AppSync 插件 示例 app.install(\"/var/mobile/1.ipa\", true) -- 强行覆盖安装，用于降级安装 App -- if app.install(\"/var/mobile/1.ipa\") then -- 安装成功 else -- 安装失败 end "},"Handbook/app/app.uninstall.html":{"url":"Handbook/app/app.uninstall.html","title":"卸载一个应用 (app.uninstall)","keywords":"","body":"卸载一个应用 (app.uninstall) 声明 卸载成败 = app.uninstall(应用程序包名) 参数及返回值 应用程序包名 文本型，需要卸载的应用的 bundle identifier应用包标识符，可在 XXT 应用程序--更多--应用列表 中查看 卸载成败 布尔型，卸载成功返回 true，卸载失败返回 false 说明 后台卸载一个应用程序卸载的过程脚本不能被自然终止并会一直阻塞 示例 if app.uninstall(\"com.tencent.mqq\") then -- 卸载成功 else -- 卸载失败 end "},"Handbook/app/tips.html":{"url":"Handbook/app/tips.html","title":"备注","keywords":"","body":"备注 process identifier (进程标识符) 为应用运行期的进程号，是个整数，每次运行都不一样 "},"Handbook/device/index.html":{"url":"Handbook/device/index.html","title":"设备相关模块","keywords":"","body":"设备相关模块 重置自动锁屏倒计时 (device.reset_idle) 锁定屏幕 (device.lock_screen) 解锁屏幕 (device.unlock_screen) 获取屏幕锁定状态 (device.is_screen_locked) 获取前台应用的画面方向 (device.front_orien) 锁定设备屏幕旋转 (device.lock_orien) 解锁设备屏幕旋转锁 (device.unlock_orien) 获取屏幕旋转锁锁定状态 (device.is_orien_locked) 振动设备 (device.vibrator) 后台播放声音 (device.play_sound) 获取设备类型 (device.type) 获取设备名 (device.name) 设置设备名 (device.set_name) 获取设备UDID (device.udid) 获取设备的序列号 (device.serial_number) 获取设备的 WiFi MAC 地址 (device.wifi_mac) 获取设备所有的接口 IP (device.ifaddrs) 获取当前设备电池剩余电量 (device.battery_level) 获取当前设备充电状态 (device.battery_state) 打开设备 WiFi (device.turn_on_wifi) 关闭设备 WiFi (device.turn_off_wifi) 打开设备蜂窝数据 (device.turn_on_data) 关闭设备蜂窝数据 (device.turn_off_data) 打开设备蓝牙 (device.turn_on_bluetooth) 关闭设备蓝牙 (device.turn_off_bluetooth) 打开设备飞行模式 (device.turn_on_airplane) 关闭设备飞行模式 (device.turn_off_airplane) 连接到当前设置所选 VPN (device.turn_on_vpn) 断开已有的 VPN 连接 (device.turn_off_vpn) 判断当前是否打开了 VPN 开关 (device.is_vpn_on) 打开设备闪光灯 (device.flash_on) 关闭设备闪光灯 (device.flash_off) 打开“减少动态效果”开关 (device.reduce_motion_on) 关闭“减少动态效果”开关 (device.reduce_motion_off) 打开 AssistiveTouch (device.assistive_touch_on) 关闭 AssistiveTouch (device.assistive_touch_off) 获取背光亮度值 (device.brightness) 设置背光亮度 (device.set_brightness) 设置自动锁屏分钟数 (device.set_autolock_time) 设置设备音量 (device.set_volume) 加入到一个无线局域网 (device.join_wifi) "},"Handbook/device/device.reset_idle.html":{"url":"Handbook/device/device.reset_idle.html","title":"重置自动锁屏倒计时 (device.reset_idle)","keywords":"","body":"重置自动锁屏倒计时 (device.reset_idle) 声明 device.reset_idle() 说明 重置自动锁屏倒计时 (使屏幕常亮)不推荐太高频率使用该函数，太高频率（每秒超过 10 次）使用该函数可能导致服务崩溃或系统崩溃 示例 -- 派发一个每 29 秒重置 IDLE 倒计时的任务 thread.dispatch(function() while 1 do device.reset_idle() sys.msleep(29 * 1000) end end) 注：上述代码中使用了非本章函数及方法 thread.dispatch、sys.msleep "},"Handbook/device/device.lock_screen.html":{"url":"Handbook/device/device.lock_screen.html","title":"锁定屏幕 (device.lock_screen)","keywords":"","body":"锁定屏幕 (device.lock_screen) 声明 device.lock_screen() 示例 device.lock_screen() "},"Handbook/device/device.unlock_screen.html":{"url":"Handbook/device/device.unlock_screen.html","title":"解锁屏幕 (device.unlock_screen)","keywords":"","body":"解锁屏幕 (device.unlock_screen) 声明 device.unlock_screen([ 锁屏密码 ]) 参数及返回值 锁屏密码 文本型，可选参数，锁屏密码，如果有锁屏密码也可以使用这个参数，如果没有则不填即可，不推荐使用 示例 device.unlock_screen() "},"Handbook/device/device.is_screen_locked.html":{"url":"Handbook/device/device.is_screen_locked.html","title":"获取屏幕锁定状态 (device.is_screen_locked)","keywords":"","body":"获取屏幕锁定状态 (device.is_screen_locked) 声明 是否锁屏 = device.is_screen_locked() 参数及返回值 是否锁屏 布尔型，返回是否已经锁定屏幕 说明 判断是否已经锁定屏幕 示例 if device.is_screen_locked() then -- 屏幕已锁定 else -- 屏幕是解锁状态 end "},"Handbook/device/device.front_orien.html":{"url":"Handbook/device/device.front_orien.html","title":"获取前台应用的画面方向 (device.front_orien)","keywords":"","body":"获取前台应用的画面方向 (device.front_orien) 声明 旋转状态 = device.front_orien() 参数及返回值 旋转状态 整数型，相对于画面 返回 0 表示 home 在下 返回 1 表示 home 在右 返回 2 表示 home 在左 返回 3 表示 home 在上 返回 4 表示 出错了 示例 sys.toast('这个提示会以前台应用的旋转方向显示', device.front_orien()) 注：上述代码中使用了非本章函数 sys.toast "},"Handbook/device/device.lock_orien.html":{"url":"Handbook/device/device.lock_orien.html","title":"锁定设备屏幕旋转 (device.lock_orien)","keywords":"","body":"锁定设备屏幕旋转 (device.lock_orien) 声明 device.lock_orien() 示例 device.lock_orien() "},"Handbook/device/device.unlock_orien.html":{"url":"Handbook/device/device.unlock_orien.html","title":"解锁设备屏幕旋转锁 (device.unlock_orien)","keywords":"","body":"解锁设备屏幕旋转锁 (device.unlock_orien) 声明 device.unlock_orien() 示例 device.unlock_orien() "},"Handbook/device/device.is_orien_locked.html":{"url":"Handbook/device/device.is_orien_locked.html","title":"获取屏幕旋转锁锁定状态 (device.is_orien_locked)","keywords":"","body":"获取屏幕旋转锁锁定状态 (device.is_orien_locked) 声明 是否锁定 = device.is_orien_locked() 参数及返回值 是否锁定 布尔型，返回是否已经锁定屏幕旋转锁 示例 if device.is_orien_locked() then -- 屏幕旋转已锁定 else -- 屏幕旋转没锁定 end "},"Handbook/device/device.vibrator.html":{"url":"Handbook/device/device.vibrator.html","title":"振动设备 (device.vibrator)","keywords":"","body":"振动设备 (device.vibrator) 声明 device.vibrator() 说明 振我一下 (没有振动马达的设备不能振) 示例 device.vibrator() "},"Handbook/device/device.play_sound.html":{"url":"Handbook/device/device.play_sound.html","title":"后台播放声音 (device.play_sound)","keywords":"","body":"后台播放声音 (device.play_sound) 声明 device.play_sound(声音文件路径) 参数及返回值 声音文件路径 文本型，声音文件的绝对路径，支持 mp3、wav、aac 音频格式 说明 后台播放一段声音该函数不会影响脚本运行，且播放的声音会在脚本停止的时候停止，如果脚本需要播放完整声音，请做好延迟退出 示例 device.play_sound(\"/var/mobile/十年.mp3\") sys.msleep(205 * 1000) -- 等待 205 秒 (3分25秒) 注：上述代码中使用了非本章函数 sys.msleep "},"Handbook/device/device.type.html":{"url":"Handbook/device/device.type.html","title":"获取设备类型 (device.type)","keywords":"","body":"获取设备类型 (device.type) 声明 设备类型 = device.type() 参数及返回值 设备类型 文本型，返回设备类型，大约是 \"iPhone3,1\" 这种形式的字符串 说明 获取设备类型这个函数可以在 XUI 中使用 示例 if device.type() == \"iPhone3,1\" then -- 是 iPhone 4 end "},"Handbook/device/device.name.html":{"url":"Handbook/device/device.name.html","title":"获取设备名 (device.name)","keywords":"","body":"获取设备名 (device.name) 声明 设备名 = device.name() 参数及返回值 设备名 文本型，返回用户给设备取的名字 说明 这个函数可以在 XUI 中使用 示例 sys.alert(\"设备的名字是：\"..device.name()) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.set_name.html":{"url":"Handbook/device/device.set_name.html","title":"设置设备名 (device.set_name)","keywords":"","body":"设置设备名 (device.set_name) 声明 device.set_name(名字) 参数及返回值 名字 文本型，需要设置的设备名字 说明 注意：设置设备名可能会在不同版本的系统上有不同程度的延迟生效现象也就是说，调用 device.set_name 后立刻使用 device.name 获取到的并不是设置的那个名字这种情况下，请自行根据不同操作系统版本延迟判断 示例 device.set_name(\"iPhavonz\") "},"Handbook/device/device.udid.html":{"url":"Handbook/device/device.udid.html","title":"获取设备UDID (device.udid)","keywords":"","body":"获取设备UDID (device.udid) 声明 udid = device.udid() 参数及返回值 udid 文本型，返回设备的 UDID 说明 UDID 参考资料：https://www.theiphonewiki.com/wiki/UDID 示例 sys.alert(\"设备的 UDID 是：\"..device.udid()) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.serial_number.html":{"url":"Handbook/device/device.serial_number.html","title":"获取设备的序列号 (device.serial_number)","keywords":"","body":"获取设备的序列号 (device.serial_number) 声明 序列号 = device.serial_number() 参数及返回值 序列号 文本型，返回设备的序列号 示例 sys.alert(\"设备的序列号是：\"..device.serial_number()) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.wifi_mac.html":{"url":"Handbook/device/device.wifi_mac.html","title":"获取设备的 WiFi MAC 地址 (device.wifi_mac)","keywords":"","body":"获取设备的 WiFi MAC 地址 (device.wifi_mac) 声明 歪坏麦克 = device.wifi_mac() 参数及返回值 歪坏麦克 文本型，返回设备的 WiFi MAC 地址 示例 sys.alert(\"设备的 WiFi MAC 地址是：\"..device.wifi_mac()) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.ifaddrs.html":{"url":"Handbook/device/device.ifaddrs.html","title":"获取设备所有的接口 IP (device.ifaddrs)","keywords":"","body":"获取设备所有的接口 IP (device.ifaddrs) 声明 接口信息数组 = device.ifaddrs() 参数及返回值 接口信息数组 表型，返回设备的所有接口的信息结构如下 { {\"接口名1\", \"IP1\"}, {\"接口名2\", \"IP2\"}, ... } 说明 获取设备所有的接口 IP 示例 -- 获取设备的 WiFi IP local ip = \"没开 WiFi\" for i,v in ipairs(device.ifaddrs()) do if (v[1]==\"en0\") then ip = v[2] end end sys.alert(ip) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.battery_level.html":{"url":"Handbook/device/device.battery_level.html","title":"获取当前设备电池剩余电量 (device.battery_level)","keywords":"","body":"获取当前设备电池剩余电量 (device.battery_level) 声明 电量 = device.battery_level() 参数及返回值 电量 实数型，当前设备电池剩余电量，范围 0.0~1.0 示例 sys.alert(\"当前设备电池剩余电量：\"..(device.battery_level() * 100)..\"%\") 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.battery_state.html":{"url":"Handbook/device/device.battery_state.html","title":"获取当前设备充电状态 (device.battery_state)","keywords":"","body":"获取当前设备充电状态 (device.battery_state) 声明 充电状态 = device.battery_state() 参数及返回值 充电状态 文本型，充电状态，有这么几种状态 返回 \"Full\" 表示连接了电源并已经充满 返回 \"Charging\" 表示连接了电源并正在充电中 返回 \"Unplugged\" 表示没有接电源 返回 \"Unknown\" 表示未知状态 示例 状态表 = { Full = \"连接并已充满\", Charging = \"连接并在充电\", Unplugged = \"没插电源\", Unknown = \"未知状态\", } -- sys.alert(\"当前设备电池充电状态：\"..状态表[device.battery_state()]) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/device/device.turn_on_wifi.html":{"url":"Handbook/device/device.turn_on_wifi.html","title":"打开设备 WiFi (device.turn_on_wifi)","keywords":"","body":"打开设备 WiFi (device.turn_on_wifi) 声明 device.turn_on_wifi() 示例 device.turn_on_wifi() "},"Handbook/device/device.turn_off_wifi.html":{"url":"Handbook/device/device.turn_off_wifi.html","title":"关闭设备 WiFi (device.turn_off_wifi)","keywords":"","body":"关闭设备 WiFi (device.turn_off_wifi) 声明 device.turn_off_wifi() 示例 device.turn_off_wifi() "},"Handbook/device/device.turn_on_data.html":{"url":"Handbook/device/device.turn_on_data.html","title":"打开设备蜂窝数据 (device.turn_on_data)","keywords":"","body":"打开设备蜂窝数据 (device.turn_on_data) 声明 device.turn_on_data() 示例 device.turn_on_data() "},"Handbook/device/device.turn_off_data.html":{"url":"Handbook/device/device.turn_off_data.html","title":"关闭设备蜂窝数据 (device.turn_off_data)","keywords":"","body":"关闭设备蜂窝数据 (device.turn_off_data) 声明 device.turn_off_data() 示例 device.turn_off_data() "},"Handbook/device/device.turn_on_bluetooth.html":{"url":"Handbook/device/device.turn_on_bluetooth.html","title":"打开设备蓝牙 (device.turn_on_bluetooth)","keywords":"","body":"打开设备蓝牙 (device.turn_on_bluetooth) 声明 device.turn_on_bluetooth() 示例 device.turn_on_bluetooth() "},"Handbook/device/device.turn_off_bluetooth.html":{"url":"Handbook/device/device.turn_off_bluetooth.html","title":"关闭设备蓝牙 (device.turn_off_bluetooth)","keywords":"","body":"关闭设备蓝牙 (device.turn_off_bluetooth) 声明 device.turn_off_bluetooth() 示例 device.turn_off_bluetooth() "},"Handbook/device/device.turn_on_airplane.html":{"url":"Handbook/device/device.turn_on_airplane.html","title":"打开设备飞行模式 (device.turn_on_airplane)","keywords":"","body":"打开设备飞行模式 (device.turn_on_airplane) 声明 device.turn_on_airplane() 说明 打开设备飞行模式 (断网哦) 示例 device.turn_on_airplane() "},"Handbook/device/device.turn_off_airplane.html":{"url":"Handbook/device/device.turn_off_airplane.html","title":"关闭设备飞行模式 (device.turn_off_airplane)","keywords":"","body":"关闭设备飞行模式 (device.turn_off_airplane) 声明 device.turn_off_airplane() 说明 关闭设备飞行模式 (不是关网，是开网) 示例 device.turn_off_airplane() "},"Handbook/device/device.turn_on_vpn.html":{"url":"Handbook/device/device.turn_on_vpn.html","title":"连接到当前设置所选 VPN (device.turn_on_vpn)","keywords":"","body":"连接到当前设置所选 VPN (device.turn_on_vpn) 声明 device.turn_on_vpn() 说明 尝试连接到所选 VPN，如果没选，则什么也不发生注：该函数稳定性有限，在 iOS7 上碰到 VPN 没有设置密码的情况下调用会导致进入安全模式，推荐使用更加稳定的解决方案 VPN 配置模块 (vpnconf) 示例 device.turn_on_vpn() "},"Handbook/device/device.turn_off_vpn.html":{"url":"Handbook/device/device.turn_off_vpn.html","title":"断开已有的 VPN 连接 (device.turn_off_vpn)","keywords":"","body":"断开已有的 VPN 连接 (device.turn_off_vpn) 声明 device.turn_off_vpn() 说明 断开已经连上的 VPN 连接，如果当前没有尝试连接或已经连接的 VPN 则什么也不发生注：该函数稳定性有限，有可能调用无效，推荐使用更加稳定的解决方案 VPN 配置模块 (vpnconf) 示例 device.turn_off_vpn() "},"Handbook/device/device.is_vpn_on.html":{"url":"Handbook/device/device.is_vpn_on.html","title":"判断当前是否打开了 VPN 开关 (device.is_vpn_on)","keywords":"","body":"判断当前是否打开了 VPN 开关 (device.is_vpn_on) 声明 开关状态, 状态描述 = device.is_vpn_on() 参数及返回值 开关状态 布尔型，VPN 开关为打开 (正在连接或已经连接成功) 状态则返回 true，否则返回 false 状态描述 文本型 或 nil，当第一个返回值为 true 的时候，这个返回值返回一个用于描述 VPN 连接状态的字符串 说明 注意：当 VPN 正在连接 (还没有连接成功) 的时候，开关状态 会返回 true。状态描述 在不同的语言环境或系统版本中返回的同一状态描述不保证相同。 更多 VPN 相关功能尽在 VPN 配置模块 (vpnconf) 示例 while (true) do local is_on, stat = device.is_vpn_on() if (is_on) then sys.toast(stat) else device.turn_on_vpn() end end 注：上述代码中使用了非本章函数 sys.toast "},"Handbook/device/device.flash_on.html":{"url":"Handbook/device/device.flash_on.html","title":"打开设备闪光灯 (device.flash_on)","keywords":"","body":"打开设备闪光灯 (device.flash_on) 声明 是否成功 = device.flash_on() 参数及返回值 是否成功 布尔型，设备可以打开相机并且有闪光灯硬件返回 true，否则返回 false 说明 iPad Pro 的闪光灯无法开启打开设备闪光灯，脚本终止的时候，由脚本启动的闪光灯会自动关闭 示例 device.flash_on() "},"Handbook/device/device.flash_off.html":{"url":"Handbook/device/device.flash_off.html","title":"关闭设备闪光灯 (device.flash_off)","keywords":"","body":"关闭设备闪光灯 (device.flash_off) 声明 是否成功 = device.flash_off() 参数及返回值 是否成功 布尔型，设备可以打开相机并且有闪光灯硬件返回 true，否则返回 false 说明 iPad Pro 的闪光灯无法开启如果闪光灯是开启状态，那么该函数会关闭闪光灯，否则什么都不发生 示例 if device.flash_off() then -- 设备有闪光灯 else -- 设备没闪光灯 end "},"Handbook/device/device.reduce_motion_on.html":{"url":"Handbook/device/device.reduce_motion_on.html","title":"打开“减少动态效果”开关 (device.reduce_motion_on)","keywords":"","body":"打开“减少动态效果”开关 (device.reduce_motion_on) 声明 device.reduce_motion_on() 说明 减少动态效果的开关在设备上的 设置--通用--辅助功能--减少动态效果 示例 device.reduce_motion_on() "},"Handbook/device/device.reduce_motion_off.html":{"url":"Handbook/device/device.reduce_motion_off.html","title":"关闭“减少动态效果”开关 (device.reduce_motion_off)","keywords":"","body":"关闭“减少动态效果”开关 (device.reduce_motion_off) 声明 device.reduce_motion_off() 说明 减少动态效果的开关在设备上的 设置--通用--辅助功能--减少动态效果 示例 device.reduce_motion_off() "},"Handbook/device/device.assistive_touch_on.html":{"url":"Handbook/device/device.assistive_touch_on.html","title":"打开 AssistiveTouch (device.assistive_touch_on)","keywords":"","body":"打开 AssistiveTouch (device.assistive_touch_on) 声明 device.assistive_touch_on() 说明 这个函数在 1.1.1-1 版以上方可使用AssistiveTouch 开关在设备上的 设置--通用--辅助功能--AssistiveTouch 示例 device.assistive_touch_on() "},"Handbook/device/device.assistive_touch_off.html":{"url":"Handbook/device/device.assistive_touch_off.html","title":"关闭 AssistiveTouch (device.assistive_touch_off)","keywords":"","body":"关闭 AssistiveTouch (device.assistive_touch_off) 声明 device.assistive_touch_off() 说明 这个函数在 1.1.1-1 版以上方可使用AssistiveTouch 的开关在设备上的 设置--通用--辅助功能--AssistiveTouch 示例 device.assistive_touch_off() "},"Handbook/device/device.brightness.html":{"url":"Handbook/device/device.brightness.html","title":"获取背光亮度值 (device.brightness)","keywords":"","body":"获取背光亮度值 (device.brightness) 声明 亮度 = device.brightness() 参数及返回值 亮度 实数型，返回当前设备的背光亮度，范围 0.0~1.0 示例 device.set_brightness 示例 "},"Handbook/device/device.set_brightness.html":{"url":"Handbook/device/device.set_brightness.html","title":"设置背光亮度 (device.set_brightness)","keywords":"","body":"设置背光亮度 (device.set_brightness) 声明 device.set_brightness(亮度) 参数及返回值 亮度 实数型，用于设置设备的背光亮度，范围 0.0~1.0 说明 该函数调用会关闭设备的自动调整背光功能 示例 sys.toast(device.brightness()) for i = 1, 10 do device.set_brightness(i/10) sys.msleep(200) end for i = 10, 5, -1 do device.set_brightness(i/10) sys.msleep(200) end 注：上述代码中使用了非本章函数 sys.toast、sys.msleep "},"Handbook/device/device.set_autolock_time.html":{"url":"Handbook/device/device.set_autolock_time.html","title":"设置自动锁屏分钟数 (device.set_autolock_time)","keywords":"","body":"设置自动锁屏分钟数 (device.set_autolock_time) 声明 device.set_autolock_time(分钟数) 参数及返回值 分钟数 整数型，用于设置设备自动锁屏分钟数，设置为 0 则永不锁屏 说明 这个函数在 1.1.2-1 版以上方可使用只能设置为设备有的分钟等级 示例 device.set_autolock_time(0) "},"Handbook/device/device.set_volume.html":{"url":"Handbook/device/device.set_volume.html","title":"设置设备音量 (device.set_volume)","keywords":"","body":"设置设备音量 (device.set_volume) 声明 device.set_volume(音量) 参数及返回值 音量 实数型，用于设置设备的音量，范围 0.0~1.0 示例 device.set_volume(0) -- 设备静音 "},"Handbook/device/device.join_wifi.html":{"url":"Handbook/device/device.join_wifi.html","title":"加入到一个无线局域网 (device.join_wifi)","keywords":"","body":"加入到一个无线局域网 (device.join_wifi) 声明 device.join_wifi(SSID, 密码, 加密类型) 参数及返回值 SSID 文本型，无线局域网的 SSID，也就是名字 密码 文本型，无线局域网的密码 加密类型 整数型，加密类型，可以是 0 表示不加密网络 1 表示有密码网络 说明 这个函数在 1.2-1 版以上方可使用这个函数不支持 iOS 10 及以上版本操作系统注意：加入无线局域网可能会需要较长时间，也可能加入失败，请自行写代码延迟并判断 示例 device.join_wifi('Tenda_9B3F', '123456', 1) "},"Handbook/image/index.html":{"url":"Handbook/image/index.html","title":"图片对象模块","keywords":"","body":"图片对象模块 判断一个值是否是图片对象 (image.is) 创建指定尺寸空白图片对象 (image.new) 图像合并 (image.oper_merge) 新建一个文本图片对象 (image.new_text_image) 从文件创建图片对象 (image.load_file) 从数据创建图片对象 (image.load_data) 从图片对象创建拷贝图片对象 (:copy) 从图片对象截取部分新建拷贝图片对象 (:crop) 保存图片对象到相册 (:save_to_album) 输出图片对象到一个 PNG 格式的文件 (:save_to_png_file) 输出图片对象到一个 JPEG 格式的文件 (:save_to_jpeg_file) 获取图片对象的 PNG 格式数据 (:png_data) 获取图片对象的 JPEG 格式数据 (:jpeg_data) 90度左旋图片对象 (:turn_left) 90度右旋图片对象 (:turn_right) 180度旋转图片对象 (:turn_upondown) 获取图片对象的尺寸 (:size) 获取图片对象某点颜色 (:get_color) 设置图片对象某点颜色 (:set_color) 颜色替换 (:replace_color) 图中贴图 (:draw_image) 二值化处理图片对象 (:binaryzation) 在图上找色 (:find_color) 图片多点颜色匹配 (:is_colors) 解码一个二维码图片 (:qr_decode) 销毁一个图片对象 (:destroy) cv - 图中找图 (:cv_find_image) cv - 图片自动二值化 (:cv_binaryzation) cv - 从图片创建一个拉伸的另外尺寸的图片 (:cv_resize) tesseract - 对图片进行 ocr 识别 (:tess_ocr) "},"Handbook/image/image.is.html":{"url":"Handbook/image/image.is.html","title":"判断一个值是否是图片对象 (image.is)","keywords":"","body":"判断一个值是否是图片对象 (image.is) 声明 是否图片 = image.is(需要判断的值) 参数及返回值 需要判断的值 值，需要判断是否是图片对象的值 是否图片 布尔型，值是图片对象返回 true，否则返回 false 说明 判断一个值是否是图片对象 示例 if image.is(img) then -- img 是个图片对象 else -- img 不是图片对象 end "},"Handbook/image/image.new.html":{"url":"Handbook/image/image.new.html","title":"创建指定尺寸空白图片对象 (image.new)","keywords":"","body":"创建指定尺寸空白图片对象 (image.new) 声明 图像 = image.new(宽, 高) 参数及返回值 宽, 高 整数型，新建的图片对象的宽, 高 图像 图片对象，返回新建的图片对象 说明 创建空白图片对象，默认这图像上所有的点的颜色皆为0x000000 (黑)该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 "},"Handbook/image/image.oper_merge.html":{"url":"Handbook/image/image.oper_merge.html","title":"图像合并 (image.oper_merge)","keywords":"","body":"图像合并 (image.oper_merge) 声明 操作成败 = image.oper_merge(图片文件名数组, 输出路径, 合并类型, 生成质量) 参数及返回值 图片文件名数组 表型，需合并图片的文件名列表，支持使用绝对路径 输出路径 文本型，生成新图片的文件名，支持使用绝对路径 合并类型 整数型，合并类型，0 - 横向合并；1 - 竖向合并 生成质量 实数型，当生成图片格式为 jpg 时，可控制图片质量，范围 0.0 ~ 1.0 操作成败 整数型，0 - 成功；1 - 失败；2 - 失败；3 - 失败 说明 默认图片路径为 /var/mobile/Media/1ferver/res，自建目录请填写相对路径 示例 image.oper_merge({\"1.png\",\"2.png\",\"3.png\"}, \"4.jpg\", 0, 0.5) "},"Handbook/image/image.new_text_image.html":{"url":"Handbook/image/image.new_text_image.html","title":"新建一个文本图片对象 (image.new_text_image)","keywords":"","body":"新建一个文本图片对象 (image.new_text_image) 声明 图像 = image.new_text_image(文本[, { font = 字体, size = 字体大小, color = 字体颜色, alpha = 字体不透明度, back_color = 背景色, back_alpha = 背景不透明度, }]) 参数及返回值 文本 文本型，需要绘制的文本内容 字体 文本型，可选参数，需要绘制的文本的字体，默认 \"Arial\" 字体大小 实数型，可选参数，需要绘制的文本的字体大小，默认 20.0 字体颜色 整数型，可选参数，需要绘制的文本的字体颜色，默认 0xffffff (白) 字体不透明度 整数型，可选参数，需要绘制的文本的字体不透明度，范围 0~255，默认 255 背景色 整数型，可选参数，图片背景色，默认 0x000000 (黑) 背景不透明度 整数型，可选参数，图片背景不透明度，范围 0~255，默认 255 图像 图片对象，返回新建的图片对象 说明 新建一个适合尺寸的图片对象，并将文本绘制于上该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 "},"Handbook/image/image.load_file.html":{"url":"Handbook/image/image.load_file.html","title":"从文件创建图片对象 (image.load_file)","keywords":"","body":"从文件创建图片对象 (image.load_file) 声明 图像 = image.load_file(文件路径) 参数及返回值 文件路径 文本型，图片文件绝对路径 图像 图片对象 或 nil，返回新建的图片对象，如果文件不存在则返回 nil 说明 从文件创建图片对象该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 示例 将文件转存到相册 "},"Handbook/image/image.load_data.html":{"url":"Handbook/image/image.load_data.html","title":"从数据创建图片对象 (image.load_data)","keywords":"","body":"从数据创建图片对象 (image.load_data) 声明 图像 = image.load_data(图像数据) 参数及返回值 图像数据 字符串型，png 或 jpeg 格式的图片数据 图像 图片对象 或 nil，返回新建的图片对象，如果数据不是图像格式则返回 nil 说明 从数据创建图片对象该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 示例 从网上下载个小图片直接转存到相册 "},"Handbook/image/_copy.html":{"url":"Handbook/image/_copy.html","title":"从图片对象创建拷贝图片对象 (:copy)","keywords":"","body":"从图片对象创建拷贝图片对象 (:copy) 声明 图像2 = 图像1:copy() 参数及返回值 图像1 图片对象，原始图片对象 图像2 图片对象，返回新建的图片对象 说明 从图片对象创建拷贝图片对象该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 示例 scrn = screen.image() img2 = scrn:copy() 注：上述代码中使用了非本章函数 screen.image "},"Handbook/image/_crop.html":{"url":"Handbook/image/_crop.html","title":"从图片对象截取部分新建拷贝图片对象 (:crop)","keywords":"","body":"从图片对象截取部分新建拷贝图片对象 (:crop) 声明 图像2 = 图像1:crop([左, 上, 右, 下]) 参数及返回值 图像1 图片对象，原始图片对象 左, 上, 右, 下 整数型，可选参数，原始图像中的区域左上右下坐标，默认 0, 0, 原图宽-1, 原图高-1 图像2 图片对象，返回新建的图片对象 说明 从图片对象截取部分新建拷贝图片对象该方法会产出一个新的图片对象，如需保证高效频繁使用请搭配 image:destroy 方法使用 示例 scrn = screen.image() img2 = scrn:crop(100, 100, 200, 200) 注：上述代码中使用了非本章函数 screen.image "},"Handbook/image/_save_to_album.html":{"url":"Handbook/image/_save_to_album.html","title":"保存图片对象到相册 (:save_to_album)","keywords":"","body":"保存图片对象到相册 (:save_to_album) 声明 图像:save_to_album() 参数及返回值 图像 图片对象，需要保存到相册的图片对象 说明 导出图片对象的图片到系统相册 示例 1 -- 从网上下载个小图片直接转存到相册 local c, h, r = http.get(\"https://www.xxtouch.com/img/Logo.png\", 10) if (c == 200) then local img = image.load_data(r) img:save_to_album() sys.alert(\"图片已存到相册\") else sys.alert(\"下载失败\") end 注：上述代码中使用了非本章函数 sys.alert、http.get 示例 2 -- 截全屏图像保存到相册 screen.image():save_to_album() 注：上述代码中使用了非本章函数 screen.image 示例 3 -- 将文件转存到相册 (这只是例子，文件不存在会报错，请在保存之前先做判断) image.load_file(\"/var/mobile/1.png\"):save_to_album() 示例 4 -- 将文件转存到相册 img = image.load_file(\"/var/mobile/1.png\") if image.is(img) then img:save_to_album() end "},"Handbook/image/_save_to_png_file.html":{"url":"Handbook/image/_save_to_png_file.html","title":"输出图片对象到一个 PNG 格式的文件 (:save_to_png_file)","keywords":"","body":"输出图片对象到一个 PNG 格式的文件 (:save_to_png_file) 声明 图像:save_to_png_file(文件路径) 参数及返回值 图像 图片对象，需要保存到文件的图片对象 文件路径 文本型，需要保存到图片文件的绝对路径 说明 输出图片对象到一个 PNG 格式的文件，扩展名可以不是 PNG 示例 -- 截全屏图像保存到文件 screen.image():save_to_png_file(\"/var/mobile/1.png\") 注：上述代码中使用了非本章函数 screen.image "},"Handbook/image/_save_to_jpeg_file.html":{"url":"Handbook/image/_save_to_jpeg_file.html","title":"输出图片对象到一个 JPEG 格式的文件 (:save_to_jpeg_file)","keywords":"","body":"输出图片对象到一个 JPEG 格式的文件 (:save_to_jpeg_file) 声明 图像:save_to_jpeg_file(文件路径 [, 图像质量 ]) 参数及返回值 图像 图片对象，需要保存到文件的图片对象 文件路径 文本型，需要保存到图片文件的绝对路径 图像质量 实数型，可选参数，图片质量，取值范围 0.0~1.0，默认 1.0 说明 输出图片对象到一个 JPEG 格式的文件，扩展名可以不是 JPG 示例 -- 截全屏图像保存到文件 screen.image():save_to_jpeg_file(\"/var/mobile/1.jpg\") -- 截全屏图像保存到文件并设置图片为低质量 (关键字：有损压缩 图像压缩 图片压缩 图片质量) screen.image():save_to_jpeg_file(\"/var/mobile/1.jpg\", 0.4) 注：上述代码中使用了非本章函数 screen.image "},"Handbook/image/_png_data.html":{"url":"Handbook/image/_png_data.html","title":"获取图片对象的 PNG 格式数据 (:png_data)","keywords":"","body":"获取图片对象的 PNG 格式数据 (:png_data) 声明 图像PNG数据 = 图像:png_data() 参数及返回值 图像 图片对象，当前操作的图片对象 图像PNG数据 字符串型，返回 PNG 数据，对这份数据的修改不会影响图片对象 说明 获取图片对象的 PNG 格式数据性能上，该函数操作过程产生两次数据拷贝 示例 file.writes('/var/mobile/1.png', screen.image():png_data()) 注：上述代码中使用了非本章函数 screen.image、file.writes "},"Handbook/image/_jpeg_data.html":{"url":"Handbook/image/_jpeg_data.html","title":"获取图片对象的 JPEG 格式数据 (:jpeg_data)","keywords":"","body":"获取图片对象的 JPEG 格式数据 (:jpeg_data) 声明 图像JPG数据 = img:jpeg_data([ 图像质量 ]) 参数及返回值 图像 图片对象，当前操作的图片对象 图像质量 实数型，可选参数，图片质量，取值范围 0.0~1.0，默认 1.0 图像JPG数据 字符串型，返回 JPEG 数据，对这份数据的修改不会影响图片对象 说明 获取图片对象的 JPEG 格式数据性能上，该函数操作过程产生两次数据拷贝 示例 -- 截全屏图像保存到文件并设置图片为 80% 质量 (关键字：有损压缩 图像压缩 图片压缩 图片质量) file.writes('/var/mobile/1.jpg', screen.image():jpeg_data(0.8)) 注：上述代码中使用了非本章函数 screen.image、file.writes "},"Handbook/image/_turn_left.html":{"url":"Handbook/image/_turn_left.html","title":"90度左旋图片对象 (:turn_left)","keywords":"","body":"90度左旋图片对象 (:turn_left) 声明 图像 = 图像:turn_left() 参数及返回值 图像 图片对象，当前操作的图片对象 说明 90 度左旋图片对象会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_turn_right.html":{"url":"Handbook/image/_turn_right.html","title":"90度右旋图片对象 (:turn_right)","keywords":"","body":"90度右旋图片对象 (:turn_right) 声明 图像 = 图像:turn_right() 参数及返回值 图像 图片对象，当前操作的图片对象 说明 90 度右旋图片对象会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_turn_upondown.html":{"url":"Handbook/image/_turn_upondown.html","title":"180度旋转图片对象 (:turn_upondown)","keywords":"","body":"180度旋转图片对象 (:turn_upondown) 声明 图像 = 图像:turn_upondown() 参数及返回值 图像 图片对象，当前操作的图片对象 说明 180 度旋转图片对象会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_size.html":{"url":"Handbook/image/_size.html","title":"获取图片对象的尺寸 (:size)","keywords":"","body":"获取图片对象的尺寸 (:size) 声明 宽, 高 = 图像:size() 参数及返回值 图像 图片对象，当前操作的图片对象 宽, 高 整数型，当前操作的图片对象的 宽、高 说明 获取图片对象的尺寸，注意这里返回的 w 不一定比 h 短，旋转会发生改变 示例 local img = image.load_file(\"/var/mobile/1.png\") local w, h = img:size() sys.alert(\"图像的宽：\"..w..\"\\n图像的高：\"..h) "},"Handbook/image/_get_color.html":{"url":"Handbook/image/_get_color.html","title":"获取图片对象某点颜色 (:get_color)","keywords":"","body":"获取图片对象某点颜色 (:get_color) 声明 颜色, 不透明度 = 图像:get_color(横坐标, 纵坐标) 参数及返回值 图像 图片对象，当前操作的图片对象 横坐标, 纵坐标 整数型，需要获取颜色的点于当前图片对象上的坐标 颜色 整数型，返回当前图片对象上的这个坐标的颜色值，值得一提的是，假如颜色不透明度不是 255，则该点颜色红绿蓝实际会需要考虑除以不透明率（不透明度/255） 不透明度 整数型，返回当前图片对象上的这个坐标的不透明度，取值范围 0~255 说明 获取图片对象某点颜色，不同于屏幕取色之处在于，图像中的像素还多了透明度属性 示例 local img = image.load_file(\"/var/mobile/1.png\") local clr = img:get_color(100, 100) sys.alert(string.format(\"图像上坐标 (100, 100) 的颜色为：0x%06x\", clr)) "},"Handbook/image/_set_color.html":{"url":"Handbook/image/_set_color.html","title":"设置图片对象某点颜色 (:set_color)","keywords":"","body":"设置图片对象某点颜色 (:set_color) 声明 图像 = 图像:set_color(横坐标, 纵坐标, 颜色) 参数及返回值 图像 图片对象，当前操作的图片对象 横坐标, 纵坐标 整数型，需要设置颜色的点于当前图片对象上的坐标 颜色 整数型，需要设置的颜色值 说明 设置图片对象某点颜色会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_replace_color.html":{"url":"Handbook/image/_replace_color.html","title":"颜色替换 (:replace_color)","keywords":"","body":"颜色替换 (:replace_color) 声明 图像 = 图像:replace_color(原色, 替换色[, 原色相似度]) 参数及返回值 图像 图片对象，当前操作的图片对象 原色 整数型，原来的颜色 替换色 整数型，需要变成的颜色 原色相似度 整数型，可选参数，颜色相似度，范围 0~100，默认 100 说明 将图片对象上某种颜色 (或及近似色) 替换为另外的颜色会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 示例 二维码背景色替换 "},"Handbook/image/_draw_image.html":{"url":"Handbook/image/_draw_image.html","title":"图中贴图 (:draw_image)","keywords":"","body":"图中贴图 (:draw_image) 声明 大图像 = 大图像:draw_image(小图像[, { left = 左上的 x 坐标, top = 左上的 y 坐标, alpha = 不透明度, background = { {颜色*, 色偏*}, {颜色*, 色偏*}, ... }, }]) 参数及返回值 大图像 图片对象，当前操作的图片对象 小图像 图片对象，需要绘制到 大图像 上的图像 左上的 x 坐标 整数型，可选参数，需要将 小图像 绘制到 大图像 的左上角的 x 坐标，默认 0 左上的 y 坐标 整数型，可选参数，需要将 小图像 绘制到 大图像 的左上角的 y 坐标，默认 0 不透明度 整数型，可选参数，小图像 的不透明度，范围 0~255，默认 255 颜色*, 色偏* 顺序表型，可选参数，小图像 上的与 颜色* 色差在 色偏* 范围内的颜色将不会绘制到 大图像 上，默认 不忽略任何颜色 说明 在图像上绘制另外一个图像会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_binaryzation.html":{"url":"Handbook/image/_binaryzation.html","title":"二值化处理图片对象 (:binaryzation)","keywords":"","body":"二值化处理图片对象 (:binaryzation) 声明 图像 = 图像:binaryzation({ {颜色*, 色偏*}, {颜色*, 色偏*}, ... }) 图像 = 图像:binaryzation(\"cx*-cox*,cx*-cox*...\") 参数及返回值 图像 图片对象，当前操作的图片对象 颜色*, 色偏* 整数型，颜色值白名单，颜色* 是颜色值本身，色偏* 是 颜色* 的最大色差值 cx*-cox* 文本型，颜色值白名单，cx* 是颜色值本身的16进制文本描述，cox* 是 cx* 的最大色差值16进制文本描述 说明 二值化处理图片对象会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 示例 local pic = screen.image(462, 242, 569, 272) pic = pic:binaryzation({ {0x9D5D39, 0x0F1F26}, {0xD3D3D2, 0x2C2C2D}, }) local pic = screen.image(462, 242, 569, 272) pic = pic:binaryzation(\"9D5D39-0F1F26,D3D3D2-2C2C2D\") "},"Handbook/image/_find_color.html":{"url":"Handbook/image/_find_color.html","title":"在图上找色 (:find_color)","keywords":"","body":"在图上找色 (:find_color) 声明 横坐标, 纵坐标 = 图像:find_color(...) 参数及返回值 图像 图片对象，当前操作的图片对象 详细用法参考 screen.find_color 说明 在图上找色 "},"Handbook/image/_is_colors.html":{"url":"Handbook/image/_is_colors.html","title":"图片多点颜色匹配 (:is_colors)","keywords":"","body":"图片多点颜色匹配 (:is_colors) 声明 是否完全匹配 = 图像:is_colors(...) 参数及返回值 图像 图片对象，当前操作的图片对象 详细用法参考 screen.is_colors 说明 图片多点颜色匹配 "},"Handbook/image/_qr_decode.html":{"url":"Handbook/image/_qr_decode.html","title":"解码一个二维码图片 (:qr_decode)","keywords":"","body":"解码一个二维码图片 (:qr_decode) 声明 识别文本 = 图像:qr_decode() 参数及返回值 图像 图片对象，当前操作的图片对象 识别文本 文本型 或 nil，返回当前二维码解码之后的文字，如果不是二维码或不能解码则返回 nil 说明 解码一个包含二维码图片，不一定需要纯二维码图像，有杂物可能也能正确识别 示例 -- 解码一个本地二维码图片文件 local img = image.load_file(\"/var/mobile/qr.png\") if img then local str = img:qr_decode() img:destroy() if str then sys.alert(\"识别成功\\n识别结果是：\"..str) else sys.alert(\"识别失败\") end else sys.alert(\"图片文件加载失败，文件或许不存在\") end -- 解码当前屏幕上显示的二维码 local str = screen.image():qr_decode() if str then sys.alert(\"识别成功\\n识别结果是：\"..str) else sys.alert(\"识别失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/image/_destroy.html":{"url":"Handbook/image/_destroy.html","title":"销毁一个图片对象 (:destroy)","keywords":"","body":"销毁一个图片对象 (:destroy) 声明 图像:destroy() 参数及返回值 图像 图片对象，当前操作的图片对象 说明 立即释放图片对象的内存占用，被销毁的图片对象不能再使用该方法为性能优化方法，在频繁创建新图片对象的情形下，建议一定要使用该方法释放掉不再使用的图片对象以防止内存占用过高导致设备卡死崩溃等问题不是频繁创建图片对象的情况下可以不使用当前方法，并不会有内存泄露，lua 自带的垃圾回收机制会延迟一段时间将不再使用的数据回收 示例 sys.alert(\"点击确定1秒后开始监控屏幕状态\") -- sys.msleep(1000) -- local img = screen.image() while 1 do local scn = screen.image() local x, y, s = scn:cv_find_image(img) scn:destroy() if s 注：上述代码中使用了非本章函数 sys.alert、sys.msleep "},"Handbook/image/_cv_find_image.html":{"url":"Handbook/image/_cv_find_image.html","title":"cv - 图中找图 (:cv_find_image)","keywords":"","body":"cv - 图中找图 (:cv_find_image) 声明 require(\"image.cv\") -- 需要提前加载 -- 横坐标, 纵坐标, 相似度 = 大图像:cv_find_image(小图像) 参数及返回值 大图像 图片对象，当前操作的图片对象 小图像 图片对象，需要找的小图 横坐标, 纵坐标 整数型，找到的小图在大图上的最匹配的位置的左上角坐标 相似度 实数型，返回找到的小图在大图上的最匹配的位置的相似度，范围 0~100 说明 opencv 扩展功能，在一个图片对象中找另外一个图片对象位置 "},"Handbook/image/_cv_binaryzation.html":{"url":"Handbook/image/_cv_binaryzation.html","title":"cv - 图片自动二值化 (:cv_binaryzation)","keywords":"","body":"cv - 图片自动二值化 (:cv_binaryzation) - 声明 require(\"image.cv\") -- 需要提前加载 -- 图像 = 图像:cv_binaryzation([ 二值化阈值 ]) 参数及返回值 图像 图片对象，当前操作的图片对象 二值化阈值 实数型，可选参数，阈值，范围 0~255，默认选理论上最合适的阈值 说明 opencv 扩展功能，图片自动二值化会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝 "},"Handbook/image/_cv_resize.html":{"url":"Handbook/image/_cv_resize.html","title":"cv - 从图片创建一个拉伸的另外尺寸的图片 (:cv_resize)","keywords":"","body":"cv - 从图片创建一个拉伸的另外尺寸的图片 (:cv_resize) 声明 require(\"image.cv\") -- 需要提前加载 -- 新图像 = 图像:cv_resize(宽, 高) 参数及返回值 图像 图片对象，当前操作的图片对象 宽, 高 整数型，设定的新图片宽高 新图像 图片对象，返回一个全新尺寸的图片对象 说明 opencv 扩展功能，从图片创建一个拉伸的另外尺寸的图片会对对象本身产生影响 "},"Handbook/image/_tess_ocr.html":{"url":"Handbook/image/_tess_ocr.html","title":"tesseract - 对图片进行 ocr 识别 (:tess_ocr)","keywords":"","body":"tesseract - 对图片进行 ocr 识别 (:tess_ocr) 声明 require(\"image.tess_ocr\") -- 需要提前加载 -- 识别结果, 结果详情 = 图像:tess_ocr([{ [lang = 语言,] [white_list = 白名单,] [black_list = 黑名单,] }]) 参数及返回值 图像 图片对象，当前操作的图片对象 语言 文本型，可选参数，使用的字库名称，默认 \"eng\" 白名单 文本型，可选参数，只允许展示的白名单，默认 无 黑名单 文本型，可选参数，只过滤的黑名单，默认 \"\" 识别结果 文本型，返回识别的结果 结果详情 *1.1.3-1 新增 表型，识别结果的每个可见字符的位置描述 说明 tesseract 扩展功能，识别文字 (XXTouch 已内置 eng 识别库 [A-Za-z0-9] 能识别常规英文和数字)内置 tesseract 引擎版本为 3.02，版本不对或者字库文件损坏会导致 XXTouch 脚本服务崩溃这里提供适用于 XXTouch 的 tesseract 引擎版本为 3.05 版的 OCR 识别库 tess_ocr_1.2_with_tesseract_3.05.01.zip白名单参数和黑名单参数不可同时存在会对对象本身产生影响性能上，该函数操作过程不产生数据拷贝如果需要做简体中文或是其它语言文字识别需要手动导入相关的字库文件到设备的 /var/mobile/Media/1ferver/tessdata/ 目录这里提供 简体中文字库 (点击下载) 如果想自己进行 tesseract 字库训练可以 百度搜索“tesseract 训练” 示例 require(\"image.tess_ocr\") -- 需要提前加载 -- text = img:tess_ocr() -- 默认为 \"eng\"，英文识别 -- text = img:tess_ocr('chi_sim') -- 简体中文识别 -- text = img:tess_ocr{ lang = \"eng\", -- 英文字库 white_list = \"0123456789\", -- 白名单 } -- text = img:tess_ocr{ lang = \"eng\", -- 英文字库 black_list = \"abcdefghijk\", -- 黑名单 } -- text = img:tess_ocr{ lang = \"chi_sim\", -- 简体中文字库 white_list = \"0123456789.元\", -- 白名单 } "},"Handbook/proc/index.html":{"url":"Handbook/proc/index.html","title":"进程字典","keywords":"","body":"进程字典 存储值到进程字典 (proc_put) 查看进程字典存储的值 (proc_get) 向进程队列词典中压入一个值 (proc_queue_push) 从进程队列词典中弹出一个值 (proc_queue_pop) 从进程队列词典中弹出所有值 (proc_queue_clear) 获取进程队列词典的尺寸 (proc_queue_size) 向进程队列词典头部压入一个值 (proc_queue_push_front) 向进程队列词典尾部压入一个值 (proc_queue_push_back) 从进程队列词典头部弹出一个值 (proc_queue_pop_front) 从进程队列词典尾部弹出一个值 (proc_queue_pop_back) "},"Handbook/proc/proc_put.html":{"url":"Handbook/proc/proc_put.html","title":"存储值到进程字典 (proc_put)","keywords":"","body":"存储值到进程字典 (proc_put) 声明 old_value = proc_put(key, value) 参数及返回值 key 字符串型，代表键 value 字符串型，代表需要设置的值 old_value 字符串型，返回这个键位置的旧的值，如果没有则返回空字符串 说明 所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程词典全部被保留存储值到进程字典并返回该键位置原来的值如果该键位置原先没有值，则返回空字符串存储空字符串代表清空该键位置 示例 local bill = \"\" while bill==\"\" do bill = proc_put(\"billno\", \"\") end print(\"billno: \".. bill) "},"Handbook/proc/proc_get.html":{"url":"Handbook/proc/proc_get.html","title":"查看进程字典存储的值 (proc_get)","keywords":"","body":"查看进程字典存储的值 (proc_get) 声明 value = proc_get(key) 参数及返回值 key 字符串型，代表键 value 字符串型，返回该键位置存储的值，如果该键位置没有值则返回空字符串 说明 这个函数已不推荐使用，可以尝试使用 proc_put 来代替所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程词典全部被保留从进程词典的指定键位中读取值如果该键位置原先没有值，则返回空字符串 示例 local bill = proc_get(\"billno\") if bill~=\"\" then print(\"has a bill: \".. bill) else print(\"no bill\") end "},"Handbook/proc/proc_queue_push.html":{"url":"Handbook/proc/proc_queue_push.html","title":"向进程队列词典中压入一个值 (proc_queue_push)","keywords":"","body":"向进程队列词典中压入一个值 (proc_queue_push) 声明 size = proc_queue_push(key, value) 参数及返回值 key 字符串型，代表键 value 字符串型，代表需要压入的值 size 整数型，压入值之后，返回该队列的尺寸，如果返回 0 ，则为压入失败 说明 此函数效果等同 proc_queue_push_back所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留进程队列词典的队列尺寸不能大于 10000，尺寸超过的队列将丢弃最先压入的值往进程队列词典中压入一个值，压入值之后，返回该队列的尺寸不能压入空字符串 示例 local size = proc_queue_push(\"billnos\", \"name\") if size~=0 then print(\"has \"..size..\" bill(s)\") else print(\"failed\") end "},"Handbook/proc/proc_queue_pop.html":{"url":"Handbook/proc/proc_queue_pop.html","title":"从进程队列词典中弹出一个值 (proc_queue_pop)","keywords":"","body":"从进程队列词典中弹出一个值 (proc_queue_pop) 声明 value = proc_queue_pop(key) 参数及返回值 key 字符串型，代表键 value 字符串型，返回弹出的值，如果队列不存在或为空，则返回空字符串 说明 此函数效果等同 proc_queue_pop_front所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留从进程队列词典中弹出一个值如果队列不存在或为空，则弹出一个空字符串 示例 local billno = proc_queue_pop(\"billnos\") if billno~=\"\" then print(billno) else print(\"no bill\") end "},"Handbook/proc/proc_queue_clear.html":{"url":"Handbook/proc/proc_queue_clear.html","title":"从进程队列词典中弹出所有值 (proc_queue_clear)","keywords":"","body":"从进程队列词典中弹出所有值 (proc_queue_clear) 声明 values = proc_queue_clear(key) 参数及返回值 key 字符串型，代表键 values 顺序表型，返回包含弹出的所有值的顺序表，如果队列不存在或为空，则返回空表 说明 所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留从进程队列词典中弹出所有值，清空指定队列 示例 local billnos = proc_queue_clear(\"billnos\") if #billnos~=0 then for i, billno in ipairs(billnos) do print(i, billno) end else print(\"no bill\") end "},"Handbook/proc/proc_queue_size.html":{"url":"Handbook/proc/proc_queue_size.html","title":"获取进程队列词典的尺寸 (proc_queue_size)","keywords":"","body":"获取进程队列词典的尺寸 (proc_queue_size) 声明 size = proc_queue_size(key) 参数及返回值 key 字符串型，代表键 size 整数型，返回该进程队列词典中的有效条目数 说明 所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留获取进程队列词典的尺寸 示例 local size = proc_queue_size(\"billnos\") if size~=0 then print(\"has \"..size..\" bill(s)\") else print(\"no bill\") end "},"Handbook/proc/proc_queue_push_front.html":{"url":"Handbook/proc/proc_queue_push_front.html","title":"向进程队列词典头部压入一个值 (proc_queue_push_front)","keywords":"","body":"向进程队列词典头部压入一个值 (proc_queue_push_front) 声明 size = proc_queue_push_front(key, value) 参数及返回值 key 字符串型，代表键 value 字符串型，代表需要压入的值 size 整数型，压入值之后，返回该队列的尺寸，如果返回 0 ，则为压入失败 说明 这个函数在 1.1.2-1 版以上方可使用所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留进程队列词典的队列尺寸不能大于 10000，尺寸超过的队列将丢弃最先压入的值往进程队列词典头部压入一个值，压入值之后，返回该队列的尺寸不能压入空字符串 示例 local size = proc_queue_push_front(\"billnos\", \"name\") if size~=0 then print(\"has \"..size..\" bill(s)\") else print(\"failed\") end "},"Handbook/proc/proc_queue_push_back.html":{"url":"Handbook/proc/proc_queue_push_back.html","title":"向进程队列词典尾部压入一个值 (proc_queue_push_back)","keywords":"","body":"向进程队列词典尾部压入一个值 (proc_queue_push_back) 声明 size = proc_queue_push_back(key, value) 参数及返回值 key 字符串型，代表键 value 字符串型，代表需要压入的值 size 整数型，压入值之后，返回该队列的尺寸，如果返回 0 ，则为压入失败 说明 这个函数在 1.1.2-1 版以上方可使用此函数效果等同 proc_queue_push所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留进程队列词典的队列尺寸不能大于 10000，尺寸超过的队列将丢弃最先压入的值往进程队列词典尾部压入一个值，压入值之后，返回该队列的尺寸不能压入空字符串 示例 local size = proc_queue_push_back(\"billnos\", \"name\") if size~=0 then print(\"has \"..size..\" bill(s)\") else print(\"failed\") end "},"Handbook/proc/proc_queue_pop_front.html":{"url":"Handbook/proc/proc_queue_pop_front.html","title":"从进程队列词典头部弹出一个值 (proc_queue_pop_front)","keywords":"","body":"从进程队列词典头部弹出一个值 (proc_queue_pop_front) 声明 value = proc_queue_pop_front(key) 参数及返回值 key 字符串型，代表键 value 字符串型，返回弹出的值，如果队列不存在或为空，则返回空字符串 说明 这个函数在 1.1.2-1 版以上方可使用此函数效果等同 proc_queue_pop所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留从进程队列词典头部弹出一个值如果队列不存在或为空，则弹出一个空字符串 示例 local billno = proc_queue_pop_front(\"billnos\") if billno~=\"\" then print(billno) else print(\"no bill\") end "},"Handbook/proc/proc_queue_pop_back.html":{"url":"Handbook/proc/proc_queue_pop_back.html","title":"从进程队列词典尾部弹出一个值 (proc_queue_pop_back)","keywords":"","body":"从进程队列词典尾部弹出一个值 (proc_queue_pop_back) 声明 value = proc_queue_pop_back(key) 参数及返回值 key 字符串型，代表键 value 字符串型，返回弹出的值，如果队列不存在或为空，则返回空字符串 说明 这个函数在 1.1.2-1 版以上方可使用所有以 \"xxtouch.\" 或 \"1ferver.\" 开头的进程队列词典全部被保留从进程队列词典尾部弹出一个值如果队列不存在或为空，则弹出一个空字符串 示例 local billno = proc_queue_pop_back(\"billnos\") if billno~=\"\" then print(billno) else print(\"no bill\") end "},"Handbook/thread/index.html":{"url":"Handbook/thread/index.html","title":"线程模块","keywords":"","body":"线程模块 前言 派发一个任务 (thread.dispatch) 获取当前任务的 ID (thread.current_id) 从队列中移除一项任务 (thread.kill) 阻塞等待一个任务完成 (thread.wait) 注册监听一个事件 (thread.register_event) 反注册监听一个事件 (thread.unregister_event) thread 示例代码 "},"Handbook/thread/START.html":{"url":"Handbook/thread/START.html","title":"前言","keywords":"","body":"前言 thread 模块使用 Lua 自带协程 (coroutine) 模块实现，非通常意义上的多线程。 "},"Handbook/thread/thread.dispatch.html":{"url":"Handbook/thread/thread.dispatch.html","title":"派发一个任务 (thread.dispatch)","keywords":"","body":"派发一个任务 (thread.dispatch) 声明 tid = thread.dispatch(task [, error_callback ]) 参数及返回值 task 函数型，这个函数将加入任务队列 error_callback 函数型，错误回调，当执行任务时发生异常，则会回调这个函数并不再抛出，可选参数，默认在异常时抛出错误 tid 整数型，任务 id，这个 id 可用于结束或是等待一个任务 说明 派发一个任务到队列，当其它任务空闲时则会开始该项任务 示例 本章最后 "},"Handbook/thread/thread.current_id.html":{"url":"Handbook/thread/thread.current_id.html","title":"获取当前任务的 ID (thread.current_id)","keywords":"","body":"获取当前任务的 ID (thread.current_id) 声明 tid = thread.current_id() 参数及返回值 tid 整数型，任务 id，这个 id 可用于结束或是等待一个任务 说明 获取当前任务的 id 示例 本章最后 "},"Handbook/thread/thread.kill.html":{"url":"Handbook/thread/thread.kill.html","title":"从队列中移除一项任务 (thread.kill)","keywords":"","body":"从队列中移除一项任务 (thread.kill) 声明 thread.kill(tid) 参数及返回值 tid 整数型，任务 id，这个 id 可用于结束或是等待一个任务 说明 从队列中移除一项任务，不管它是否已经开始，是否已经完成 示例 本章最后 "},"Handbook/thread/thread.wait.html":{"url":"Handbook/thread/thread.wait.html","title":"阻塞等待一个任务完成 (thread.wait)","keywords":"","body":"阻塞等待一个任务完成 (thread.wait) 声明 thread.wait(tid, timeout) 参数及返回值 timeout 实数型，等待超时时间，超时后将返回，单位：秒 tid 整数型，任务 id，这个 id 可用于结束或是等待一个任务 说明 当前线程阻塞等待一个任务完成 示例 本章最后 "},"Handbook/thread/thread.register_event.html":{"url":"Handbook/thread/thread.register_event.html","title":"注册监听一个事件 (thread.register_event)","keywords":"","body":"注册监听一个事件 (thread.register_event) 声明 eid = thread.register_event(event, callback [, error_callback ]) 参数及返回值 event 字符串型，代表事件名 callback 函数型，事件将会触发的回调函数 error_callback 函数型，错误回调，当执行任务时发生异常，则会回调这个函数并不再抛出，可选参数，默认在异常时抛出错误 eid 整数型，事件 id，可以用于反注册监听该事件 说明 注册监听一个事件 示例 本章最后 "},"Handbook/thread/thread.unregister_event.html":{"url":"Handbook/thread/thread.unregister_event.html","title":"反注册监听一个事件 (thread.unregister_event)","keywords":"","body":"反注册监听一个事件 (thread.unregister_event) 声明 eid = thread.unregister_event(event, eid) 参数及返回值 event 字符串型，代表事件名 eid 整数型，事件 id，可以用于反注册监听该事件 说明 反注册监听一个事件 示例 本章最后 "},"Handbook/thread/samples.html":{"url":"Handbook/thread/samples.html","title":"thread 示例代码","keywords":"","body":"thread 示例代码 tmid = thread.dispatch( -- 派发一个异步任务 function() sys.msleep(2700) sys.toast(\"这是第 2.7 秒\") end ) -- tid = thread.dispatch( -- 派发一个异步任务 function() sys.msleep(300) for i=1,10 do sys.toast(\"线程 2: \"..i) sys.msleep(1000) end sys.toast(\"应该运行不到这里\") end ) -- -- iPhone 5C 双指合拢缩小相册图片示例 -- thread.dispatch(function() -- 派发一个滑动任务 touch.on(59,165) :move(297,522) :msleep(500) :off() end) -- thread.dispatch(function() -- 再派发一个滑动任务 touch.on(580,1049) :move(371,1049) :msleep(500) :off() end) -- proc_queue_clear(\"来自远方的消息\") eid = thread.register_event( -- 注册监听字典状态有值事件 \"来自远方的消息\", function(val) sys.toast(\"收到消息：\"..val) end ) -- sys.msleep(300) thread.wait(tmid) -- for i=1,10 do sys.toast(\"线程 1: \"..i) sys.msleep(400) end -- thread.kill(tid) -- 杀死 线程 2 thread.unregister_event(\"来自远方的消息\", eid) -- 取消一个字典状态有值事件 -- sys.toast(\"完了\") 注：上述代码中使用了非本章函数及方法 proc_queue_clear、sys.msleep、sys.toast、touch.on、:move、:msleep、:off "},"Handbook/webview/index.html":{"url":"Handbook/webview/index.html","title":"Web 视图模块","keywords":"","body":"Web 视图模块 展现一个 webview (webview.show) 隐藏一个 webview (webview.hide) 在一个 webview 上执行一段 JS (webview.eval) 获取一个 webview 的区域及层级信息 (webview.frame) 销毁一个 webview (webview.destroy) webview 使用示例 "},"Handbook/webview/webview.show.html":{"url":"Handbook/webview/webview.show.html","title":"展现一个 webview (webview.show)","keywords":"","body":"展现一个 webview (webview.show) 声明 webview.show { -- 所有参数皆为可选参数 html = HTML内容, x = 原点横坐标, y = 原点纵坐标, width = 宽度, height = 高度, corner_radius = 圆角半径, alpha = 不透明度, animation_duration = 动画时间, rotate = 旋转角度, level = 窗体层级, opaque = 范围不透明, ignores_hit = 是否忽略触摸事件, can_drag = 是否能被拖动, } 字段说明 html 文本型，可选参数，页面 html 内容。默认为 上次调用 webview.show 时候所设 id 整数型，可选参数，表示当前 webview 的 id，可使用不同的 id 来同时展现多个 webview，范围 1 ~ 1000，默认为 1 x 整数型，可选参数，距离左侧的距离。默认为 0 y 整数型，可选参数，距离顶端的距离。默认为 0 width 整数型，可选参数，弹出窗口的宽度。默认为 屏幕宽度 height 整数型，可选参数，弹出的窗口高度。默认为 屏幕高度 alpha 实数型，可选参数，不透明度，范围 0.0 ~ 1.0。默认为 1.0 corner_radius 实数型，可选参数，圆角半径，0.0 则是方角。默认为 0.0 animation_duration 实数型，可选参数，从上次状态到参数所设状态的动画时间。默认为 0.0 rotate 实数型，可选参数，旋转状态， 0.0 (竖屏) 、90.0 (横屏 Home 在右) 、180.0 (竖屏翻转) 、270.0 (横屏 Home 在左) 。默认为 0.0 level 实数型，可选参数，窗体层级，默认 1100.0 opaque 布尔型，可选参数，背景不透明选项，默认为 true 背景不透明 ignores_hit 布尔型，可选参数，用于设置忽略 (不拦截) 触摸事件，默认为 false 不忽略，这个属性在 webview 创建后不能更改 can_drag 布尔型，可选参数，用于设置是否可拖拽移动 webview，默认为 false 不能拖动 说明 让 webview 以参数设置的那样出现除了 html 参数会保持上一次 show 的状态，其它参数一律会在调用时重设成默认值 示例 本章结尾 "},"Handbook/webview/webview.hide.html":{"url":"Handbook/webview/webview.hide.html","title":"隐藏一个 webview (webview.hide)","keywords":"","body":"隐藏一个 webview (webview.hide) 声明 webview.hide([ id ]) 参数及返回值 id 整数型，可选参数，表示当前 webview 的 id，范围 1 ~ 1000，默认为 1 说明 暂时隐藏一个 webview 示例 本章结尾 "},"Handbook/webview/webview.eval.html":{"url":"Handbook/webview/webview.eval.html","title":"在一个 webview 上执行一段 JS (webview.eval)","keywords":"","body":"在一个 webview 上执行一段 JS (webview.eval) 声明 str = webview.eval(js [, id ]) 参数及返回值 js 文本型，需要执行的 JS 代码 id 整数型，可选参数，表示当前 webview 的 id，范围 1 ~ 1000，默认为 1 str 文本型，返回执行 JS 代码产生的返回值 说明 在一个 webview 上执行一段 JS 并获得返回值文字 示例 r = webview.eval(\"a = 3; b = 2; a * b;\") "},"Handbook/webview/webview.frame.html":{"url":"Handbook/webview/webview.frame.html","title":"获取一个 webview 的区域及层级信息 (webview.frame)","keywords":"","body":"获取一个 webview 的区域及层级信息 (webview.frame) 声明 frame = webview.frame([ id ]) 参数及返回值 id 整数型，可选参数，表示当前 webview 的 id，范围 1 ~ 1000，默认为 1 frame 表型，返回当前 webview 的区域及层级信息 说明 获取一个 webview 的区域及层级信息 示例 local frame = webview.frame(1) sys.alert( \"位置为:\"..\"(\"..frame.x..\",\"..frame.y..\")\\n\".. \"大小为:\"..\"(宽:\"..frame.width..\",高:\"..frame.height..\")\\n\".. \"层级为:\"..\"(\"..frame.level..\")\" ) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/webview/webview.destroy.html":{"url":"Handbook/webview/webview.destroy.html","title":"销毁一个 webview (webview.destroy)","keywords":"","body":"销毁一个 webview (webview.destroy) 声明 webview.destroy([ id ]) 参数及返回值 id 整数型，可选参数，表示当前 webview 的 id，可使用不同的 id 来同时展现多个 webview，范围 1 ~ 1000，默认为 1 说明 销毁一个 webview脚本停止的时候，会自动调用销毁所有展现过的 webview 示例 本章结尾 "},"Handbook/webview/samples.html":{"url":"Handbook/webview/samples.html","title":"webview 使用示例","keywords":"","body":"webview 使用示例 一个演示 local html = [=[ $(document).ready(function(){ $(\"#toast_content\").val(\"toast内容\"); $(\"#close_page\").click(function(){ $.post( \"/proc_queue_push\", '{\"key\": \"来自webview的消息\",\"value\": \"关闭页面\"}', function(){} ); }); $(\"#show_toast\").click(function(){ $.post( \"/proc_put\", $.toJSON({ key:\"toast内容\", value:$(\"#toast_content\").val() }), function(){} ); $.post( \"/proc_queue_push\", '{\"key\": \"来自webview的消息\",\"value\": \"显示toast\"}', function(){} ); }); $(\"#slide_down\").click(function(){ $.post( \"/proc_queue_push\", '{\"key\": \"来自webview的消息\",\"value\": \"往下滑动\"}', function(){} ); $(this).hide(); }); $(\"#full_vertical\").click(function(){ $.post( \"/proc_queue_push\", '{\"key\": \"来自webview的消息\",\"value\": \"竖屏全屏\"}', function(){} ); }); $(\"#full_landscape\").click(function(){ $.post( \"/proc_queue_push\", '{\"key\": \"来自webview的消息\",\"value\": \"横屏全屏\"}', function(){} ); }); }); 动脚webview演示 点我关闭页面 显示一个toast 竖屏全屏横屏全屏 视图往下滑动 第1个选项 第2个选项 第3个选项 第4个选项 ]=] -- local w, h = screen.size() -- local factor = 1 -- 默认高度为 2x 设备所设 if w == 1242 or w == 1080 then factor = 1.5 -- iPhone 6(S)+ 的分辨率是 3x 的 elseif w == 320 or w == 768 then factor = 0.5 -- 3Gs 以前的 iPhone 的分辨率是 1x 的 end -- webview.show{ -- 重置 webview 位置到左上角 x = 0, y = 0, width = w - 40 * factor, height = (500) * factor, alpha = 0, animation_duration = 0, } -- webview.show{ -- 从左上角用0.3秒的时间滑动出来 html = html, x = 20 * factor, y = 50 * factor, width = (w - 40 * factor), height = (500) * factor, corner_radius = 10, alpha = 0.7, animation_duration = 0.3, } -- proc_queue_clear(\"来自webview的消息\", \"\") -- 清空需要监听的字典的值 local eid = thread.register_event( -- 注册监听字典状态有值事件 \"来自webview的消息\", function(val) if val == \"关闭页面\" then webview.show{ x = 20 * factor, y = 500 * factor * 2, width = (w - 40 * factor), height = (500 - 70) * factor, corner_radius = 10, alpha = 0, animation_duration = 0.8, } sys.msleep(800) webview.destroy() sys.toast(\"页面线程结束\") return true -- 返回 true 停止当前监听 elseif val == \"往下滑动\" then webview.show{ x = 20 * factor, y = (50 + 300) * factor, -- 纵坐标 + 300 width = (w - 40 * factor), height = (500 - 70) * factor, -- 往下滑动按钮被隐藏了，高度调整 corner_radius = 10, alpha = 0.7, animation_duration = 0.5, -- 耗时 0.5 秒 } elseif val == \"竖屏全屏\" then webview.show{} -- 此处将会把 webview 置为全屏 elseif val == \"横屏全屏\" then webview.show{rotate=90} -- 此处将会把 webview 置为横屏全屏 elseif val == \"显示toast\" then sys.toast(proc_get(\"toast内容\")) end end ) -- sys.msleep(3000) sys.toast(\"主线程结束\") 注：上述代码中使用了非本章函数 screen.size、proc_queue_clear、thread.register_event、proc_get、sys.toast、sys.msleep "},"Handbook/xpp/index.html":{"url":"Handbook/xpp/index.html","title":"XPP 脚本包模块","keywords":"","body":"XPP 脚本包模块 前言 获取当前脚本包的元信息 (xpp.info) 获取当前脚本包的包路径 (xpp.bundle_path) 获取当前脚本包中的资源路径 (xpp.resource_path) "},"Handbook/xpp/START.html":{"url":"Handbook/xpp/START.html","title":"前言","keywords":"","body":"前言 XPP ( 以下称作“脚本应用包” ) 是可以被 XXTouch 解析、查看与执行的一种 Bundle ( 包 ) 结构，以单一文件的形式出现在用户面前。这个“文件”实际上是一个以 .xpp 为扩展名的目录 ( 文件夹 ) 脚本包格式标准参考 XPP 格式 "},"Handbook/xpp/xpp.info.html":{"url":"Handbook/xpp/xpp.info.html","title":"获取当前脚本包的元信息 (xpp.info)","keywords":"","body":"获取当前脚本包的元信息 (xpp.info) 声明 元信息 = xpp.info() 参数及返回值 元信息 表型，返回当前脚本包的元信息，如果当前正在运行的脚本不是脚本包，返回一个空表 说明 这个函数在 1.2-3 版以上方可使用用于从运行着的脚本中获取当前脚本的元信息脚本包标准参考 XPP 示例 local info = xpp.info() "},"Handbook/xpp/xpp.bundle_path.html":{"url":"Handbook/xpp/xpp.bundle_path.html","title":"获取当前脚本包的包路径 (xpp.bundle_path)","keywords":"","body":"获取当前脚本包的包路径 (xpp.bundle_path) 声明 包路径 = xpp.bundle_path() 参数及返回值 包路径 文本型，返回当前脚本包的包路径，如果当前正在运行的脚本不是脚本包，返回当前运行的脚本路径 说明 这个函数在 1.2-3 版以上方可使用用于从运行着的脚本中获取当前脚本的路径脚本包标准参考 XPP 示例 local path = xpp.bundle_path() "},"Handbook/xpp/xpp.resource_path.html":{"url":"Handbook/xpp/xpp.resource_path.html","title":"获取当前脚本包中的资源路径 (xpp.resource_path)","keywords":"","body":"获取当前脚本包中的资源路径 (xpp.resource_path) 声明 资源路径 = xpp.resource_path(资源文件名) 参数及返回值 资源路径 文本型 或 nil，返回当前脚本包的某个资源文件的路径，如果资源不存在，则返回 nil 说明 这个函数在 1.2-3 版以上方可使用用于从运行着的脚本中获取当前脚本包中的某个资源文件的路径，支持本地化脚本包标准参考 XPP 示例 local path = xpp.resource_path('appicon.png') "},"Handbook/xui/index.html":{"url":"Handbook/xui/index.html","title":"XUI 脚本配置界面模块","keywords":"","body":"XUI 脚本配置界面模块 前言 展示一个配置界面 (xui.show) 收起正在展示的配置界面 (xui.dismiss) 校验配置界面的配置 (xui.setup) 重新加载当前正在展示的配置界面 (xui.reload) 获取配置界面的配置值 (xui.get) 设置配置界面上的某个控件的值 (xui.set) 读取某个配置分区所有配置 (xui.read) 覆盖写入配置表到某个配置分区 (xui.write) 清除某个配置分区所有的配置 (xui.clear) "},"Handbook/xui/START.html":{"url":"Handbook/xui/START.html","title":"前言","keywords":"","body":"前言 XUI 用于在 XXTouch 上提供配置界面, 采用 iOS 系统原生组件. 本手册提供了 XUI 界面布局的规范. XUI 是 XPP 脚本包 的一部分, 用来为脚本包创建配置, 不能独立使用. 脚本配置界面参考 XUI 格式 "},"Handbook/xui/xui.show.html":{"url":"Handbook/xui/xui.show.html","title":"展示一个配置界面 (xui.show)","keywords":"","body":"展示一个配置界面 (xui.show) 声明 xui.show(配置界面文件名) 参数及返回值 配置界面文件名 文本型，需要展示的当前脚本包中的配置界面文件（.xui）的文件名，只能是当前脚本包内的配置界面文件（.xui） 说明 这个函数在 1.2-10 版以上方可使用立刻使用 App 展示展示配置界面该函数不会阻塞，没有返回值，会调起 App 尝试展示，展示失败会在 App 内显示脚本配置界面标准参考 XUI 示例 xui.show('interface.xui') "},"Handbook/xui/xui.dismiss.html":{"url":"Handbook/xui/xui.dismiss.html","title":"收起正在展示的配置界面 (xui.dismiss)","keywords":"","body":"收起正在展示的配置界面 (xui.dismiss) 声明 xui.dismiss() 说明 这个函数在 1.2-10 版以上方可使用尝试让 App 收起配置界面回到主界面该函数不会阻塞，没有返回值，会调起 App 尝试收起配置界面，如果没有配置界面正在展示则跳转到 App 什么都不发生脚本配置界面标准参考 XUI 示例 xui.dismiss() "},"Handbook/xui/xui.setup.html":{"url":"Handbook/xui/xui.setup.html","title":"校验配置界面的配置 (xui.setup)","keywords":"","body":"校验配置界面的配置 (xui.setup) 声明 xui.setup(配置界面文件名) 参数及返回值 配置界面文件名 文本型，需要校验的当前脚本包中的配置界面文件（.xui）的文件名，只能是当前脚本包内的配置界面文件（.xui） 说明 这个函数在 1.2-10 版以上方可使用如果配置界面没有被配置过，则此函数用于生成该配置界面的默认配置，并且同时它会根据配置界面中的控件校验并修正存储的配置的值类型脚本配置界面标准参考 XUI 示例 xui.setup('interface.xui') "},"Handbook/xui/xui.reload.html":{"url":"Handbook/xui/xui.reload.html","title":"重新加载当前正在展示的配置界面 (xui.reload)","keywords":"","body":"重新加载当前正在展示的配置界面 (xui.reload) 声明 xui.reload() 说明 这个函数在 1.2-10 版以上方可使用如果当前没有正在展示配置界面，则什么都不发生注意控制好这个函数的调用频率，频率太高会导致 App 卡死脚本配置界面标准参考 XUI 示例 xui.reload() "},"Handbook/xui/xui.get.html":{"url":"Handbook/xui/xui.get.html","title":"获取配置界面的配置值 (xui.get)","keywords":"","body":"获取配置界面的配置值 (xui.get) 声明 值 = xui.get(配置分区, 配置键) 参数及返回值 配置分区 文本型，配置界面中的配置分区（defaults）标识符 配置键 文本型，配置界面中的控件的配置键（key）标识符 值 任意类型，不同的控件类型会返回不同的值，如果没有该配置值，返回 nil 说明 这个函数在 1.2-10 版以上方可使用该函数不负责过滤值类型，如果需要保证获取的值类型合法，可先使用 xui.setup 来校验修正再读取脚本配置界面标准参考 XUI 示例 xui.setup('interface.xui') local enabled = xui.get('com.yourcompany.A-Script-Bundle', 'enabled') "},"Handbook/xui/xui.set.html":{"url":"Handbook/xui/xui.set.html","title":"设置配置界面上的某个控件的值 (xui.set)","keywords":"","body":"设置配置界面上的某个控件的值 (xui.set) 声明 xui.set(配置分区, 配置键, 值) 参数及返回值 配置分区 文本型，配置界面中的配置分区（defaults）标识符 配置键 文本型，配置界面中的控件的配置键（key）标识符 值 任意类型，不同的控件类型可以设置不同的值 说明 这个函数在 1.2-10 版以上方可使用如果当前正显示着配置界面，则该函数会立刻更新界面上的显示值该函数不负责过滤值类型，如果需要保证值类型合法，可于设置后使用 xui.setup 来校验修正脚本配置界面标准参考 XUI 示例 xui.set('com.yourcompany.A-Script-Bundle', 'enabled', true) xui.setup('interface.xui') "},"Handbook/xui/xui.read.html":{"url":"Handbook/xui/xui.read.html","title":"读取某个配置分区所有配置 (xui.read)","keywords":"","body":"读取某个配置分区所有配置 (xui.read) 声明 配置 = xui.read(配置分区) 参数及返回值 配置分区 文本型，配置界面中的配置分区（defaults）标识符 配置 表型，这个配置分区所有配置的键值对，如果没有该配置分区，则返回空表 说明 这个函数在 1.2-10 版以上方可使用该函数用于优化读取多个配置该函数不负责过滤值类型，如果需要保证获取的值类型合法，可先使用 xui.setup 来校验修正再读取脚本配置界面标准参考 XUI 示例 xui.setup('interface.xui') local dict = xui.read('com.yourcompany.A-Script-Bundle') local enabled = dict['enabled'] "},"Handbook/xui/xui.write.html":{"url":"Handbook/xui/xui.write.html","title":"覆盖写入配置表到某个配置分区 (xui.write)","keywords":"","body":"覆盖写入配置表到某个配置分区 (xui.write) 声明 操作成败 = xui.write(配置分区, 配置) 参数及返回值 配置分区 文本型，配置界面中的配置分区（defaults）标识符 配置 表型，配置的键值对 说明 这个函数在 1.2-10 版以上方可使用该函数用于优化同时设置多项配置，如果当前正显示着配置界面，则该函数会立刻更新界面上的显示值该函数不负责过滤值类型，如果需要保证值类型合法，可于写入后使用 xui.setup 来校验修正脚本配置界面标准参考 XUI 示例 xui.setup('interface.xui') local dict = xui.read('com.yourcompany.A-Script-Bundle') dict['enabled'] = true xui.write('com.yourcompany.A-Script-Bundle', dict) xui.setup('interface.xui') "},"Handbook/xui/xui.clear.html":{"url":"Handbook/xui/xui.clear.html","title":"清除某个配置分区所有的配置 (xui.clear)","keywords":"","body":"清除某个配置分区所有的配置 (xui.clear) 声明 操作成败 = xui.clear(配置分区) 参数及返回值 配置分区 文本型，配置界面中的配置分区（defaults）标识符 说明 这个函数在 1.2-10 版以上方可使用该函数用于优化同时设置多项配置，如果当前正显示着配置界面，则该函数会立刻更新界面上的显示值可于清除后使用 xui.setup 再次生成配置界面的默认配置脚本配置界面标准参考 XUI 示例 xui.clear('com.yourcompany.A-Script-Bundle') xui.setup('interface.xui') "},"Handbook/ext-table/index.html":{"url":"Handbook/ext-table/index.html","title":"扩展 table 模块","keywords":"","body":"扩展 table 模块 前言 深拷贝一个表 (table.deep_copy) 深打印一个表 (table.deep_print) 从字符串加载一个表 (table.load_string) "},"Handbook/ext-table/START.html":{"url":"Handbook/ext-table/START.html","title":"前言","keywords":"","body":"前言 table 模块是 Lua 基础模块，XXTouch 在其基础上做了一些扩展。 "},"Handbook/ext-table/table.deep_copy.html":{"url":"Handbook/ext-table/table.deep_copy.html","title":"深拷贝一个表 (table.deep_copy)","keywords":"","body":"深拷贝一个表 (table.deep_copy) 声明 被复制的表 = table.deep_copy(一个表) 参数及返回值 一个表 表型，需要拷贝的表 被复制的表 表型，返回表的拷贝份 说明 迭代拷贝一个表到另外一个表，表中除 function 和 userdata 以外的所有值都会拷贝拷贝出来的表中如果有循环引用，那么引用关系也会获得拷贝 示例 local _g = table.deep_copy(_G) "},"Handbook/ext-table/table.deep_print.html":{"url":"Handbook/ext-table/table.deep_print.html","title":"深打印一个表 (table.deep_print)","keywords":"","body":"深打印一个表 (table.deep_print) 声明 表文本 = table.deep_print(关联表) 参数及返回值 关联表 表型，需要打印成字符串的表 表文本 文本型，返回表的树形结构的文本，这个文本不保证格式兼容 说明 将一个表的树形结构打印出来打印出来的结构不保证格式兼容，不同版本打印出来可能不一样非表型引用类型 (用户数据、函数) 不可通过 table.load_string 反序列，只保证人类可读性这个函数会将内容输出到 print 缓冲区 示例 local s = table.deep_print(_G) sys.alert(s) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/ext-table/table.load_string.html":{"url":"Handbook/ext-table/table.load_string.html","title":"从字符串加载一个表 (table.load_string)","keywords":"","body":"从字符串加载一个表 (table.load_string) 声明 关联表 = table.load_string(表文本) 参数及返回值 表文本 文本型，表的树形结构的文本，只能包含静态数据，不能包含任何动态代码 关联表 表型 或 nil，加载成功返回表结构，失败返回 nil 说明 这个函数在 1.1.2-6 版以上方可使用将一个树形结构文本描述转换成一个表对象一定意义上，table.load_string 是 table.deep_print 的反函数 (这取决有没有循环引用或非表引用类型)它与 load 的区别在于，它不会运行文本中的代码，只会使用静态数据例如以下示例包含奇怪代码，结果是 b 为 nil b = table.load_string[[ { a = os.execute('reboot'), -- 这里的代码将不会运行，并且会返回 nil } ]] 示例 local t = table.load_string[[ { a = 1, b = 2, c = 3, } ]] sys.alert(t.b) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/ext-string/index.html":{"url":"Handbook/ext-string/index.html","title":"扩展 string 模块","keywords":"","body":"扩展 string 模块 前言 转成 16 进制文本 (string.to_hex) 从 16 进制文本转回 (string.from_hex) 将 GBK 编码的文本转成 UTF-8 编码的文本 (string.from_gbk) 计算字符串的 md5 哈希值 (string.md5) 计算字符串的 sha1 哈希值 (string.sha1) 对字符串进行 base64 编码 (string.base64_encode) 对 base64 编码的文本进行解码 (string.base64_decode) 对字符串进行加密 (string.aes128_encrypt) 解密一段已加密的字符串 (string.aes128_decrypt) 用分隔符规则分割一个字符串 (string.split) 去除文本左边空白字符 (string.ltrim) 去除文本右边空白字符 (string.rtrim) 去除文本左右两边空白字符 (string.trim) 去除文本中所有的空白字符 (string.atrim) 去除掉文本前的 UTF8-BOM (string.strip_utf8_bom) 生成随机字符串 (string.random) 比较两个版本号大小 (string.compare_version) 扩展 string 示例代码 "},"Handbook/ext-string/START.html":{"url":"Handbook/ext-string/START.html","title":"前言","keywords":"","body":"前言 string 模块是 Lua 基础模块，XXTouch 在其基础上做了一些扩展。 "},"Handbook/ext-string/string.to_hex.html":{"url":"Handbook/ext-string/string.to_hex.html","title":"转成 16 进制文本 (string.to_hex)","keywords":"","body":"转成 16 进制文本 (string.to_hex) 声明 16进制文本 = string.to_hex(数据内容) 参数及返回值 数据内容 字符串型，需要转换成 16 进制的字符串 16进制文本 文本型，返回 16 进制文本 说明 将字符串 (或二进制数据块) 转换成可打印的 16 进制文本关键词：图片十六进制 十六进制图片 文件十六进制 十六进制文件 数据十六进制 十六进制数据 示例 -- 示例 1： sys.alert(string.to_hex('一些数据')) -- 输出 \"e4b880e4ba9be695b0e68dae\" -- -- 示例 2： sys.alert((string.to_hex('一些数据'):gsub('(..)', '\\\\x%1'))) -- 输出 \"\\xe4\\xb8\\x80\\xe4\\xba\\x9b\\xe6\\x95\\xb0\\xe6\\x8d\\xae\" 注：上述代码中使用了非本章函数 sys.alert 更多示例 本章最后 "},"Handbook/ext-string/string.from_hex.html":{"url":"Handbook/ext-string/string.from_hex.html","title":"从 16 进制文本转回 (string.from_hex)","keywords":"","body":"从 16 进制文本转回 (string.from_hex) 声明 数据内容 = string.from_hex(16进制文本) 参数及返回值 16进制文本 文本型，需要转换成字符串的 16 进制文本 数据内容 字符串型 或 nil，返回字符串，如果输入参数不是 16 进制文本，则返回 nil 说明 string.to_hex 的反函数，将可打印的 16 进制文本转换成字符串 (或二进制数据块) 示例 sys.alert(string.from_hex('e4b880e4ba9be695b0e68dae')) -- 输出 \"一些数据\" 注：上述代码中使用了非本章函数 sys.alert 更多示例 本章最后 "},"Handbook/ext-string/string.from_gbk.html":{"url":"Handbook/ext-string/string.from_gbk.html","title":"将 GBK 编码的文本转成 UTF-8 编码的文本 (string.from_gbk)","keywords":"","body":"将 GBK 编码的文本转成 UTF-8 编码的文本 (string.from_gbk) 声明 可以直接用的文本 = string.from_gbk(GBK编码的文本) 参数及返回值 GBK编码的文本 文本型，需要转换成 UTF-8 编码的 GBK 编码文本 可以直接用的文本 字符串型 或 nil，返回 UTF-8 编码的文本，如果编码错误导致转换无法完成，返回 nil 说明 将 GBK 编码的文本转成 UTF-8 编码的文本，转换返回乱码字符串可能是编码不正确，但是能完成编码对应转换，这不是函数的问题更复杂的编码转换需求请参考 luaiconv (编码转换库) 注：GBK 编码包含 GB2312 编码，所以如果需要 GB2312 编码的文本转换也是这个函数 示例 -- 中文编码 中文标准编码 国标扩展编码 GB2312 gbkstr = '\\x58\\x58\\x54\\x6f\\x75\\x63\\x68\\x20\\xba\\xdc\\xc7\\xbf' -- sys.alert(gbkstr) -- GBK 编码的字符串无法显示 sys.alert(string.from_gbk(gbkstr)) -- 输出 \"XXTouch 很强\" 注：上述代码中使用了非本章函数 sys.alert说明：在 Lua 源码中，字符串中 \\x 开头，后面跟两位 16 进制数表示以该数字编码的单个字节。例如：\\x58 表示 X 这个字符，可打印字符部分参考《ASCII 编码》 "},"Handbook/ext-string/string.md5.html":{"url":"Handbook/ext-string/string.md5.html","title":"计算字符串的 md5 哈希值 (string.md5)","keywords":"","body":"计算字符串的 md5 哈希值 (string.md5) 声明 哈希值 = string.md5(数据内容) 参数及返回值 数据内容 字符串型，原始字符串 哈希值 文本型，返回字符串的 md5 哈希值的 16 进制文本 说明 计算字符串 (或二进制数据块) 的 md5 校验值 示例 sys.alert(string.md5('XXTouch 真棒')) -- 输出 \"4921dbf380df452fa959dc47cef30e4b\" 注：上述代码中使用了非本章函数 sys.alert 更多示例 本章最后 "},"Handbook/ext-string/string.sha1.html":{"url":"Handbook/ext-string/string.sha1.html","title":"计算字符串的 sha1 哈希值 (string.sha1)","keywords":"","body":"计算字符串的 sha1 哈希值 (string.sha1) 声明 哈希值 = string.sha1(数据内容) 参数及返回值 数据内容 字符串型，原始字符串 哈希值 文本型，返回字符串的 sha1 哈希值的 16 进制文本 说明 计算字符串 (或二进制数据块) 的 sha1 校验值 示例 sys.alert(string.sha1('XXTouch 真棒')) -- 输出 \"a959c48d904c1075c7ddfdb1fda49effb2142493\" 注：上述代码中使用了非本章函数 sys.alert 更多示例 本章最后 "},"Handbook/ext-string/string.base64_encode.html":{"url":"Handbook/ext-string/string.base64_encode.html","title":"对字符串进行 base64 编码 (string.base64_encode)","keywords":"","body":"对字符串进行 base64 编码 (string.base64_encode) 声明 b64文本 = string.base64_encode(数据内容) 参数及返回值 数据内容 字符串型，原始字符串 b64文本 文本型，返回字符串的 base64 编码文本 说明 对字符串 (或二进制数据块) 进行 base64 编码关键词：图片Base64 Base64图片 文件Base64 Base64文件 数据Base64 Base64数据 二进制Base64 Base64二进制 示例 -- 取屏幕区域 png 格式数据进行 base64 编码 b64s = screen.image(0, 0, 100, 100):png_data():base64_encode() -- 读取文件数据并进行 base64 编码 b64s = file.reads('/var/mobile/1.png'):base64_encode() 注：上述代码中使用了非本章函数 screen.image、:png_data、file.reads 更多示例 本章最后 "},"Handbook/ext-string/string.base64_decode.html":{"url":"Handbook/ext-string/string.base64_decode.html","title":"对 base64 编码的文本进行解码 (string.base64_decode)","keywords":"","body":"对 base64 编码的文本进行解码 (string.base64_decode) 声明 数据内容 = string.base64_decode(b64文本) 参数及返回值 b64文本 文本型，base64 编码的文本 数据内容 字符串型，返回解码后的字符串 说明 string.base64_encode 的反函数，将 base64 编码的文本转换回字符串 (或二进制数据块) 示例 本章最后 "},"Handbook/ext-string/string.aes128_encrypt.html":{"url":"Handbook/ext-string/string.aes128_encrypt.html","title":"对字符串进行加密 (string.aes128_encrypt)","keywords":"","body":"对字符串进行加密 (string.aes128_encrypt) 声明 加密的数据 = string.aes128_encrypt(数据内容, 密钥) 参数及返回值 数据内容 字符串型，需要加密的字符串 密钥 字符串型，密码 加密的数据 字符串型，加密后的二进制数据块 说明 使用 AES128 算法 ECB 模式将字符串 (或二进制数据块) 加密注：AES128 算法 ECB 模式不存在 iv (偏移向量) 参数，如果对接开发中一定需要写，那么是 0 示例 本章最后 "},"Handbook/ext-string/string.aes128_decrypt.html":{"url":"Handbook/ext-string/string.aes128_decrypt.html","title":"解密一段已加密的字符串 (string.aes128_decrypt)","keywords":"","body":"解密一段已加密的字符串 (string.aes128_decrypt) 声明 数据内容 = string.aes128_decrypt(加密的数据, 密钥) 参数及返回值 加密的数据 字符串型，已经加密的字符串 密钥 字符串型，密码 数据内容 字符串型，解密之后的字符串 说明 使用 AES128 算法 ECB 模式将加密的字符串 (或二进制数据块) 解密注：AES128 算法 ECB 模式不存在 iv (偏移向量) 参数，如果对接开发中一定需要写，那么是 0 示例 本章最后 "},"Handbook/ext-string/string.split.html":{"url":"Handbook/ext-string/string.split.html","title":"用分隔符规则分割一个字符串 (string.split)","keywords":"","body":"用分隔符规则分割一个字符串 (string.split) 声明 分割好的文本数组 = string.split(待分割文本, 分隔符) 参数及返回值 待分割文本 文本型，需要分割的字符串 分隔符 文本型，分隔符 分割好的文本数组 表型，分割后的字符串片段按顺序排列于此表 说明 用分隔符规则分割一个字符串字符串分割 文本分割 字符串分割 文本切割 文本分段 示例 -- 示例 1 (分割账号密码) ： t = string.split('lfue6841214----123456', '----') sys.alert('账号是：'..t[1]) -- -- 示例 2 (取文本中间部分，两个 # 之间的文字) ： t = string.split('您好，验证码是#4937#，15分钟内有效。【爆炸科技】', '#') sys.alert('验证码是：'..t[2]) -- -- 示例 3 (复杂点的取文本中间部分) ： t = string.split('您好，验证码是4937，15分钟内有效。【爆炸科技】', '验证码是') t = string.split(t[2], '，15分钟') sys.alert('验证码是：'..t[1]) 注：上述代码中使用了非本章函数 sys.alert 封装示例 1 -- 取文本中间部分的封装 (找不到匹配返回 nil) function str_middle(str, sep1, sep2) assert(type(str) == 'string', '`str_middle` 第 #1 参数必须是字符串') assert(type(sep1) == 'string', '`str_middle` 第 #2 参数必须是字符串') assert(type(sep2) == 'nil' or type(sep2) == 'string', '`str_middle` 第 #3 参数可选，但必须是字符串') local t = string.split(str, sep1) if not sep2 or sep1==sep2 then return t[2] else if t[2] == nil then return nil else t = string.split(t[2], sep2) if t[2] == nil then return nil else return t[1] end end end end -- 以上封装可复制到脚本中用 -- r = str_middle('您好，验证码是4937，15分钟内有效。【爆炸科技】', '码是', '，15分') sys.alert('验证码是：'..r) -- 输出 \"验证码是：4937\" -- r = str_middle('您好，验证码是#8346#，15分钟内有效。【爆炸科技】', '#') sys.alert('验证码是：'..r) -- 输出 \"验证码是：8346\" 注：上述代码中使用了非本章函数 sys.alert 封装示例 2 -- 取绝对路径的文件名 function str_strip_dirname(path) local d = string.split(path, '/') return d[#d] end -- 取绝对路径的目录 function str_strip_filename(path) local d = string.split(path, '/') d[#d] = nil return table.concat(d, '/') end -- 剔除路径最后一部分的扩展名（后缀名） function str_strip_extension(path) local d = string.split(path, '/') local fnt = string.split(d[#d], '.') d[#d] = fnt[1] return table.concat(d, '/') end -- 获取路径最后一部分的扩展名（后缀名） function str_get_extension(path) local d = string.split(path, '/') local fnt = string.split(d[#d], '.') table.remove(fnt, 1) return table.concat(fnt, '.') end sys.alert(str_strip_dirname(\"/private/var/mobile/Media/1ferver/lua/scripts/1.lua.xxt\")) -- 输出 \"1.lua.xxt\" sys.alert(str_strip_filename(\"/private/var/mobile/Media/1ferver/lua/scripts/1.lua.xxt\")) -- 输出 \"/private/var/mobile/Media/1ferver/lua/scripts\" sys.alert(str_strip_extension(\"/private/var/mobile/Media/1ferver/lua/scripts/1.lua.xxt\")) -- 输出 \"/private/var/mobile/Media/1ferver/lua/scripts/1\" sys.alert(str_get_extension(\"/private/var/mobile/Media/1ferver/lua/scripts/1.lua.xxt\")) -- 输出 \"lua.xxt\" sys.alert(str_strip_extension(str_strip_dirname(\"/private/var/mobile/Media/1ferver/lua/scripts/1.lua.xxt\"))) -- 输出 \"1\" 注：上述代码中使用了非本章函数 sys.alert、table.concat 可能相关的示例 (将中英混合的文本爆开成一个个的字符，仅支持 UTF8 编码文本) -- 这不是使用 string.split 实现的例子 function text_explode(text) local ret = {} for p, c in utf8.codes(text) do ret[#ret + 1] = utf8.char(c) end return ret end -- local t = text_explode('你好，XXTouch') sys.alert(table.concat(t, '/')) -- 输出 \"你/好/，/X/X/T/o/u/c/h\" 注：上述代码中使用了非本章函数 sys.alert、table.concat、utf8.char、utf8.codes 更多示例 本章最后 "},"Handbook/ext-string/string.ltrim.html":{"url":"Handbook/ext-string/string.ltrim.html","title":"去除文本左边空白字符 (string.ltrim)","keywords":"","body":"去除文本左边空白字符 (string.ltrim) 声明 处理后文本 = string.ltrim(处理前文本) 参数及返回值 处理前文本 文本型，需要去除左边空白字符的文本 处理后文本 文本型，返回已经去除左边空白字符的文本 说明 去除文本左边空白字符空白字符包括 \"\\r\" \"\\n\" \"\\t\" 示例 本章最后 "},"Handbook/ext-string/string.rtrim.html":{"url":"Handbook/ext-string/string.rtrim.html","title":"去除文本右边空白字符 (string.rtrim)","keywords":"","body":"去除文本右边空白字符 (string.rtrim) 声明 处理后文本 = string.rtrim(处理前文本) 参数及返回值 处理前文本 文本型，需要去除右边空白字符的文本 处理后文本 文本型，返回已经去除右边空白字符的文本 说明 去除文本右边空白字符空白字符包括 \"\\r\" \"\\n\" \"\\t\" 示例 本章最后 "},"Handbook/ext-string/string.trim.html":{"url":"Handbook/ext-string/string.trim.html","title":"去除文本左右两边空白字符 (string.trim)","keywords":"","body":"去除文本左右两边空白字符 (string.trim) 声明 处理后文本 = string.trim(处理前文本) 参数及返回值 处理前文本 文本型，需要去除左右两边空白字符的文本 处理后文本 文本型，返回已经去除左右两边空白字符的文本 说明 去除文本左右两边空白字符空白字符包括 \"\\r\" \"\\n\" \"\\t\" 示例 本章最后 "},"Handbook/ext-string/string.atrim.html":{"url":"Handbook/ext-string/string.atrim.html","title":"去除文本中所有的空白字符 (string.atrim)","keywords":"","body":"去除文本中所有的空白字符 (string.atrim) 声明 处理后文本 = string.atrim(处理前文本) 参数及返回值 处理前文本 文本型，需要去除所有的空白字符的文本 处理后文本 文本型，返回已经去除所有的空白字符的文本 说明 去除文本所有的空白字符空白字符包括 \"\\r\" \"\\n\" \"\\t\" 示例 本章最后 "},"Handbook/ext-string/string.strip_utf8_bom.html":{"url":"Handbook/ext-string/string.strip_utf8_bom.html","title":"去除掉文本前的 UTF8-BOM (string.strip_utf8_bom)","keywords":"","body":"去除掉文本前的 UTF8-BOM (string.strip_utf8_bom) 声明 处理后文本 = string.strip_utf8_bom(处理前文本) 参数及返回值 处理前文本 文本型，需要剔除掉 UTF8-BOM 字符的文本 处理后文本 文本型，返回已经剔除掉 UTF8-BOM 字符的文本 说明 UTF8-BOM 的表现形式是文档开头的三个看不见的字符 \"\\xEF\\xBB\\xBF\" (在 Lua 源码中，字符串中 \\x 开头，后面跟两位 16 进制数表示以该数字编码的单个字节。例如：\\x58 表示 X 这个字符，可打印字符部分参考《ASCII 编码》)这个函数在 1.1.3-1 版以上方可使用 示例 txt = \"\\xEF\\xBB\\xBFXXTouch\" sys.alert(txt..', '..#txt) -- 输出 \"XXTouch, 10\" -- txt = string.strip_utf8_bom(txt) sys.alert(txt..', '..#txt) -- 输出 \"XXTouch, 7\" 注：上述代码中使用了非本章函数 sys.alert 小知识 UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯 (顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯) 。BOM (byte order mark) 是为 UTF-16 和 UTF-32 准备的，用于标记字节序 (byte order) 。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。 (百度搜索 UTF8-BOM 查看更多资料) "},"Handbook/ext-string/string.random.html":{"url":"Handbook/ext-string/string.random.html","title":"生成随机字符串 (string.random)","keywords":"","body":"生成随机字符串 (string.random) 声明 随机字符串 = string.random(字符池 [, 生成字符个数, 每字符的字节数 ]) 参数及返回值 字符池 文本型，需要生成字符串的字典 生成字符个数 整数型，可选参数，需要生成的随机字符串中的字符个数，默认 6 每字符的字节数 整数型，可选参数，每个字符的长度，默认 1 随机字符串 文本型，返回生成的随机字符串 说明 生成随机字符串，UTF-8 编码的中文每个字符的长度为 3 示例 rs = string.random(\"qwertyuiopasdfghjklzxcvbnm\", 20, 1) rs = string.random(\"一二三四五六七八九十\", 20, 3) "},"Handbook/ext-string/string.compare_version.html":{"url":"Handbook/ext-string/string.compare_version.html","title":"比较两个版本号大小 (string.compare_version)","keywords":"","body":"比较两个版本号大小 (string.compare_version) 声明 比较结果 = string.compare_version(版本号甲, 版本号乙) 参数及返回值 版本号甲, 版本号乙 文本型，需要比较大小的两个版本号 比较结果 整数型，版本号甲大于版本号乙返回 1，版本号甲小于版本号乙返回 -1，版本号相等返回 0 说明 比较两个版本号字符串大小，遵守如下比较规则使用点 (.) 或减号 (-) 或空格隔开的纯数字值不同分隔符效果相等，多个分隔符连在一起被认为是一个分隔符权值随分段从左至右逐步降低遇到任何非法字符将截断不对比后面的内容如果段数不等，则不够段数用 '0' 补齐对比空字符串或非法串会被认为版本号是 '0'例如 '1.1' 与 '1.1.0' 是相等的两个版本号例如 '1.1' 与 '1.1-0' 是相等的两个版本号例如 '1.1' 与 '1-1' 是相等的两个版本号例如 '1.0' 与 '1 0' (1 和 0 之间有个空格) 是相等的两个版本号例如 '1.0' 大于 '0.99999'这个函数在 1.2-3 版以上方可使用这个函数在 1.2-10 版以上可以在 XUI 中使用 示例 assert(string.compare_version(\"\", \"\") == 0) assert(string.compare_version(\"1\", \"\") == 1) assert(string.compare_version(\"\", \"1\") == -1) assert(string.compare_version(\"1\", \"1\") == 0) assert(string.compare_version(\"1.0\", \"1\") == 0) assert(string.compare_version(\"1\", \"1.0\") == 0) assert(string.compare_version(\"1.\", \"1\") == 0) assert(string.compare_version(\"1\", \"1.\") == 0) assert(string.compare_version(\"1.\", \"1.0\") == 0) assert(string.compare_version(\"1.0\", \"1.\") == 0) assert(string.compare_version(\"1.0\", \"1.0\") == 0) assert(string.compare_version(\"1.0.0\", \"1.0.0\") == 0) assert(string.compare_version(\"1.1\", \"1.0\") == 1) assert(string.compare_version(\"1.0\", \"1.1\") == -1) assert(string.compare_version(\"1.1\", \"1.10\") == -1) assert(string.compare_version(\"1.2\", \"1.11\") == -1) assert(string.compare_version(\"1.1\", \"1.1.1\") == -1) assert(string.compare_version(\"1.2\", \"1.1.1\") == 1) assert(string.compare_version(\"1.0\", \"0.99999\") == 1) assert(string.compare_version(\"1.10.1\", \"1.10\") == 1) assert(string.compare_version(\"1.2-4\", \"1.2-3\") == 1) assert(string.compare_version(\"1.2-3\", \"1.2.3\") == 0) assert(string.compare_version(\"1.2-4\", \"1.2.3.0\") == 1) assert(string.compare_version(\"1.2-4\", \"1.2.3.10\") == 1) assert(string.compare_version(\"1.2-4\", \"1.2.30.10\") == -1) assert(string.compare_version(\"1.2-3\", \"1.2.4\") == -1) assert(string.compare_version(\"2.2\", \"1.2\") == 1) assert(string.compare_version(\"2.2\", \"10.2\") == -1) assert(string.compare_version(\"2..2\", \"2.2\") == 0) assert(string.compare_version(\"2.2.x.3\", \"2.2\") == 0) assert(string.compare_version(\"x\", \"\") == 0) "},"Handbook/ext-string/samples.html":{"url":"Handbook/ext-string/samples.html","title":"扩展 string 示例代码","keywords":"","body":"扩展 string 示例代码 -- 哈希校验 local str = \"sozereal\" sys.alert('\"'..str..'\" 的 16 进制编码为: ') sys.alert(' 转换成明文为: \"'..str:to_hex():from_hex()..'\"') sys.alert('\"'..str..'\" 的 MD5 值是: '..str:md5()) sys.alert('\"'..str..'\" 的 SHA1 值是: '..str:sha1()) local binstr = \"\\0\\1\\2\\3\\4\\5\" sys.alert(' 的 MD5 值是: '..binstr:md5()) sys.alert(' 的 SHA1 值是: '..binstr:sha1()) -- -- 数据加/解密 local msg = \"\\5\\4\\3\\2\\1\\0\" local key = \"sozereal\" local emsg = msg:aes128_encrypt(key) local emsgb64 = emsg:base64_encode() sys.alert('二进制数据 \\n 使用 AES128 算法 密钥 \"'..key..'\" 加密 值是: \\n base64 串为 \"'..emsgb64..'\"') local tmp = emsgb64:base64_decode() msg = tmp:aes128_decrypt(key) sys.alert('\"'..emsgb64..'\" base64 解码后的数据为 \\n使用 AES128 算法 密钥 \"'..key..'\" 解密 值是: ') -- -- 字符串小工具 str = \" 哈哈,he he,1,3,6 \" new = str:split(\",\") --将字符串str按照 `,` 分割并返回一个表 sys.alert(new[2]) sys.alert(str:rtrim()) -- 结果 \" 哈哈,he he,1,3,6\" ,删除字符串尾部的空白字符 sys.alert(str:ltrim()) -- 结果 \"哈哈,he he,1,3,6 \" ,删除字符串首部的空白字符 sys.alert(str:trim()) -- 结果 \"哈哈,he he,1,3,6\" ,删除字符串首尾的空白字符 sys.alert(str:atrim()) -- 结果 \"哈哈,hehe,1,3,6\" ,删除字符串所有的空白字符 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/http/index.html":{"url":"Handbook/http/index.html","title":"! HTTP 模块","keywords":"","body":"! HTTP 模块 前言 发起 GET 请求 (http.get) 发起 POST 请求 (http.post) HTTP 文件下载 (http.download) 发起 HEAD 请求 (http.head) 发起 DELETE 请求 (http.delete) 发起 PUT 请求 (http.put) "},"Handbook/http/START.html":{"url":"Handbook/http/START.html","title":"前言","keywords":"","body":"前言 当前模块并不支持 HTTP/1.0 或更低版本的 HTTP 协议，需求若无法使用当前模块完成，也可以使用 lcurl 模块 来实现。 "},"Handbook/http/http.get.html":{"url":"Handbook/http/http.get.html","title":"发起 GET 请求 (http.get)","keywords":"","body":"发起 GET 请求 (http.get) 声明 HTTP状态码, 返回头JSON文本, 返回主体 = http.get(URL [, 超时秒, 请求头, URL不ESCAPE ]) 参数及返回值 URL 文本型，需要请求的 URL 地址，该方法默认会对 URL 进行百分号 escape 处理，如不需要可参考 URL不ESCAPE 参数说明 超时秒 实数型，可选参数，请求超时时间，单位秒，默认 2 *1.2-3 版以上默认超时改为 10 秒 请求头 表型，可选参数，发出的请求的头部信息，形式 {field1 = value1, field2 = value2, ...}，默认 {} URL不ESCAPE *1.1.3-1 新增 布尔型，可选参数，true 表示不对 URL 进行 escape 直接请求，默认 false 对 URL 进行自定义 escape 可参考 lcurl 模块 的 easy:escape、easy:unescape HTTP状态码 整数型，返回当次请求的 http 状态码，请求超时返回 -1 返回头JSON文本 文本型 或 nil，请求完成返回的 JSON 形式头部信息，请求超时返回 nil 返回主体 字符串型 或 nil，请求完成返回的内容，请求超时返回 nil 说明 使用 HTTP/1.1 协议的 GET 方法请求获取网络资源这个函数不会将资源存储到磁盘上，如果需要下载较大的网络资源，建议使用 http.download这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会若服务器协议版本为 HTTP/1.0 或 HTTP/0.9，可使用 返回主体 = httpGet(URL, 超时秒) 这个方法替代 示例 local code, res_headers, body = http.get(\"http://www.baidu.com\", 1, { [\"User-Agent\"] = \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)\"; -- 模拟 IE8 的请求 [\"Cookie\"] = \"大佬你会不会啊？\"; -- 顺带 Cookie 提交 }) if code == 200 then -- 如果返回的状态码是 HTTP_OK sys.alert(body) -- 输出百度首页的网页 HTML 内容 end 注：上述代码中使用了非本章函数 sys.alert 示例 -- 中文 URL 默认自动会 escape，包含中文的 URL 可直接像下面这样调用 local c, h, r = http.get(\"https://www.xxtouch.com/测试文本.txt\") if c==200 then -- 如果返回的状态码是 HTTP_OK sys.alert(r) -- 输出内容 end -- -- 1.1.3-1 新增 no_escape (URL不ESCAPE) 参数示例，下面的例子与上面例子等效 local c, h, r = http.get(\"https://www.xxtouch.com/%E6%B5%8B%E8%AF%95%E6%96%87%E6%9C%AC.txt\", 5, {}, true--[[这里]]) if c==200 then -- 如果返回的状态码是 HTTP_OK sys.alert(r) -- 输出内容 end 注：上述代码中使用了非本章函数 sys.alert http.get 封装获取外网IP实例 function get_ip() local done = false thread.dispatch(function() while (true) do if (done) then sys.toast(\"\", -1) return else sys.toast(\"正在获取 IP 地址...\", device.front_orien()) end sys.msleep(2000) end end) while (true) do local c, h, b = http.get(\"http://ip.chinaz.com/getip.aspx?ts=\"..tostring(sys.rnd()), 60) if (c==200) then sys.toast(\"\", -1) done = true return b:match('%d+%.%d+%.%d+%.%d+') end end end -- -- 将以上代码拷贝到自己的脚本最前面，然后在脚本中使用 sys.alert(get_ip()) 注：上述代码中使用了非本章函数 sys.alert、sys.toast、sys.msleep、sys.rnd、thread.dispatch、device.front_orien http.get 根据当前网络获取 GPS 位置及城市名称实例 转至论坛：https://club.xxtouch.com/forum.php?mod=viewthread&tid=247 "},"Handbook/http/http.post.html":{"url":"Handbook/http/http.post.html","title":"发起 POST 请求 (http.post)","keywords":"","body":"发起 POST 请求 (http.post) 声明 HTTP状态码, 返回头JSON文本, 返回主体 = http.post(URL [, 超时秒, 请求头, 请求主体, URL不ESCAPE ]) 参数及返回值 URL 文本型，需要请求的 URL 地址，该方法默认会对 URL 进行 escape 处理，如不需要可参考 URL不ESCAPE 参数说明 超时秒 实数型，可选参数，请求超时时间，单位秒，默认 2 *1.2-3 版以上默认超时改为 10 秒 请求头 表型，可选参数，发出的请求的头部信息，形式 {field1 = value1, field2 = value2, ...}，默认 {} 请求主体 字符串型，可选参数，使用 post 发送出去的内容，默认是空字符串 URL不ESCAPE *1.1.3-1 新增 布尔型，可选参数，true 表示不对 URL 进行 escape 直接请求，默认 false 对 URL 进行自定义 escape 可参考 lcurl 模块 的 easy:escape、easy:unescape HTTP状态码 整数型，返回当次请求的 http 状态码，请求超时返回 -1 返回头JSON文本 文本型 或 nil，请求完成返回的 JSON 形式头部信息，请求超时返回 nil 返回主体 字符串型 或 nil，请求完成返回的内容，请求超时返回 nil 说明 使用 HTTP/1.1 协议的 POST 方法发送数据到网络中这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会若服务器协议版本为 HTTP/1.0 或 HTTP/0.9，可使用 返回主体 = httpPost(URL, 请求主体, 超时秒) 这个方法替代 示例 local code, res_headers, body = http.post(\"http://www.baidu.com\", 1, { [\"User-Agent\"] = \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)\", -- 模拟 IE8 的请求 [\"Cookie\"] = \"大佬你会不会啊？\"; -- 顺带 Cookie 提交 }, \"需要发送过去的数据\") if code == 200 then -- 如果返回的状态码是 HTTP_OK sys.alert(body) -- 输出百度首页的网页 HTML 内容 end 注：上述代码中使用了非本章函数 sys.alert POST 提交表单示例 local c, h, r = http.post('http://httpbin.org/post', 60, {}, 'name=havonz&qq=1004695100&wechat=havonz') if (c == 200) then sys.alert(r, 0, '提交成功') else if (c == -1) then sys.alert('请求失败，请检查网络连接', 0, '连接超时') else sys.alert('错误代码 #'..c..'\\n'..r, 0, 'HTTP 错误') end end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/http/http.download.html":{"url":"Handbook/http/http.download.html","title":"HTTP 文件下载 (http.download)","keywords":"","body":"HTTP 文件下载 (http.download) 声明 下载成败, 下载信息 = http.download(URL, 本地文件路径 [, 连接超时秒, 断点续传模式, 分块回调函数, 缓冲区尺寸 ]) 参数及返回值 URL 文本型，远端文件地址 本地文件路径 文本型，需要保存到的本地路径 连接超时秒 实数型，可选参数，连接超时时间，单位秒，默认 10 断点续传模式 布尔型，可选参数，是否需要支持断点续传，是为 true，否为 false，默认 false 分块回调函数 函数型 可选参数，分块回调函数，每下载完一个分块都会回调一次这个函数，默认 空函数 分块回调函数第一个参数为当前下载的信息，回调函数返回 true 则打断这次下载 缓冲区尺寸 整数型，可选参数，缓冲区大小字节数，默认自动最优配置 下载成败 布尔型，连接是否成功 下载信息 表型 或 文本型，如果连接成功则返回表型下载信息，否则返回连接失败原因文本描述 说明 -- 第二个返回值下载信息结构如下 { resource_size = 远端资源总字节数, start_pos = 本次下载从资源的开始的位置, size_download = 本次下载的字节数, speed_download = 本次下载的速度 (单位：字节/秒) , } 这个函数适合大文件下载，在传输的过程中停止脚本可能会缓慢这个函数在 1.1.0-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 简单示例 local done, info = http.download(\"http://192.168.31.13/1.zip\", \"/var/mobile/1.zip\") if (done) then sys.alert(\"如果没有意外，已经下载好了\") else sys.alert(\"连接失败：\"..info) end 复杂示例 local done, info = http.download(\"http://192.168.31.13/1.zip\", \"/var/mobile/1.zip\", 10, true, function(binfo) local percent = math.floor(((binfo.start_pos + binfo.size_download) / binfo.resource_size) * 100) sys.toast(\"下载进度 \"..percent..\"%\") end, 4096 * 1024) -- if (done) then if (info.start_pos + info.size_download 注：上述代码中使用了非本章函数 sys.alert、sys.toast 错误信息参考 Requested range was not delivered by the server 这个错误表示服务器可能不支持断点续传，将断点续传选项设为 false 即可 "},"Handbook/http/http.head.html":{"url":"Handbook/http/http.head.html","title":"发起 HEAD 请求 (http.head)","keywords":"","body":"发起 HEAD 请求 (http.head) 声明 HTTP状态码, 返回头JSON文本 = http.head(URL [, 超时秒, 请求头, URL不ESCAPE ]) 参数及返回值 URL 文本型，需要请求的 URL 地址，该方法默认会对 URL 进行 escape 处理，如不需要可参考 URL不ESCAPE 参数说明 超时秒 实数型，可选参数，请求超时时间，单位秒，默认 2 *1.2-3 版以上默认超时改为 10 秒 请求头 表型，可选参数，发出的请求的头部信息，形式 {field1 = value1, field2 = value2, ...}，默认 {} URL不ESCAPE *1.1.3-1 新增 布尔型，可选参数，true 表示不对 URL 进行 escape 直接请求，默认 false 对 URL 进行自定义 escape 可参考 lcurl 模块 的 easy:escape、easy:unescape HTTP状态码 整数型，返回当次请求的 http 状态码，请求超时返回 -1 返回头JSON文本 文本型 或 nil，请求完成返回的 JSON 形式头部信息，请求超时返回 nil 说明 使用 HTTP/1.1 协议的 HEAD 方法请求获取网络资源的头部信息HEAD 协议通常和 GET 请求会获得同样的返回头，但 HEAD 请求不会返回实际主体内容这个函数在 1.1.1-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 示例 local c, h = http.head(\"https://www.xxtouch.com/测试文本.txt\") if c==200 then -- 如果返回的状态码是 HTTP_OK sys.alert(h) -- 输出请求到的头信息 end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/http/http.delete.html":{"url":"Handbook/http/http.delete.html","title":"发起 DELETE 请求 (http.delete)","keywords":"","body":"发起 DELETE 请求 (http.delete) 声明 HTTP状态码, 返回头JSON文本, 返回主体 = http.delete(URL [, 超时秒, 请求头, URL不ESCAPE ]) 参数及返回值 URL 文本型，需要请求的 URL 地址，该方法默认会对 URL 进行 escape 处理，如不需要可参考 URL不ESCAPE 参数说明 超时秒 实数型，可选参数，请求超时时间，单位秒，默认 2 *1.2-3 版以上默认超时改为 10 秒 请求头 表型，可选参数，发出的请求的头部信息，形式 {field1 = value1, field2 = value2, ...}，默认 {} URL不ESCAPE *1.1.3-1 新增 布尔型，可选参数，true 表示不对 URL 进行 escape 直接请求，默认 false 对 URL 进行自定义 escape 可参考 lcurl 模块 的 easy:escape、easy:unescape HTTP状态码 整数型，返回当次请求的 http 状态码，请求超时返回 -1 返回头JSON文本 文本型 或 nil，请求完成返回的 JSON 形式头部信息，请求超时返回 nil 返回主体 字符串型 或 nil，请求完成返回的内容，请求超时返回 nil 说明 使用 HTTP/1.1 协议的 DELETE 方法请求获取网络资源，它通常用于删除一个网络资源，该协议一般会有权限验证这个函数在 1.1.1-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 示例 local c, h, r = http.delete(\"https://www.xxtouch.com/测试文本.txt\") if c==200 then -- 如果返回的状态码是 HTTP_OK sys.alert(r) -- 输出结果 end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/http/http.put.html":{"url":"Handbook/http/http.put.html","title":"发起 PUT 请求 (http.put)","keywords":"","body":"发起 PUT 请求 (http.put) 声明 HTTP状态码, 返回头JSON文本, 返回主体 = http.put(URL [, 超时秒, 请求头, 请求主体, URL不ESCAPE ]) 参数及返回值 URL 文本型，需要请求的 URL 地址，该方法默认会对 URL 进行 escape 处理，如不需要可参考 URL不ESCAPE 参数说明 超时秒 实数型，可选参数，请求超时时间，单位秒，默认 2 *1.2-3 版以上默认超时改为 10 秒 请求头 表型，可选参数，发出的请求的头部信息，形式 {field1 = value1, field2 = value2, ...}，默认 {} 请求主体 字符串型，可选参数，使用 put 发送出去的内容，默认是空字符串 URL不ESCAPE *1.1.3-1 新增 布尔型，可选参数，true 表示不对 URL 进行 escape 直接请求，默认 false 对 URL 进行自定义 escape 可参考 lcurl 模块 的 easy:escape、easy:unescape HTTP状态码 整数型，返回当次请求的 http 状态码，请求超时返回 -1 返回头JSON文本 文本型 或 nil，请求完成返回的 JSON 形式头部信息，请求超时返回 nil 返回主体 字符串型 或 nil，请求完成返回的内容，请求超时返回 nil 说明 使用 HTTP/1.1 协议的 PUT 方法发送数据到网络中，它与 POST 用法一致这个函数在 1.1.1-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 示例 local code, res_headers, body = http.put(\"http://www.baidu.com\", 1, { [\"User-Agent\"] = \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)\", -- 模拟 IE8 的请求 [\"Cookie\"] = \"大佬你会不会啊？\"; -- 顺带 Cookie 提交 }, \"需要发送过去的数据\") if code==200 then -- 如果返回的状态码是 HTTP_OK sys.alert(body) -- 输出百度首页的网页html end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/ftp/index.html":{"url":"Handbook/ftp/index.html","title":"! FTP 模块","keywords":"","body":"! FTP 模块 FTP 文件下载 (ftp.download) FTP 文件上传 (ftp.upload) "},"Handbook/ftp/ftp.download.html":{"url":"Handbook/ftp/ftp.download.html","title":"FTP 文件下载 (ftp.download)","keywords":"","body":"FTP 文件下载 (ftp.download) 声明 下载成败, 下载信息 = ftp.download(URL, 本地文件路径 [, 连接超时秒, 断点续传模式, 分块回调函数, 缓冲区尺寸 ]) 参数及返回值 URL 文本型，远端文件地址，账号及密码被包含在这一参数中 本地文件路径 文本型，需要保存到的本地路径 连接超时秒 实数型，可选参数，连接超时时间，单位秒，默认 10 断点续传模式 布尔型，可选参数，是否需要支持断点续传，是为 true，否为 false，默认 false 分块回调函数 函数型 可选参数，分块回调函数，每下载完一个分块都会回调一次这个函数，默认 空函数 分块回调函数第一个参数为当前下载的信息，回调函数返回 true 则打断这次下载 缓冲区尺寸 整数型，可选参数，缓冲区大小字节数，默认自动最优配置 下载成败 布尔型，连接是否成功 下载信息 表型 或 文本型，如果连接成功则返回表型下载信息，否则返回连接失败原因文本描述 说明 -- 第二个返回值下载信息结构如下 { resource_size = 远端资源总字节数, start_pos = 本次下载从资源的开始的位置, size_download = 本次下载的字节数, speed_download = 本次下载的速度 (单位：字节/秒) , } 这个函数适合大文件下载，在传输的过程中停止脚本可能会缓慢这个函数在 1.1.0-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 简单示例 账号密码写在 URL 中，具体 URL 格式如下 (中括号内是可选参数) ftp://[账号:密码@]地址[:端口]/路径 账号或密码中包含 @、:、/ 这三个字符可分别用 %40、%3A、%2F (若还有其它 URL 中不能包含的字符可使用 URLEncode 进行编码) 例如账号是 havonz 密码是 11@@22 参考下例 local done, info = ftp.download(\"ftp://havonz:11%40%4022@192.168.31.13/1.zip\", \"/var/mobile/1.zip\") if (done) then sys.alert(\"如果没有意外，已经下载好了\") else sys.alert(\"连接失败：\"..info) end 复杂示例 local done, info = ftp.download(\"ftp://havonz:123456@192.168.31.13/1.zip\", \"/var/mobile/1.zip\", 10, true, function(binfo) local percent = math.floor(((binfo.start_pos + binfo.size_download) / binfo.resource_size) * 100) sys.toast(\"下载进度 \"..percent..\"%\") end, 4096 * 1024) -- if (done) then if (info.start_pos + info.size_download 注：上述代码中使用了非本章函数 sys.alert、sys.toast "},"Handbook/ftp/ftp.upload.html":{"url":"Handbook/ftp/ftp.upload.html","title":"FTP 文件上传 (ftp.upload)","keywords":"","body":"FTP 文件上传 (ftp.upload) 声明 上传成败, 上传信息 = ftp.upload(本地文件路径, URL [, 连接超时秒, 断点续传模式, 分块回调函数, 缓冲区尺寸 ]) 参数及返回值 本地文件路径 文本型，本地文件路径 URL 文本型，需要上传到的远端地址，账号及密码被包含在这一参数中 连接超时秒 实数型，可选参数，连接超时时间，单位秒，默认 10 断点续传模式 布尔型，可选参数，是否需要支持断点续传，是为 true，否为 false，默认 false 分块回调函数 函数型 可选参数，分块回调函数，每上传完一个分块都会回调一次这个函数，默认 空函数 分块回调函数第一个参数为当前上传的信息，回调函数返回 true 则打断这次上传 缓冲区尺寸 整数型，可选参数，缓冲区大小字节数，默认自动最优配置 上传成败 布尔型，连接是否成功 上传信息 表型 或 文本型，如果连接成功则返回表型上传信息，否则返回连接失败原因文本描述 说明 -- 第二个返回值下载信息结构如下 { resource_size = 本地文件总字节数, start_pos = 本次上传从本地文件的开始的位置, size_upload = 本次上传的字节数, speed_upload = 本次上传的速度 (单位：字节/秒) , } 这个函数适合大文件上传，在传输的过程中停止脚本可能会缓慢这个函数在 1.1.0-1 版以上方可使用这个函数可能会让出，在这个函数返回之前，其它的 线程 可能会得到运行机会 简单示例 账号密码写在 URL 中，具体 URL 格式如下 (中括号内是可选参数) ftp://[账号:密码@]地址[:端口]/路径 账号或密码中包含 @、:、/ 这三个字符可分别用 %40、%3A、%2F (若还有其它 URL 中不能包含的字符可使用 URLEncode 进行编码) 例如账号是 havonz 密码是 11@@22 参考下例 local done, info = ftp.upload(\"/var/mobile/1.zip\", \"ftp://havonz:11%40%4022@192.168.31.13/1.zip\") if (done) then sys.alert(\"如果没有意外，已经上传好了\") else sys.alert(\"连接失败：\"..info) end 复杂示例 local done, info = ftp.upload(\"/var/mobile/1.zip\", \"ftp://havonz:123456@192.168.31.13/1.zip\", 10, true, function(binfo) local percent = math.floor(((binfo.start_pos + binfo.size_upload) / binfo.resource_size) * 100) sys.toast(\"上传进度 \"..percent..\"%\") end, 4096 * 1024) -- if (done) then if (info.start_pos + info.size_upload 注：上述代码中使用了非本章函数 sys.alert、sys.toast "},"Handbook/json/index.html":{"url":"Handbook/json/index.html","title":"JSON 模块","keywords":"","body":"JSON 模块 前言 将 Lua 值转成 JSON 字符串 (json.encode) 将 JSON 字符串转换成 Lua 值 (json.decode) JSON 中的 NULL 常量 (json.null) "},"Handbook/json/START.html":{"url":"Handbook/json/START.html","title":"前言","keywords":"","body":"前言 JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。详情见：http://www.json.org/ 该 JSON 模块 完全等同于 LuaCJSON 扩展库，非原创模块 "},"Handbook/json/json.encode.html":{"url":"Handbook/json/json.encode.html","title":"将 Lua 值转成 JSON 字符串 (json.encode)","keywords":"","body":"将 Lua 值转成 JSON 字符串 (json.encode) 声明 JSON文本, 错误信息 = json.encode(值) 参数及返回值 值 表型 或 文本型 或 数值型 或 布尔型 或 json.null，需要转换成 json 文本的 lua 值 JSON文本 文本型 或 nil，转换成功则返回一个 json 字符串，否则返回 nil 错误信息 文本型 或 nil， 转换失败 JSON文本 的值为 nil 的情况下，这个返回值则是具体的错误信息 说明 将 lua 中的数据值转成 json 形式可以方便与其它语言交互传输注意 不是任何 lua 值都可以转成 json。例如：用户数据或函数及包含用户数据或函数的表这个函数可以在 XUI 中使用 示例 local tb = { [\"膜\"] = \"图样图森破桑叹斯乃衣服\", [\"蛤\"] = \"比你们高到不知道哪里去了\", moha = { 1,0,0,4,6,9,5,1,0,0, }, nullvalue = json.null, } local jsonstr = json.encode(tb) sys.alert(jsonstr) -- local tmp = json.decode(jsonstr) sys.alert(tmp.moha[5]) sys.alert(tostring(tmp.nullvalue)) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/json/json.decode.html":{"url":"Handbook/json/json.decode.html","title":"将 JSON 字符串转换成 Lua 值 (json.decode)","keywords":"","body":"将 JSON 字符串转换成 Lua 值 (json.decode) 声明 值, 错误信息 = json.decode(JSON文本) 参数及返回值 JSON文本 文本型，需要转换成表的 json 文本 值 表型 或 文本型 或 数值型 或 布尔型 或 json.null 或 nil，转换成功则返回一个与 json 字符串结构相对应的 lua 值，否则返回 nil 错误信息 文本型 或 nil， 转换失败 值 为 nil 的情况下，这个返回值则是具体的错误信息 说明 将 json 文本转换成 lua 的中对应的数据值这个函数可以在 XUI 中使用 示例 print(json.decode('true')) print(json.decode('17')) print(json.decode('\"哈哈\"')) print(json.decode('null')) print(json.decode('')) table.deep_print(json.decode('{}')) table.deep_print(json.decode('{\"娘子\":\"啊哈\",\"你好\":\"世界\"}')) table.deep_print(json.decode('[]')) table.deep_print(json.decode('[1, 0, 0, \"4695100\"]')) -- sys.alert(print.out()) 注：上述代码中使用了非本章函数 table.deep_print 、print.out、sys.alert -- 使用 json.decode 转换 Unicode 编码为文字 sys.alert(json.decode([[\"\\u82cf\\u6cfd\"]])) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/json/json.null.html":{"url":"Handbook/json/json.null.html","title":"JSON 中的 NULL 常量 (json.null)","keywords":"","body":"JSON 中的 NULL 常量 (json.null) 声明 json.null 说明 这不是一个函数，是一个常量。以文本形式打印为 “userdata: 0x0”它用于表示 json 中对应的 null 值为什么它有必要存在 因为 lua table 中的 nil 会被判定为不存在，转换成 json 之后，key 会消失，所以需要一个特定的值来表示这个 null这个值可以在 XUI 中使用 示例 local tb = json.decode('{\"nullvalue\":null}') if tb['nullvalue'] == json.null then sys.alert(json.null) end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/plist/index.html":{"url":"Handbook/plist/index.html","title":"PLIST 文件读写模块","keywords":"","body":"PLIST 文件读写模块 读取 plist 文件 (plist.read) 写入 plist 文件 (plist.write) 读取属性表数据 (plist.load) 取 Lua 表的属性表数据 (plist.dump) "},"Handbook/plist/plist.read.html":{"url":"Handbook/plist/plist.read.html","title":"读取 plist 文件 (plist.read)","keywords":"","body":"读取 plist 文件 (plist.read) 声明 plist = require(\"plist\") -- 需要先引入 plist 模块 关联表 = plist.read(文件路径) 参数及返回值 文件路径 文本型，需要读取的 plist 文件的绝对路径 关联表 表型 或 nil，读取成功则返回 plist 的树形结构对应的一个表，否则返回 nil 说明 读取 plist 文件转换成表plist 文件中的非通用数据类型值不支持读取，会被忽略这个函数可以在 XUI 中使用 示例 local plist = require(\"plist\") local plfilename = \"/var/mobile/Library/Caches/com.apple.mobile.installation.plist\" --设置plist路径 local tmp2 = plist.read(plfilename) --读取plist文件内容并返回一个TABLE sys.alert(tmp2['Metadata']['ProductBuildVersion']) --显示ProductBuildVersion的键值 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/plist/plist.write.html":{"url":"Handbook/plist/plist.write.html","title":"写入 plist 文件 (plist.write)","keywords":"","body":"写入 plist 文件 (plist.write) 声明 plist = require(\"plist\") -- 需要先引入 plist 模块 plist.write(文件路径, 关联表) 参数及返回值 文件路径 文本型，需要写入的 plist 文件的绝对路径 关联表 表型，这个表的树形结构将会转换成 plist 说明 将一个表的树形结构写入到 plist 文件中请注意不要传入有引用环的表，会导致脚本无法终止甚至卡死使用该函数操作文件会导致文件所有者变 root，如果需要更改用户级应用的 plist 需要在修改后将权限修正方可生效这个函数可以在 XUI 中使用 示例 local plist = require(\"plist\") local plfilename = \"/var/mobile/Library/Caches/com.apple.mobile.installation.plist\" --设置plist路径 local tmp2 = plist.read(plfilename) --读取plist文件内容并返回一个TABLE tmp2[\"Metadata\"][\"ProductBuildVersion\"] = \"havonz\" --将表中ProductBuildVersion键值改为havonz plist.write(plfilename, tmp2) --将修改后的表写入PLIST文件 os.execute(\"chown mobile:mobile \"..plfilename) -- 修正文件权限 os.execute(\"chmod 644 \"..plfilename) "},"Handbook/plist/plist.load.html":{"url":"Handbook/plist/plist.load.html","title":"读取属性表数据 (plist.load)","keywords":"","body":"读取属性表数据 (plist.load) 声明 关联表 = plist.load(属性表数据) 参数及返回值 属性表数据 字符串型，需要读取的属性表数据 关联表 表型 或 nil，加载成功则返回属性表数据的树形结构对应的一个表，否则返回 nil 说明 plist.dump 的反函数，将属性表数据转换成表非通用数据类型值不支持读取，会被忽略这个函数在 1.2-3 版以上方可使用 示例 -- 示例 1 local jtmp = plist.load([[ { arr = ( 46, 99, 7, ); dict = { a = 55; b = 65; c = 9; }; } ]]) sys.alert(jtmp.arr[1]) -- 输出 46 sys.alert(jtmp.dict.c) -- 输出 9 -- -- 示例 2 local xtmp = plist.load([[ arr 46 99 7 dict a 55 b 65 c 9 ]]) sys.alert(xtmp.arr[1]) -- 输出 46 sys.alert(xtmp.dict.c) -- 输出 9 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/plist/plist.dump.html":{"url":"Handbook/plist/plist.dump.html","title":"取 Lua 表的属性表数据 (plist.dump)","keywords":"","body":"取 Lua 表的属性表数据 (plist.dump) 声明 属性表数据 = plist.dump(关联表[, 属性表数据格式]) 参数及返回值 关联表 表型，需要转换成属性表数据的 Lua 表 属性表数据格式 文本型，可选参数，只能是 \"binary\" 或者 \"XML\"，以及 1.2-10 版新增 \"openstep\"，默认为 \"XML\" 属性表数据 字符串型 或 nil，转换成功返回数据内容，转换失败返回 nil 说明 plist.load 的反函数，将表转换成属性表数据这个函数在 1.2-3 版以上方可使用 示例 local tab = { arr = { 46, 99, 7, }; dict = { a = 55; b = 65; c = 9; }; } -- local xplist = plist.dump(tab) sys.alert(xplist) -- 输出 XML 格式的属性表数据 -- local bplist = plist.dump(tab, \"binary\") sys.alert(bplist) -- 二进制格式的属性表数据，打印出来会乱码 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/utils/index.html":{"url":"Handbook/utils/index.html","title":"小工具模块","keywords":"","body":"小工具模块 给通讯录添加一个或多个联系人 (utils.add_contacts) 删除通讯录所有联系人 (utils.remove_all_contacts) 打开扫码器 (utils.open_code_scanner) 关闭扫码器 (utils.close_code_scanner) 将文本编码成二维码图片 (utils.qr_encode) 获得当前脚本的启动参数 (utils.launch_args) 判断当前脚本是否从 App 内启动 (utils.is_launch_via_app) 导入一个视频文件到相册 (utils.video_to_album) "},"Handbook/utils/utils.add_contacts.html":{"url":"Handbook/utils/utils.add_contacts.html","title":"给通讯录添加一个或多个联系人 (utils.add_contacts)","keywords":"","body":"给通讯录添加一个或多个联系人 (utils.add_contacts) 声明 success = utils.add_contacts({ { firstName = \"姓1\", lastName = \"名1\", phoneNumbers = { \"联系人1号码1\", \"联系人1号码2\", }, emails = { \"联系人1邮箱1\", \"联系人1邮箱2\", }, }, { firstName = \"姓2\", lastName = \"名2\", phoneNumbers = { \"联系人2号码1\", \"联系人2号码2\", }, emails = { \"联系人2邮箱1\", \"联系人2邮箱2\", }, }, ... }) 参数及返回值 firstName 文本型，联系人姓 lastName 文本型，联系人名 phoneNumbers 表型，这个人的号码列表 emails 表型，这个人的邮箱号列表 success 布尔型，添加成功返回 true，失败返回 false 说明 将一个或多个联系人记录添加到系统通讯录注意：大批量导入很慢，特大批量导入会导致注销 示例 utils.add_contacts({ { firstName = \"小\", lastName = \"明\", phoneNumbers = { \"13800001111\", \"13800002222\", }, emails = { \"xiaoming@qq.com\", \"xiaoming@163.com\", }, }, { firstName = \"小\", lastName = \"红\", phoneNumbers = { \"13800003333\", \"13800004444\", }, emails = { \"xiaohong@qq.com\", \"xiaohong@163.com\", }, }, }) "},"Handbook/utils/utils.remove_all_contacts.html":{"url":"Handbook/utils/utils.remove_all_contacts.html","title":"删除通讯录所有联系人 (utils.remove_all_contacts)","keywords":"","body":"删除通讯录所有联系人 (utils.remove_all_contacts) 声明 操作成败 = utils.remove_all_contacts() 参数及返回值 操作成败 布尔型，删除成功返回 true，失败返回 false 说明 删除通讯录所有联系人联系人很多的时候会需要消耗一些时间 示例 utils.remove_all_contacts() "},"Handbook/utils/utils.open_code_scanner.html":{"url":"Handbook/utils/utils.open_code_scanner.html","title":"打开扫码器 (utils.open_code_scanner)","keywords":"","body":"打开扫码器 (utils.open_code_scanner) 声明 打开成败 = utils.open_code_scanner() 参数及返回值 打开成败 布尔型，相机打开成功会返回 true，否则返回 false 说明 iOS 9 以上的 iPad 无法开启扫码器打开条码/二维码扫描器，会启动相机，与所有需要用到摄像头的应用不能同时使用这个函数调用不会返回扫描的结果扫描器的结果将通过 系统消息 xxtouch.scan_code_callback 传回 示例 扫码消息回调示例 -- 简易二维码扫描器演示 -- proc_queue_clear(\"xxtouch.scan_code_callback\") -- 清空消息队列 local success = utils.open_code_scanner() -- 打开扫码相机 if not success then sys.alert(\"可以于 “设置-通用-访问限制” 中取消 “相机” 的访问限制\", 0, \"无法访问系统相机\") return end -- local w, h = screen.size() webview.show({ -- 屏幕上方创建一个半透明的条 html = [[ 二维码置入镜头范围 ]], x = 0, y = 0, width = w, height = 100, alpha = 0.2, opaque = false, animation_duration = 0.2, }) -- while (true) do -- 循环等待消息 local ret = proc_queue_pop(\"xxtouch.scan_code_callback\") if (ret ~= \"\") then local rt = json.decode(ret) if (rt.type == \"org.iso.QRCode\") then utils.close_code_scanner() webview.show({ x = 0, y = 0, width = 0, height = 0, animation_duration = 0.2, opaque = false, }) local choice = sys.alert(rt.string, 0, \"扫描到二维码内容\", \"取消\", \"拷贝\", \"转存相册\") if (choice == 1) then pasteboard.write(rt.string) elseif (choice == 2) then utils.qr_encode(rt.string, { size = 320, fill_color = 0xff409bff, shadow_color = 0xff308bef, }):save_to_album() sys.alert(\"已经保存到相册\") end break else sys.toast( \"扫描到条码：\"..rt.type..\"\\n\".. \"条码内容为：\"..rt.string ) end end sys.msleep(10) end 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、proc_queue_clear、proc_queue_pop、json.decode、:save_to_album、 pasteboard.write、webview.show、screen.size "},"Handbook/utils/utils.close_code_scanner.html":{"url":"Handbook/utils/utils.close_code_scanner.html","title":"关闭扫码器 (utils.close_code_scanner)","keywords":"","body":"关闭扫码器 (utils.close_code_scanner) 声明 utils.close_code_scanner() 说明 关闭条码/二维码扫描器 示例 utils.open_code_scanner 示例 "},"Handbook/utils/utils.qr_encode.html":{"url":"Handbook/utils/utils.qr_encode.html","title":"将文本编码成二维码图片 (utils.qr_encode)","keywords":"","body":"将文本编码成二维码图片 (utils.qr_encode) 声明 图像 = utils.qr_encode(文本内容[, { size = 尺寸, fill_color = 填充颜色, shadow_color = 阴影颜色, }]) 参数及返回值 文本内容 文本型，需要编码成二维码的文本内容 size 整数型，需要编码成二维码的边长，默认 320 fill_color 整数型，填充二维码图像的颜色，默认 0xff000000 (黑色不透明) shadow_color 整数型，二维码阴影，默认 0x00000000 (完全透明) 图像 图片对象，返回生成的二维码图片对象 说明 将文本编码成一个指定尺寸背景色透明的二维码图片 示例 utils.open_code_scanner 示例 生成一个尺寸为 320 蓝色的二维码存到相册 local img = utils.qr_encode(\"XXTouch 真棒\", { size = 320, fill_color = 0xff409bff, shadow_color = 0xff308bef, }) img:save_to_album() 注：上述代码中使用了非本章函数 :save_to_album 微信等 App 无法识别透明色、深色背景的二维码，可以使用 :replace_color 将背景色替换成白色以解决： local img = utils.qr_encode(\"XXTouch 真棒\", { size = 320, fill_color = 0xff409bff, }) img:replace_color(0x00000000, 0xffffffff) -- 透明色替换成白色 img:save_to_album() 注：上述代码中使用了非本章函数 :replace_color、:save_to_album "},"Handbook/utils/utils.launch_args.html":{"url":"Handbook/utils/utils.launch_args.html","title":"获得当前脚本的启动参数 (utils.launch_args)","keywords":"","body":"获得当前脚本的启动参数 (utils.launch_args) 声明 启动参数关联表 = utils.launch_args() 参数及返回值 启动参数关联表 表型，返回一个用于描述当次启动的参数表，结构可以自行用 table.deep_print 打印查看 说明 在 1.1.0-1 版或以上版本 App 内启动有额外的参数获得当前脚本的启动参数，推荐配合 Activator 激活脚本 示例 sys.alert(table.deep_print(utils.launch_args())) 注：上述代码中使用了非本章函数 sys.alert、table.deep_print -- 获取当前脚本文件路径 (注：不是任何情况下脚本都有一个文件路径) sys.alert(\"当前的脚本路径是：\"..tostring(utils.launch_args().path)) 注：上述代码中使用了非本章函数 sys.alert、tostring "},"Handbook/utils/utils.is_launch_via_app.html":{"url":"Handbook/utils/utils.is_launch_via_app.html","title":"判断当前脚本是否从 App 内启动 (utils.is_launch_via_app)","keywords":"","body":"判断当前脚本是否从 App 内启动 (utils.is_launch_via_app) 声明 是否从App内启动 = utils.is_launch_via_app() 参数及返回值 是否从App内启动 布尔型，如果当前脚本是从 App 内的启动按钮启动，则返回 true，否则返回 false 说明 判断当前脚本是否从 App 内的启动按钮启动这个函数在 1.1.0-1 版以上方可使用 示例 dialog:load "},"Handbook/utils/utils.video_to_album.html":{"url":"Handbook/utils/utils.video_to_album.html","title":"导入一个视频文件到相册 (utils.video_to_album)","keywords":"","body":"导入一个视频文件到相册 (utils.video_to_album) 声明 utils.video_to_album(视频文件名) 参数及返回值 视频文件名 文本型，视频文件的文件名，支持的格式有 mp4、m4v、mov 说明 这个函数在 1.1.2-1 版以上方可使用将 mp4、m4v、mov 视频保存到相册 示例 utils.video_to_album(\"/var/mobile/1.mp4\") "},"Handbook/file/index.html":{"url":"Handbook/file/index.html","title":"文件操作模块","keywords":"","body":"文件操作模块 判断一个文件或目录是否存在 (file.exists) 获取目录所有文件名列表 (file.list) 获得一个文件的尺寸 (file.size) 读取一个文件中的所有数据 (file.reads) 将数据覆盖写入到文件 (file.writes) 将数据追加到文件末尾 (file.appends) 统计一个文本文件的总行数 (file.line_count) 获取一个文本文件指定行的数据 (file.get_line) 设置文本文件指定行的内容 (file.set_line) 在文本文件指定行前插入内容 (file.insert_line) 移除文件中指定行 (file.remove_line) 获取一个文本文件的所有行 (file.get_lines) 将一个顺序表转换逐行覆盖写入到文件中 (file.set_lines) 将一个顺序表转换逐行插入到文件指定行前 (file.insert_lines) "},"Handbook/file/file.exists.html":{"url":"Handbook/file/file.exists.html","title":"判断一个文件或目录是否存在 (file.exists)","keywords":"","body":"判断一个文件或目录是否存在 (file.exists) 声明 存在信息 = file.exists(文件路径) 参数及返回值 文件路径 文本型，文件或目录绝对路径 存在信息 false 或 \"file\" 或 \"directory\" false，路径不存在 \"file\"， 路径是一个文件 \"directory\"， 路径是一个目录 说明 用于判断一个路径是文件还是目录还是不存在这个函数在 1.1.0-1 版以上方可使用 示例 if file.exists(\"/var/mobile/1.zip\") then sys.alert(\"`/var/mobile/1.zip` 存在\") else sys.alert(\"`/var/mobile/1.zip` 不存在\") end -- if file.exists(\"/var/mobile/1.zip\")==\"file\" then sys.alert(\"`/var/mobile/1.zip` 存在并且是个文件\") else sys.alert(\"`/var/mobile/1.zip` 不是文件\") end -- if file.exists(\"/var/mobile/123/\")==\"directory\" then sys.alert(\"`/var/mobile/123/` 存在并且是个目录\") else sys.alert(\"`/var/mobile/123/` 不是目录\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.list.html":{"url":"Handbook/file/file.list.html","title":"获取目录所有文件名列表 (file.list)","keywords":"","body":"获取目录所有文件名列表 (file.list) 声明 文件列表 = file.list(文件路径) 参数及返回值 文件路径 文本型，目录绝对路径 文件列表 顺序表型 或 nil，如果目录不存在或路径是一个文件则返回 nil，否则返回目录文件列表 说明 获取目录所有文件名列表这个函数在 1.1.0-1 版以上方可使用 示例 local list = file.list(\"/var/mobile/\") if list then print(\"目录 `/var/mobile/` 中有\"..#list..\"个文件或目录\") for _, name in ipairs(list) do print(name) end sys.alert(print.out()) else sys.alert(\"`/var/mobile/` 不是目录\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.size.html":{"url":"Handbook/file/file.size.html","title":"获得一个文件的尺寸 (file.size)","keywords":"","body":"获得一个文件的尺寸 (file.size) 声明 尺寸 = file.size(文件路径) 参数及返回值 文件路径 文本型，文件绝对路径 尺寸 整数型 或 nil，如果文件不存在或文件名是一个目录则返回 nil，否则返回文件尺寸 (单位: 字节) 说明 获得一个文件的尺寸这个函数在 1.1.0-1 版以上方可使用 示例 local fsize = file.size(\"/var/mobile/1.zip\") if fsize then sys.alert(\"`/var/mobile/1.zip` 的尺寸为：\"..fsize..\"字节\") else sys.alert(\"`/var/mobile/1.zip` 不是文件\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.reads.html":{"url":"Handbook/file/file.reads.html","title":"读取一个文件中的所有数据 (file.reads)","keywords":"","body":"读取一个文件中的所有数据 (file.reads) 声明 内容 = file.reads(文件路径) 参数及返回值 文件路径 文本型，文件绝对路径 内容 字符串型 或 nil，文件不存在返回 nil，否则返回整个文件的数据 说明 读取一个文件中的所有数据这个函数在 1.1.0-1 版以上方可使用 示例 local data = file.reads(\"/var/mobile/1.zip\") if data then sys.alert(\"`/var/mobile/1.zip` 的尺寸为：\"..#data..\"字节\") else sys.alert(\"`/var/mobile/1.zip` 不是文件\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.writes.html":{"url":"Handbook/file/file.writes.html","title":"将数据覆盖写入到文件 (file.writes)","keywords":"","body":"将数据覆盖写入到文件 (file.writes) 声明 写入成败 = file.writes(文件路径, 待写入内容) 参数及返回值 文件路径 文本型，文件绝对路径 待写入内容 字符串型，需要写入的数据 写入成败 布尔型，操作成功返回 true，操作失败返回 false 说明 将数据覆盖写入到文件，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用 示例 local success = file.writes(\"/var/mobile/1.txt\", \"苟\") if success then sys.alert(\"写入成功\") else sys.alert(\"写入失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.appends.html":{"url":"Handbook/file/file.appends.html","title":"将数据追加到文件末尾 (file.appends)","keywords":"","body":"将数据追加到文件末尾 (file.appends) 声明 操作成败 = file.appends(文件路径, 待追加内容) 参数及返回值 文件路径 文本型，文件绝对路径 待追加内容 字符串型，需要追加写入的数据 操作成败 布尔型，操作成功返回 true，操作失败返回 false 说明 将数据追加到文件末尾，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用 示例 local success = file.appends(\"/var/mobile/1.txt\", \"利国家生死矣\") if success then sys.alert(\"写入成功\") else sys.alert(\"写入失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.line_count.html":{"url":"Handbook/file/file.line_count.html","title":"统计一个文本文件的总行数 (file.line_count)","keywords":"","body":"统计一个文本文件的总行数 (file.line_count) 声明 行数 = file.line_count(文件路径) 参数及返回值 文件路径 文本型，文件绝对路径 行数 整数型 或 nil，返回文件总行数，空文件将返回 0，文件不存在返回 nil 说明 统计一个文本文件的总行数，空文件将返回 0这个函数在 1.1.1-1 版以上方可使用 示例 local linecount = file.line_count(\"/var/mobile/1.txt\") if linecount then sys.alert(\"`/var/mobile/1.txt` 一共有 \"..linecount..\" 行\") else sys.alert(\"`/var/mobile/1.txt` 不是文件\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.get_line.html":{"url":"Handbook/file/file.get_line.html","title":"获取一个文本文件指定行的数据 (file.get_line)","keywords":"","body":"获取一个文本文件指定行的数据 (file.get_line) 声明 行内容 = file.get_line(文件路径, 行号) 参数及返回值 文件路径 文本型，文件绝对路径 行号 整数型，指定行号，0 为最后一行 +1，负数则为倒数行号 行内容 字符串型 或 nil，行数不够返回空字符串，文件不存在返回 nil 说明 获取一个文本文件指定行的数据这个函数在 1.1.0-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 常见问题 如果读取到文本的第一行包含不可见字符，请检查是否处理了 UTF8-BOM，可使用 string.strip_utf8_bom 剔除 示例 local data = file.get_line(\"/var/mobile/1.txt\", 1) if data then data = string.strip_utf8_bom(data) -- 处理掉可能存在的 UTF8-BOM sys.alert(\"`/var/mobile/1.txt` 第一行的内容是 \"..data) else sys.alert(\"`/var/mobile/1.txt` 不是文件\") end 注：上述代码中使用了非本章函数 sys.alert、string.strip_utf8_bom "},"Handbook/file/file.set_line.html":{"url":"Handbook/file/file.set_line.html","title":"设置文本文件指定行的内容 (file.set_line)","keywords":"","body":"设置文本文件指定行的内容 (file.set_line) 声明 写入成败 = file.set_line(文件路径, 行号, 待写入内容) 参数及返回值 文件路径 文本型，文件绝对路径 行号 整数型，指定行号，0 为最后一行 +1，负数则为倒数行号 待写入内容 字符串型，需要设置为指定行的数据 写入成败 布尔型，操作成功返回 true，操作失败返回 false 说明 设置文本文件指定行的内容，行数不够用空行补足，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 示例 local success = file.set_line(\"/var/mobile/1.txt\", 3, \"哈哈哈\") if success then sys.alert(\"操作成功\") else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.insert_line.html":{"url":"Handbook/file/file.insert_line.html","title":"在文本文件指定行前插入内容 (file.insert_line)","keywords":"","body":"在文本文件指定行前插入内容 (file.insert_line) 声明 写入成败 = file.insert_line(文件路径, 行号, 待插入的内容) 参数及返回值 文件路径 文本型，文件绝对路径 行号 整数型，指定行号，0 为最后一行 +1，负数则为倒数行号 待插入的内容 字符串型，需要插入到指定行前的数据 写入成败 布尔型，操作成功返回 true，操作失败返回 false 说明 在文本文件指定行前插入内容，行数不够用空行补足，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 示例 local success = file.insert_line(\"/var/mobile/1.txt\", 2, \"岂因祸福避趋之\") if success then sys.alert(\"操作成功\") else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.remove_line.html":{"url":"Handbook/file/file.remove_line.html","title":"移除文件中指定行 (file.remove_line)","keywords":"","body":"移除文件中指定行 (file.remove_line) 声明 操作成败, 被删除行的内容 = file.remove_line(文件路径, 行号) 参数及返回值 文件路径 文本型，文件绝对路径 行号 整数型，指定行号，0 为最后一行 +1，负数则为倒数行号 操作成败 布尔型，操作成功返回 true，操作失败返回 false 被删除行的内容 字符串型，当操作成功的时候，返回被移除的行 说明 移除文件中指定行，如果被移除的行之后还有行，那么后面行会往前移这个函数在 1.1.1-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 常见问题 如果读取到文本的第一行包含不可见字符，请检查是否处理了 UTF8-BOM，可使用 string.strip_utf8_bom 剔除 示例 local success, line = file.remove_line(\"/var/mobile/1.txt\", 3) if success then sys.alert(\"操作成功，被删除的行的内容是：\"..line) else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.get_lines.html":{"url":"Handbook/file/file.get_lines.html","title":"获取一个文本文件的所有行 (file.get_lines)","keywords":"","body":"获取一个文本文件的所有行 (file.get_lines) 声明 行数组 = file.get_lines(文件路径) 参数及返回值 文件路径 文本型，文件绝对路径 行数组 顺序表型 或 nil，返回一个顺序表，文件不存在返回 nil 说明 获取一个文本文件的所有行，空文件返回 0 行这个函数在 1.1.1-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 常见问题 如果读取到文本的第一行包含不可见字符，请检查是否处理了 UTF8-BOM，可使用 string.strip_utf8_bom 剔除 示例 local lines = file.get_lines(\"/var/mobile/1.txt\") if lines then if #lines > 0 then lines[1] = string.strip_utf8_bom(lines[1]) -- 处理掉可能存在的 UTF8-BOM sys.alert(\"文件第一行的内容是 \"..lines[1]) else sys.alert(\"文件是空的\") end else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert、string.strip_utf8_bom "},"Handbook/file/file.set_lines.html":{"url":"Handbook/file/file.set_lines.html","title":"将一个顺序表转换逐行覆盖写入到文件中 (file.set_lines)","keywords":"","body":"将一个顺序表转换逐行覆盖写入到文件中 (file.set_lines) 声明 写入成败 = file.set_lines(文件路径, 行数组) 参数及返回值 文件路径 文本型，文件绝对路径 行数组 顺序表型，需要转换写入到文件的表 写入成败 布尔型，操作成功返回 true，操作失败返回 false 说明 将一个顺序表转换逐行覆盖写入到文件中，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 示例 local success = file.set_lines(\"/var/mobile/1.txt\", { \"苟利国家生死以\", \"岂因祸福避趋之\", }) if success then sys.alert(\"+1s\") else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/file/file.insert_lines.html":{"url":"Handbook/file/file.insert_lines.html","title":"将一个顺序表转换逐行插入到文件指定行前 (file.insert_lines)","keywords":"","body":"将一个顺序表转换逐行插入到文件指定行前 (file.insert_lines) 声明 写入成败 = file.insert_lines(文件路径, 行号, 行数组) 参数及返回值 文件路径 文本型，文件绝对路径 行号 整数型，指定行号，0 为最后一行 +1，负数则为倒数行号 行数组 顺序表型，需要转换插入到文件的表 写入成败 布尔型，操作成功返回 true，操作失败返回 false 说明 将一个顺序表转换逐行插入到文件指定行前，文件不存在会创建文件，目录不存在会返回 false这个函数在 1.1.0-1 版以上方可使用这个函数在 1.2-1 版以上将自动剔除 UTF8-BOM (百度搜索 UTF8-BOM 查看更多资料) 示例 local success = file.insert_lines(\"/var/mobile/1.txt\", 0, { -- 将下面两行字追加到文件末尾 \"I will do whatever it takes to serve my country even at the cost of my own life,\", \"regardless of fortune or misfortune to myself.\", }) if success then sys.alert(\"+1s\") else sys.alert(\"操作失败\") end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/vpnconf/index.html":{"url":"Handbook/vpnconf/index.html","title":"VPN 配置模块","keywords":"","body":"VPN 配置模块 创建一个 VPN 配置 (vpnconf.create) 获取当前系统 VPN 的列表 (vpnconf.list) 选择一个 VPN 配置 (vpnconf.select) 删除一个 VPN 配置 (vpnconf.delete) 以当前选择的 VPN 建立连接 (vpnconf.connect) 断开当前的 VPN 连接 (vpnconf.disconnect) 获取当前选择的 VPN 的状态 (vpnconf.status) "},"Handbook/vpnconf/vpnconf.create.html":{"url":"Handbook/vpnconf/vpnconf.create.html","title":"创建一个 VPN 配置 (vpnconf.create)","keywords":"","body":"创建一个 VPN 配置 (vpnconf.create) 声明 创建成败 = vpnconf.create(配置表) 参数及返回值 配置表 表型，用于描述需要创建的 VPN 配置的描述的字典 创建成败 布尔型，创建成功返回 true，创建失败返回 false，创建失败通常是因为参数不全或错误 说明 这个函数在 1.2-3 版以上方可使用用于快速创建一个 VPN 配置，不支持 IKEv2 类型创建，如果是旧版 XXTouch 或需要创建 IKEv2 类型的 VPN 可使用 VPN 扩展模块 配置表支持的字段及意义 字段名 类型 意义 dispName 文本型 VPN 的显示名 VPNType 文本型 VPN 的类型，支持 \"PPTP\"、\"L2TP\"、\"IPSec\" server 文本型 服务器地址 authorization 文本型 账号 password 文本型 密码 secret 文本型，可选参数 密钥，PPTP 可不填 encrypLevel 整数型，可选参数 加密级别，默认 1 group 文本型，可选参数 群组名称，默认 \"\" VPNSendAllTraffic 整数型，可选参数 是否发送所有流量，默认 1 示例 local success = vpnconf.create{ dispName = '1个测试VPN', -- VPN 的显示名 VPNType = \"L2TP\", -- VPN 的类型，支持 PPTP、L2TP、IPSec、IKEv2 server = 'www.xxtouch.com', -- 服务器地址 authorization = 'havonz', -- 账号 password = '123456', -- 密码 secret = 'XXTOUCH', -- 密钥，PPTP 可不填 encrypLevel = 1, -- 加密级别，选填，默认 1 group = '', -- 群组名称，选填，默认 \"\" VPNSendAllTraffic = 1, -- 是否发送所有流量，选填，默认 1 } if success then sys.alert('创建成功') else sys.alert('创建失败，确定人品没有问题？') end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/vpnconf/vpnconf.list.html":{"url":"Handbook/vpnconf/vpnconf.list.html","title":"获取当前系统 VPN 的列表 (vpnconf.list)","keywords":"","body":"获取当前系统 VPN 的列表 (vpnconf.list) 声明 VPN列表 = vpnconf.list() 参数及返回值 VPN列表 表型 或 nil，获取成功返回当前系统 VPN 的顺序表，获取失败返回 nil 说明 这个函数在 1.2-3 版以上方可使用返回的 VPN 列表结构如下 { {dispName = 显示名1, VPNID = VPNID1}, {dispName = 显示名2, VPNID = VPNID2}, ... } 示例 local list = vpnconf.list() if list then sys.alert(table.deep_print(list)) else sys.alert('获取失败，确定人品没有问题？') end 注：上述代码中使用了非本章函数 sys.alert、table.deep_print "},"Handbook/vpnconf/vpnconf.select.html":{"url":"Handbook/vpnconf/vpnconf.select.html","title":"选择一个 VPN 配置 (vpnconf.select)","keywords":"","body":"选择一个 VPN 配置 (vpnconf.select) 声明 操作成败 = vpnconf.select(显示名或VPNID) 参数及返回值 显示名或VPNID 文本型，选择一个 VPN，多个同显示名 VPN 不保证选择哪个。如果需要精确选择可传入 VPNID 操作成败 布尔型，操作成功返回 true，操作失败返回 false，操作失败通常是因为指定配置不存在 说明 这个函数在 1.2-3 版以上方可使用VPNID 可通过 vpnconf.list 函数获得 示例 local success = vpnconf.select('1个测试VPN') if success then sys.alert('操作成功') else sys.alert('操作失败，确认你要选中的 VPN 配置存在？') end "},"Handbook/vpnconf/vpnconf.delete.html":{"url":"Handbook/vpnconf/vpnconf.delete.html","title":"删除一个 VPN 配置 (vpnconf.delete)","keywords":"","body":"删除一个 VPN 配置 (vpnconf.delete) 声明 操作成败 = vpnconf.delete(显示名或VPNID) 参数及返回值 显示名或VPNID 文本型，删除一个 VPN，多个同显示名 VPN 不保证删除哪个。如果需要精确删除可传入 VPNID 操作成败 布尔型，操作成功返回 true，操作失败返回 false，操作失败通常是因为指定配置不存在 说明 这个函数在 1.2-3 版以上方可使用VPNID 可通过 vpnconf.list 函数获得 示例 local success = vpnconf.delete('1个测试VPN') if success then sys.alert('操作成功') else sys.alert('操作失败，确认你要删除的 VPN 配置存在？') end 注：上述代码中使用了非本章函数 sys.alert 遍历删除所有 VPN 配置示例 -- 删除所有VPN 删除全部VPN VPN全部删除 全部VPN删除 local vpnlist = vpnconf.list() if vpnlist then for _,v in ipairs(vpnlist) do if (vpnconf.delete(v.VPNID)) then sys.log('成功删除：'..v.dispName..'('..v.VPNID..')') else sys.log('无法删除：'..v.dispName..'('..v.VPNID..')') end end sys.alert('操作完成！') else sys.alert('获取列表失败，确定人品没有问题？') end 注：上述代码中使用了非本章函数 sys.alert、sys.log "},"Handbook/vpnconf/vpnconf.connect.html":{"url":"Handbook/vpnconf/vpnconf.connect.html","title":"以当前选择的 VPN 建立连接 (vpnconf.connect)","keywords":"","body":"以当前选择的 VPN 建立连接 (vpnconf.connect) 声明 操作成败 = vpnconf.connect() 参数及返回值 操作成败 布尔型，操作成功 (不是连接成功) 返回 true，操作失败返回 false，操作失败通常是因为没有选中的配置 说明 这个函数在 1.2-3 版以上方可使用 示例 local success = vpnconf.connect() if success then sys.alert('操作成功，正在建立连接……') else sys.alert('当前并无选中任何 VPN 配置，成功创建 VPN 之后，记得调用 vpnconf.select 选中它') end "},"Handbook/vpnconf/vpnconf.disconnect.html":{"url":"Handbook/vpnconf/vpnconf.disconnect.html","title":"断开当前的 VPN 连接 (vpnconf.disconnect)","keywords":"","body":"断开当前的 VPN 连接 (vpnconf.disconnect) 声明 操作成败 = vpnconf.disconnect() 参数及返回值 操作成败 布尔型，操作成功 (不是断开连接成功) 返回 true，操作失败返回 false，操作失败通常是因为没有选中的配置 说明 这个函数在 1.2-3 版以上方可使用 示例 local success = vpnconf.disconnect() if success then sys.alert('操作成功，正在断开连接……') else sys.alert('当前并无选中任何 VPN 配置，成功创建 VPN 之后，记得调用 vpnconf.select 选中它') end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/vpnconf/vpnconf.status.html":{"url":"Handbook/vpnconf/vpnconf.status.html","title":"获取当前选择的 VPN 的状态 (vpnconf.status)","keywords":"","body":"获取当前选择的 VPN 的状态 (vpnconf.status) 声明 状态 = vpnconf.status() 参数及返回值 状态 表型 或 nil，操作成功返回状态描述表，没有选择任何 VPN 返回 nil 说明 这个函数在 1.2-3 版以上方可使用返回的状态表结构如下 { text = 当前状态的文字描述, connected = 是否已经连接成功, } 示例 local status = vpnconf.status() if status then sys.alert(table.deep_print(status)) else sys.alert('当前并无选中任何 VPN 配置，成功创建 VPN 之后，记得调用 vpnconf.select 选中它') end 注：上述代码中使用了非本章函数 sys.alert、table.deep_print "},"Handbook/cloud_ocr/index.html":{"url":"Handbook/cloud_ocr/index.html","title":"云打码模块","keywords":"","body":"云打码模块 初始化一个云打码平台 (cloud_ocr.ocr) 识别屏幕上的范围 (plat.ocr_screen) 识别图片文件 (plat.ocr_image) 识别图片对象 (plat.ocr_obj) 提交错误的识别 (plat.report_error) cloud_ocr 示例代码 "},"Handbook/cloud_ocr/cloud_ocr.ocr.html":{"url":"Handbook/cloud_ocr/cloud_ocr.ocr.html","title":"初始化一个云打码平台 (cloud_ocr.ocr)","keywords":"","body":"初始化一个云打码平台 (cloud_ocr.ocr) 声明 local cloud_ocr = require('cloud_ocr') local plat = cloud_ocr.ocr(平台名, 账号, 密码) 参数及返回值 平台名 文本型，平台 (目前支持 'ruokuai', '好爱') 账号 文本型，云验证码识别网站账号 密码 文本型，云验证码识别网站密码 plat 表型，云打码平台对象，用于后面几个 API 说明 初始化一个云打码平台，云平台账号需要在各自平台官网注册 XXTouch 目前已经集成的云打码平台有若快打码、好爱答题 ruokuai (若快打码) 平台官网：http://www.ruokuai.com/ 注意：若快的开发者账号不能用于打码，需要注册一个用户账号用于打码 好爱 平台官网：http://www.haoi23.net/ 好爱 平台支持在软件版本 1.2-1 或以上集成 示例 本章最后 "},"Handbook/cloud_ocr/plat.ocr_screen.html":{"url":"Handbook/cloud_ocr/plat.ocr_screen.html","title":"识别屏幕上的范围 (plat.ocr_screen)","keywords":"","body":"识别屏幕上的范围 (plat.ocr_screen) 声明 识别结果, 结果标签或错误信息 = plat.ocr_screen(左, 上, 右, 下, 打码类型 [, 超时秒数, 缩放比例 ]) 参数及返回值 plat 表型，云打码平台对象，可以使用 初始化一个云打码平台 来获得 左, 上, 右, 下 整数型，需要打码的图像在屏幕上的范围 打码类型 文本型，打码类型 超时秒数 整数型，可选参数，超时时间设置，单位秒，默认 30 缩放比例 整数型，可选参数，缩放比例，默认 100 不处理 识别结果 文本型 或 nil，识别成功返回打码结果文字，识别失败返回 nil 结果标签或错误信息 文本型，识别成功返回 结果标签，识别失败返回错误信息文本描述 说明 使用打码平台识别屏幕上的范围 打码题型参考若快题型及价格：http://www.ruokuai.com/home/pricetype 示例 本章最后 "},"Handbook/cloud_ocr/plat.ocr_image.html":{"url":"Handbook/cloud_ocr/plat.ocr_image.html","title":"识别图片文件 (plat.ocr_image)","keywords":"","body":"识别图片文件 (plat.ocr_image) 声明 识别结果, 结果标签或错误信息 = plat.ocr_image(文件路径, 打码类型 [, 超时秒数, 缩放比例 ]) 参数及返回值 plat 表型，云打码平台对象，可以使用 初始化一个云打码平台 来获得 文件路径 文本型，需要打码的图像文件名 打码类型 文本型，打码类型 超时秒数 整数型，可选参数，超时时间设置，单位秒，默认 30 缩放比例 整数型，可选参数，缩放比例，默认 100 不处理 识别结果 文本型 或 nil，识别成功返回打码结果文字，识别失败返回 nil 结果标签或错误信息 文本型，识别成功返回 结果标签，识别失败返回错误信息文本描述 说明 使用打码平台识别图像文件文件名如果不使用绝对路径，那么加载 /var/mobile/Media/1ferver/res/ 这个目录的图片文件 打码题型参考若快题型及价格：http://www.ruokuai.com/home/pricetype 示例 本章最后 "},"Handbook/cloud_ocr/plat.ocr_obj.html":{"url":"Handbook/cloud_ocr/plat.ocr_obj.html","title":"识别图片对象 (plat.ocr_obj)","keywords":"","body":"识别图片对象 (plat.ocr_obj) 声明 识别结果, 结果标签或错误信息 = plat.ocr_obj(图像, 打码类型 [, 超时秒数, 缩放比例 ]) 参数及返回值 plat 表型，云打码平台对象，可以使用 初始化一个云打码平台 来获得 图像 图片对象，需要打码的图片对象 打码类型 文本型，打码类型 超时秒数 整数型，可选参数，超时时间设置，单位秒，默认 30 缩放比例 整数型，可选参数，缩放比例，默认 100 不处理 识别结果 文本型 或 nil，识别成功返回打码结果文字，识别失败返回 nil 结果标签或错误信息 文本型，识别成功返回 结果标签，识别失败返回错误信息文本描述 说明 使用打码平台识别图片对象 打码题型参考若快题型及价格：http://www.ruokuai.com/home/pricetype 示例 本章最后 "},"Handbook/cloud_ocr/plat.report_error.html":{"url":"Handbook/cloud_ocr/plat.report_error.html","title":"提交错误的识别 (plat.report_error)","keywords":"","body":"提交错误的识别 (plat.report_error) 声明 提交成败, 状态信息 = plat.report_error([ 结果标签 ]) 参数及返回值 plat 表型，云打码平台对象，可以使用 初始化一个云打码平台 来获得 结果标签 文本型，可选参数，对应打码返回的 结果标签，默认提交上次成功的 结果标签 提交成败 布尔型，返回是否提交成功 状态信息 文本型 或 nil，正确返回状态信息 (可不判断) ，错误返回 nil 说明 提交错误的识别到打码平台 示例 本章最后 "},"Handbook/cloud_ocr/samples.html":{"url":"Handbook/cloud_ocr/samples.html","title":"cloud_ocr 示例代码","keywords":"","body":"cloud_ocr 示例代码 local cloud_ocr = require('cloud_ocr') local plat = cloud_ocr.ocr('ruokuai','平台账号','平台密码') -- 初始化一个平台对象 local text, id_or_err = plat.ocr_screen(3, 448, 628, 724, 1040) -- 使用这个平台打屏幕上的码获得结果 if text then sys.alert('识别成功\\n'.. '结果标签:'..id_or_err..'\\n'.. '识别结果:'..text) else sys.alert('识别失败\\n'.. '错误信息:'..id_or_err) end 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/system-callback/index.html":{"url":"Handbook/system-callback/index.html","title":"系统回调消息","keywords":"","body":"系统回调消息 前言 电话呼入呼出回调消息 扫码结果回调消息 Activator 事件回调消息 HID 事件消息 "},"Handbook/system-callback/START.html":{"url":"Handbook/system-callback/START.html","title":"前言","keywords":"","body":"前言 本章没有自定义函数 "},"Handbook/system-callback/call.html":{"url":"Handbook/system-callback/call.html","title":"电话呼入呼出回调消息","keywords":"","body":"电话呼入呼出回调消息 声明 thread.register_event(\"xxtouch.call_callback\", function(val) if (val == \"in\") then -- 有电话呼入 elseif (val == \"out\") then -- 有电话呼出 elseif (val == \"disconnected\") then -- 电话被挂断 end end) 状态 in 来电呼入的时候，以 xxtouch.call_callback 标识的进程队列词典会推入这个值 out 呼出电话的时候，以 xxtouch.call_callback 标识的进程队列词典会推入这个值 disconnected 当来电或去电挂断的时候，以 xxtouch.call_callback 标识的进程队列词典会推入这个值 说明 当收到系统电话呼入呼出消息的时候，这个消息标识的进程队列词典会推入一个状态 示例 -- 清空消息队列 proc_queue_clear(\"xxtouch.call_callback\") -- sys.toast(\"脚本从现在开始监听来电事件，二十秒后取消监听\") -- -- 开始建立监听回调 local eid = thread.register_event(\"xxtouch.call_callback\", function(val) if (val == \"in\") then sys.toast(\"来电话了\") elseif (val == \"out\") then sys.toast(\"正在打电话出去\") elseif (val == \"disconnected\") then sys.toast(\"电话挂断了\") end end) -- sys.msleep(20000) -- 等待 20 秒 -- -- 反注册回调函数，如果不反注册监听，那么脚本不会在此结束 thread.unregister_event(\"xxtouch.call_callback\", eid) 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、proc_queue_clear、thread.register_event、thread.unregister_event "},"Handbook/system-callback/scan.html":{"url":"Handbook/system-callback/scan.html","title":"扫码结果回调消息","keywords":"","body":"扫码结果回调消息 声明 thread.register_event(\"xxtouch.scan_code_callback\", function(val) local ret = json.decode(val) -- 返回的是一个 json 字符串 if (ret.type == \"org.iso.QRCode\") then -- 扫到一个二维码回调 ret.string 是结果 else -- 其它类型回调可以根据 ret.type 来区分 end end) 状态 val 当使用扫码器扫到一个能识别的值时，以 xxtouch.scan_code_callback 标识的进程队列词典会推入这个值以及它的相关信息 说明 当扫码器扫到一个能识别的值的时候，这个消息标识的进程队列词典会推入一个状态 示例 -- 清空消息队列 proc_queue_clear(\"xxtouch.scan_code_callback\") -- local success = utils.open_code_scanner() if not success then sys.alert(\"可以于 “设置-通用-访问限制” 中取消 “相机” 的访问限制\", 0, \"无法访问系统相机\") return end -- sys.toast(\"脚本从现在开始监扫码结果事件，二十秒后取消监听\") -- -- 开始建立监听回调 local eid = thread.register_event(\"xxtouch.scan_code_callback\", function(val) local ret = json.decode(val) if (ret.type == \"org.iso.QRCode\") then sys.toast(\"扫到一个二维码\\n\"..ret.string) else sys.toast(\"扫到一个条码\\n\"..ret.string) end end) -- sys.msleep(20000) -- 等待 20 秒 -- -- 反注册回调函数，如果不反注册监听，那么脚本不会在此结束 thread.unregister_event(\"xxtouch.scan_code_callback\", eid) 注：上述代码中使用了非本章函数 utils.open_code_scanner、sys.toast、sys.msleep、proc_queue_clear、thread.register_event、 thread.unregister_event、json.decode "},"Handbook/system-callback/activator.html":{"url":"Handbook/system-callback/activator.html","title":"Activator 事件回调消息","keywords":"","body":"Activator 事件回调消息 声明 thread.register_event(\"xxtouch.activator_callback\", function(val) local ret = json.decode(val) sys.toast(\"mode:\"..ret.mode..\"\\n\" ..\"event:\"..ret.event..\"\\n\" ..\"time:\"..ret.time) end) 状态 val 当配置了 Activator 回调并且触发了响应的 Activator 事件的时候，事件的详情会传到这里 说明 需要安装 Activator 并于 Activator 中做好相应的配置配合使用 示例 -- 清空消息队列 proc_queue_clear(\"xxtouch.activator_callback\") -- -- 开始建立监听回调 local eid = thread.register_event(\"xxtouch.activator_callback\", function(val) local ret = json.decode(val) if ret.event==\"libactivator.statusbar.tap.double\" then sys.toast(\"双击状态栏回调\") end end) -- sys.msleep(20000) -- 等待 20 秒 -- -- 反注册回调函数，如果不反注册监听，那么脚本不会在此结束 thread.unregister_event(\"xxtouch.activator_callback\", eid) 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、proc_queue_clear、thread.register_event、thread.unregister_event "},"Handbook/system-callback/hid.html":{"url":"Handbook/system-callback/hid.html","title":"HID 事件消息","keywords":"","body":"HID 事件消息 声明 thread.register_event(\"xxtouch.hid_event\", function(val) local event = json.decode(val) if event.event_type==\"touch\" then if event.event_name==\"touch.on\" then sys.toast(\"触摸接触位置: (\"..event.x..\", \"..event.y..\")\\n\"..event.time) elseif event.event_name==\"touch.move\" then sys.toast(\"触摸移动到位置: (\"..event.x..\", \"..event.y..\")\\n\"..event.time) elseif event.event_name==\"touch.off\" then sys.toast(\"触摸从位置: (\"..event.x..\", \"..event.y..\") 离开屏幕\\n\"..event.time) end else if event.event_name==\"key.down\" then sys.toast(\"按下按键: \"..event.key_name..\"\\n\"..event.time) elseif event.event_name==\"key.up\" then sys.toast(\"抬起按键: \"..event.key_name..\"\\n\"..event.time) end end end) 状态 val 注册监听则所有的 hid 事件信息都会传递到这里，极度影响脚本运行效率，不需要了请及时反注册 HID 事件中所有的触摸坐标都是以竖屏 HOME 键在下为初始化坐标系，如果需要，可以使用 screen.rotate_xy 转换后使用 示例 -- 清空消息队列 proc_queue_clear(\"xxtouch.hid_event\") -- -- 建立监听回调 local eid = thread.register_event(\"xxtouch.hid_event\", function(val) local event = json.decode(val) if event.event_type==\"touch\" then if event.event_name==\"touch.on\" then sys.toast(\"触摸接触位置: (\"..event.x..\", \"..event.y..\")\\n\"..event.time) elseif event.event_name==\"touch.move\" then sys.toast(\"触摸移动到位置: (\"..event.x..\", \"..event.y..\")\\n\"..event.time) elseif event.event_name==\"touch.off\" then sys.toast(\"触摸从位置: (\"..event.x..\", \"..event.y..\") 离开屏幕\\n\"..event.time) end else if event.event_name==\"key.down\" then sys.toast(\"按下按键: \"..event.key_name..\"\\n\"..event.time) elseif event.event_name==\"key.up\" then sys.toast(\"抬起按键: \"..event.key_name..\"\\n\"..event.time) end end end) -- touch.on(100, 100):off() sys.msleep(1000) key.press('homebutton') -- sys.msleep(20000) -- 等待 20 秒 -- -- 反注册回调函数，如果不反注册监听，那么脚本不会在此结束 thread.unregister_event(\"xxtouch.hid_event\", eid) 注：上述代码中使用了非本章函数 sys.toast、sys.msleep、proc_queue_clear、thread.register_event、thread.unregister_event "},"Handbook/gps/index.html":{"url":"Handbook/gps/index.html","title":"地理位置伪装","keywords":"","body":"地理位置伪装 伪装GPS位置 (gps.fake) 清除GPS伪装信息 (gps.clear) "},"Handbook/gps/gps.fake.html":{"url":"Handbook/gps/gps.fake.html","title":"伪装GPS位置 (gps.fake)","keywords":"","body":"伪装GPS位置 (gps.fake) 声明 gps.fake(应用包名, 纬度, 经度) 参数及返回值 应用包名 文本型，指定应用包名 纬度 实数型，纬度 经度 实数型，经度 说明 对指定应用伪装 GPS 位置，脚本或者服务停止后依然有效更新、重装或是卸载 XXTouch 会清空所有的伪装信息电脑端拾取经纬度坐标可以用 这个 (百度地图坐标拾取) 示例 gps.fake(\"com.baidu.map\", 39.806139606082951, 116.2303211298582) "},"Handbook/gps/gps.clear.html":{"url":"Handbook/gps/gps.clear.html","title":"清除GPS伪装信息 (gps.clear)","keywords":"","body":"清除GPS伪装信息 (gps.clear) 声明 gps.clear([应用包名]) 参数及返回值 应用包名 文本型，可选参数，指定应用包名，如果不填，则清除所有应用的 GPS 伪装信息 说明 清除指定应用的 GPS 伪装信息更新、重装或是卸载 XXTouch 会清空所有的伪装信息 示例 gps.clear(\"com.baidu.map\") "},"Handbook/extensions/index.html":{"url":"Handbook/extensions/index.html","title":"外部扩展","keywords":"","body":"外部扩展 大漠找字/文字识别 模块 "},"Handbook/extensions/dm.html":{"url":"Handbook/extensions/dm.html","title":"大漠找字/文字识别 模块","keywords":"","body":"大漠找字/文字识别 模块 工具下载 大漠综合工具.zip 说明 大漠找字识字不用我解释是什么了吧？这个模块使用废弃的 matrix_dict 模块 封装，源代码开放。安装 XXTouch 之后可以在设备 /var/mobile/Media/1ferver/lua/dm.lua 查看源代码这个模块在 1.1.0-1 版以上方可使用 示例 -- 看例子！！ local dm = require(\"dm\") -- 引用 dm 库 dm.SetPath(\"/var/mobile/Media/1ferver/res\") -- 设置字库查找目录，默认 /var/mobile/Media/1ferver/res dm.SetDict(0, \"dm_soft.txt\") -- 设置一个编号对应的字库文件 dm.UseDict(0) -- 选择字库编号，默认 0 -- local found, x, y = dm.FindStr(0, 0, 307, 215, \"相机\", \"4d4226-404010\", 1.0) local text = dm.Ocr(0, 0, 307, 215, \"4d4226-404010\", 1.0) sys.alert(table.deep_print({found, x, y, text})) 注：上述代码中使用了非本章函数 sys.alert、table.deep_print "},"Handbook/open-source/index.html":{"url":"Handbook/open-source/index.html","title":"已集成的开源扩展库","keywords":"","body":"已集成的开源扩展库 LuaCJSON 扩展库 LuaSocket 扩展库 luaiconv 编码转换扩展库 lpeg 扩展库 LuaFileSystem 扩展库 LuaSQLite3 模块 lcurl 模块 "},"Handbook/open-source/luacjson.html":{"url":"Handbook/open-source/luacjson.html","title":"LuaCJSON 扩展库","keywords":"","body":"LuaCJSON 扩展库 LuaCJSON 手册地址 注： XXTouch 内置的 JSON 模块就是 LuaCJSON，参考 JSON 模块 (json) "},"Handbook/open-source/luasocket.html":{"url":"Handbook/open-source/luasocket.html","title":"LuaSocket 扩展库","keywords":"","body":"LuaSocket 扩展库 LuaSocket 手册地址 连接超时示例 local socket = require(\"socket\") local sock = socket.tcp() sock:settimeout(0.2) -- 设置连接超时秒数 if (sock:connect(\"220.181.57.217\", 80)) then sock:close() -- 关闭连接 sys.alert(\"能连上\") else sys.alert(\"超时了\") end 注：上述代码中使用了非本章函数 sys.alert 模拟 HTTP 请求百度首页示例 local socket = require('socket') local sock = socket.tcp() local ip = assert(socket.dns.toip('www.baidu.com'), '域名解析失败') sock:settimeout(10) assert(sock:connect(ip, 80) == 1, '连接失败或超时') assert( sock:send( 'GET / HTTP/1.1\\r\\n'.. 'Host: www.baidu.com\\r\\n'.. 'Accept: */*\\r\\n'.. 'Connection: close\\r\\n'.. '\\r\\n' ), '发送数据超时' ) local buf = {} repeat local chunk, status, partial = sock:receive(4096) if (chunk) then buf[#buf + 1] = chunk else if (partial) then buf[#buf + 1] = partial end end until status == \"closed\" sock:close() sys.alert(table.concat(buf)) 注：上述代码中使用了非本章函数 sys.alert、table.concat "},"Handbook/open-source/luaiconv.html":{"url":"Handbook/open-source/luaiconv.html","title":"luaiconv 编码转换扩展库","keywords":"","body":"luaiconv 编码转换扩展库 luaiconv 手册地址 GBK 编码转 UTF-8 编码示例 local iconv = require(\"iconv\") local cd = iconv.new(\"utf-8\", \"gbk\") -- 新建一个 GBK 编码到 UTF8 编码的转换器 local f = io.open(\"/var/mobile/1.txt\", \"rb\") local s = f:read(\"*a\") f:close() sys.alert(cd:iconv(s)) 注：上述代码中使用了非本章函数 sys.alert Unicode Little Endian (UTF-16LE) 编码转 UTF-8 编码示例 local iconv = require(\"iconv\") local cd = iconv.new(\"utf-8\", \"utf-16le\") -- 新建一个 UTF-16LE 编码到 UTF8 编码的转换器 local f = io.open(\"/var/mobile/1.txt\", \"rb\") local s = f:read(\"*a\") f:close() sys.alert(cd:iconv(s)) 注：上述代码中使用了非本章函数 sys.alert Unicode Big Endian (UTF-16BE) 编码转 UTF-8 编码示例 local iconv = require(\"iconv\") local cd = iconv.new(\"utf-8\", \"utf-16be\") -- 新建一个 UTF-16BE 编码到 UTF8 编码的转换器 local f = io.open(\"/var/mobile/1.txt\", \"rb\") local s = f:read(\"*a\") f:close() sys.alert(cd:iconv(s)) 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/open-source/lpeg.html":{"url":"Handbook/open-source/lpeg.html","title":"lpeg 扩展库","keywords":"","body":"lpeg 扩展库 lpeg 手册地址 "},"Handbook/open-source/luafilesystem.html":{"url":"Handbook/open-source/luafilesystem.html","title":"LuaFileSystem 扩展库","keywords":"","body":"LuaFileSystem 扩展库 LuaFileSystem 手册地址 获取路径中所有文件名示例 local lfs = require(\"lfs\") for filename in lfs.dir(\"/var/mobile\") do if (filename ~= \"..\" and filename ~= \".\") then print(filename) end end sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert 获取文件 (夹) 属性示例 local lfs = require(\"lfs\") -- local attr = lfs.attributes(\"/var/mobile\") -- print(\"类型\", attr.mode) print(\"最后访问时间\", os.date(\"%Y-%m-%d %H:%M:%S\", attr.access)) print(\"最后修改时间\", os.date(\"%Y-%m-%d %H:%M:%S\", attr.modification)) print(\"最后状态变更时间\", os.date(\"%Y-%m-%d %H:%M:%S\", attr.change)) -- sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert 获取及切换脚本当前目录示例 local lfs = require 'lfs' -- sys.alert(lfs.currentdir()) -- 输出 \"/\" -- lfs.chdir('/var/mobile/Media/1ferver/lua/scripts') -- sys.alert(lfs.currentdir()) -- 输出 \"/var/mobile/Media/1ferver/lua/scripts\" 注：上述代码中使用了非本章函数 sys.alert "},"Handbook/open-source/luasqlite3.html":{"url":"Handbook/open-source/luasqlite3.html","title":"LuaSQLite3 模块","keywords":"","body":"LuaSQLite3 模块 LuaSQLite3 手册地址 引用示例 local sqlite3 = require('sqlite3') 读取短信示例 local sqlite3 = require('sqlite3') -- local db = sqlite3.open('/private/var/mobile/Library/SMS/sms.db') -- local handle_map = {} local messages = {} -- db:exec('select handle_id, text, date from message', function (ud, ncols, values, names) messages[#messages + 1] = { handle_id = values[1], text = values[2], date = os.date(\"%Y-%m-%d %H:%M:%S\", os.time({year = 2001, month = 1, day = 1}) + tonumber(values[3])) } return sqlite3.OK end) -- db:exec('select ROWID, id from handle', function (ud, ncols, values, names) handle_map[values[1]] = values[2] return sqlite3.OK end) -- for _,v in ipairs(messages) do v.id = handle_map[v.handle_id] v.handle_id = nil end -- local results = {} for _,v in ipairs(messages) do results[#results + 1] = string.format(\"[%s](%s):%s\", v.date, v.id, v.text) end -- sys.toast(table.concat(results, '\\n')) 注：上述代码中使用了非本章函数 sys.toast、table.concat "},"Handbook/open-source/lcurl.html":{"url":"Handbook/open-source/lcurl.html","title":"lcurl 模块","keywords":"","body":"lcurl 模块 这个模块在 1.1.0-1 版以上方可使用 lcurl 手册地址 URIEncode 和 URIDecode -- URL编码 URI编码 百分号编码 URLEncode URLDecode URLEscape URIEscape PercentEscape local curl = require('lcurl') local e = curl.easy() -- print(e:escape('abcd$%^&*()')) -- 输出 \"abcd%24%25%5E%26%2A%28%29\" -- print(e:unescape('abcd%24%25%5E%26%2A%28%29')) -- 输出 \"abcd$%^&*()\" -- sys.alert(print.out()) 注：上述代码中使用了非本章函数 sys.alert 模拟触摸精灵 httpGet 实现示例 function httpGet(url) -- 也能请求 ftp 资源 (此函数已内置，不需要再拷贝到自己脚本中，只是 lcurl 使用实例而已) if (url:sub(1, 6) ~= \"ftp://\" and url:sub(1, 7) ~= \"http://\" and url:sub(1, 8) ~= \"https://\") then url = \"http://\"..url end local curl = require(\"curl.safe\") local buffer_t = {} local write_f = function(s) buffer_t[#buffer_t + 1] = s end local noerr, err = pcall(function() curl.easy() :setopt(curl.OPT_URL, url) :setopt(curl.OPT_CONNECTTIMEOUT, 60) :setopt_writefunction(write_f) :perform() end) if (noerr) then return table.concat(buffer_t) else return nil, err end end 注：上述代码中使用了非本章函数 table.concat "},"Handbook/more-open-source/index.html":{"url":"Handbook/more-open-source/index.html","title":"更多的编译好的开源扩展库","keywords":"","body":"更多的编译好的开源扩展库 XML格式扩展库.zip 已兼容 iOS 11项目源码：https://github.com/LuaDist/luaxml ZIP压缩文件操作库.zip 已兼容 iOS 11项目源码：https://github.com/brimworks/lua-zip zlib字符串压缩解压库.zip 已兼容 iOS 11项目源码：https://github.com/LuaDist/lzlib ZeroMQZMQØMQ_扩展库.zip 已兼容 iOS 11项目源码：https://github.com/zeromq/lzmq OpenSSL扩展库.zip 已兼容 iOS 11项目源码：https://github.com/zhaozg/lua-openssl UNIX系统API对接库.zip 已兼容 iOS 11项目源码：https://github.com/wahern/lunix使用文档：http://25thandclement.com/~william/projects/lunix.pdf POSIX标准API扩展库.zip 已兼容 iOS 11项目源码：https://github.com/luaposix/luaposix使用文档：http://luaposix.github.io/luaposix MySQL客户端扩展库.zip 已兼容 iOS 11项目源码：https://github.com/keplerproject/luasql使用文档：http://keplerproject.github.io/luasql/manual.html "},"Handbook/supplement/index.html":{"url":"Handbook/supplement/index.html","title":"附录","keywords":"","body":"附录 开发及周边工具下载 扩展库及远程扩展接口 脚本守护模式是什么？ 开机启动的时机说明 \"URL Scheme\" 的相关应用 日期格式化相关 (os.date) 命令执行相关示例代码 (os.execute) string 库的相关应用 math 库的相关应用 学习 Lua 注意避开的坑 开发常见运行期错误参考 "},"Handbook/supplement/dev-tools.html":{"url":"Handbook/supplement/dev-tools.html","title":"开发及周边工具下载","keywords":"","body":"开发及周边工具下载 全平台编辑器、脚本制作工具、集成开发环境下载页 Windows 平台工具 XXT 局域网集中控下载页 XXT 取色器 1.0.12 Windows 版.zip XXT 网络授权 1.12.0.1.zip 大漠综合工具.zip 其它平台工具 XXT 取色器 1.0.12 MacOS 版（需要安装 Java）.zip XXT 取色器 1.0.12 Java 无绑版.zip "},"Handbook/supplement/exts.html":{"url":"Handbook/supplement/exts.html","title":"扩展库及远程扩展接口","keywords":"","body":"扩展库及远程扩展接口 扩展库 除 XXTouch 团队已编译的强大的扩展库以外 开发者还可自行为 XXTouch 扩展更多的功能 有兴趣赶快下载下面模板尝试一下吧！ Lua插件模板.zip 远程扩展接口 如果有兴趣给 XXTouch 开发周边平台配套软件 例如：基于局域网的 集中控制系统、截图取色工具、脚本开发调试环境、设备间数据共享 可以看这里：OpenAPI "},"Handbook/supplement/daemon-mode.html":{"url":"Handbook/supplement/daemon-mode.html","title":"脚本守护模式是什么？","keywords":"","body":"脚本守护模式是什么？ 脚本守护模式会保证脚本在被外力因素 (如服务程序崩溃、设备断电) 终止后，设备再次恢复正常状态的时候能够再次启动脚本。例外情形如下： 设备断电后再无充电 设备开不了机 设备重启后丢失越狱状态 设备处于安全模式 设备有锁屏密码并重启 用户终止 脚本因运行期错误终止 守护模式会先于开机启动脚本启动，所以在设备发生故障重启后可以在脚本头部加上如下代码以确保当次脚本启动的时候，屏幕已经处于解锁状态while (device.is_screen_locked()) do device.unlock_screen() sys.msleep(1000) end sys.toast(\"屏幕已解锁，脚本开始\") -- 这下面就可以开始脚本 -- ... "},"Handbook/supplement/bootstrap.html":{"url":"Handbook/supplement/bootstrap.html","title":"开机启动的时机说明","keywords":"","body":"开机启动的时机说明 开机启动脚本需要主屏幕完全准备好之后才会运作，一般而言会在开机之后延迟一会儿再启动。 较为常见的开机不启动情形如下： 无法进入桌面 开机后进入安全模式 设置了锁屏密码 "},"Handbook/supplement/url-scheme.html":{"url":"Handbook/supplement/url-scheme.html","title":"\"URL Scheme\" 的相关应用","keywords":"","body":"\"URL Scheme\" 的相关应用 具体使用方法参考：app.open_url URL Scheme 跳转到 prefs:root=WIFI 设置-WiFi (或无线局域网) prefs:root=Bluetooth 设置-蓝牙 prefs:root=INTERNET_TETHERING 设置-个人热点 prefs:root=Wallpaper 设置-墙纸与亮度 prefs:root=Sounds 设置-声音 prefs:root=Sounds&path=Ringtone 设置-声音-电话铃声 prefs:root=Photos 设置-照片与相机 prefs:root=STORE 设置-iTunes Store 和 App Store prefs:root=Safari 设置-Safari prefs:root=MUSIC 设置-音乐 prefs:root=MUSIC&path=EQ 设置-音乐-均衡器 prefs:root=VIDEO 设置-视频 prefs:root=NOTES 设置-备忘录 prefs:root=Phone 设置-电话 prefs:root=CASTLE 设置-iCloud prefs:root=CASTLE&path=STORAGE_AND_BACKUP 设置-iCloud-存储与备份 prefs:root=NOTIFICATIONS_ID 设置-通知中心 prefs:root=ACCOUNT_SETTINGS 设置-邮件、日历、通讯录 prefs:root=LOCATION_SERVICES 设置-定位服务 prefs:root=MESSAGES 设置-信息 prefs:root=GAMECENTER 设置-Game Center prefs:root=General 设置-通用 prefs:root=General&path=About 设置-通用-关于本机 prefs:root=General&path=SOFTWARE_UPDATE_LINK 设置-通用-软件更新 prefs:root=General&path=ACCESSIBILITY 设置-通用-辅助功能 prefs:root=General&path=ACCESSIBILITY/REDUCE_MOTION 设置-通用-辅助功能-减少动态效果 prefs:root=General&path=ACCESSIBILITY/ENHANCE_BACKGROUND_CONTRAST 设置-通用-辅助功能-增强对比度 prefs:root=General&path=AUTO_CONTENT_DOWNLOAD 设置-通用-后台应用刷新 prefs:root=General&path=USAGE 设置-通用-用量 prefs:root=General&path=AUTOLOCK 设置-通用-自动锁定 prefs:root=General&path=DATE_AND_TIME 设置-通用-日期与时间 prefs:root=General&path=Keyboard 设置-通用-键盘 prefs:root=General&path=INTERNATIONAL 设置-通用-多语言环境 prefs:root=General&path=VPN 设置-通用-VPN prefs:root=General&path=Bluetooth 设置-通用-蓝牙 prefs:root=General&path=Network 设置-通用-网络 prefs:root=General&path=Network/VPN 设置-通用-网络-VPN prefs:root=General&path=ManagedConfigurationList 设置-通用-描述文件 prefs:root=General&path=Reset 设置-通用-还原 "},"Handbook/supplement/os.date.html":{"url":"Handbook/supplement/os.date.html","title":"日期格式化相关 (os.date)","keywords":"","body":"日期格式化相关 (os.date) os.date 第二个参数是可选参数，默认为当前时间 格式 示例 描述 结果 %Y-%m-%d %H:%M:%S os.date(\"%Y-%m-%d %H:%M:%S\", 1487356783) 一种常用日期时间格式 2017-02-18 02:39:43 %Y-%m-%d os.date(\"%Y-%m-%d\", 1487356783) 一种常用日期格式 2017-02-18 %a os.date(\"%a\", 1487356783) 短星期名 Sat %A os.date(\"%A\", 1487356783) 全星期名 Saturday %b os.date(\"%b\", 1487356783) 简写的月份名 Feb %B os.date(\"%B\", 1487356783) 月份的全称 February %c os.date(\"%c\", 1487356783) 标准的日期的时间串 Sat Feb 18 02:39:43 2017 %d os.date(\"%d\", 1487356783) 月的天[01-31] 18 %H os.date(\"%H\", 1487356783) 24小时制的时[00-23] 02 %I os.date(\"%I\", 1487356783) 12小时制的时[01-12] 02 %j os.date(\"%j\", 1487356783) 年的天[001-366] 049 %M os.date(\"%M\", 1487356783) 分钟[00-59] 39 %m os.date(\"%m\", 1487356783) 月份[01-12] 02 %p os.date(\"%p\", 1487356783) 上午AM 下午PM AM %S os.date(\"%S\", 1487356783) 秒钟[00-61] 43 %w os.date(\"%w\", 1487356783) 星期几 (星期日为0) [0-6] 6 %x os.date(\"%x\", 1487356783) 标准的日期串 02/18/17 %X os.date(\"%X\", 1487356783) 标准的时间串 02:39:43 %y os.date(\"%y\", 1487356783) 不带世纪的年份 17 %Y os.date(\"%Y\", 1487356783) 带世纪部分的年份 2017 %% os.date(\"%%\", 1487356783) 百分号 % 更多 os.date 使用示例实时显示当前日期时间 "},"Handbook/supplement/os.execute.html":{"url":"Handbook/supplement/os.execute.html","title":"命令执行相关示例代码 (os.execute)","keywords":"","body":"命令执行相关示例代码 (os.execute) 重启设备 os.execute('reboot') 注销设备 os.execute('killall -9 SpringBoard backboardd') 重建图标缓存 os.execute('su mobile -c uicache') 创建脚本日志符号链接到脚本目录 os.execute('ln -s /private/var/mobile/Media/1ferver/log/sys.log /private/var/mobile/Media/1ferver/lua/scripts/脚本日志.txt') 常用操作封装 --[[ 删除文件 文件删除 删除目录 重命名文件 文件重命名 目录重命名 重命名目录 文件夹重命名 重命名文件夹 移动文件 文件移动 移动目录 目录移动 移动文件夹 文件夹移动 拷贝文件 文件拷贝 复制文件 文件复制 新建目录 创建目录 拷贝目录 目录拷贝 复制目录 目录复制 新建文件夹 创建文件夹 拷贝文件夹 文件夹拷贝 复制文件夹 文件夹复制 以上是关键词，便于在手册中搜索到此处 --]] local function sh_escape(path) -- XXTouch 原创函数，未经 XXTouch 许可，可以用于商业用途 path = string.gsub(path, \"([ \\\\()<>'\\\"`#&*;?~$])\", \"\\\\%1\") return path end function fdelete(path) -- 删除一个文件或目录 (递归删除子项) assert(type(path)==\"string\" and path~=\"\", 'fremove 参数异常') os.execute('rm -rf '..sh_escape(path)) end function frename(from, to) -- 重命名 (移动) 一个文件或目录 assert(type(from)==\"string\" and from~=\"\", 'frename 参数 1 异常') assert(type(to)==\"string\" and to~=\"\", 'frename 参数 2 异常') os.execute('mv -f '..sh_escape(from)..\" \"..sh_escape(to)) end function fcopy(from, to) -- 拷贝一个文件或目录 (递归拷贝子项) assert(type(from)==\"string\" and from~=\"\", 'fcopy 参数 1 异常') assert(type(to)==\"string\" and to~=\"\", 'fcopy 参数 2 异常') os.execute('cp -rf '..sh_escape(from)..\" \"..sh_escape(to)) end function mkdir(path) -- 新建一个目录 (递归创建子目录) assert(type(path)==\"string\" and path~=\"\", 'mkdir 参数异常') os.execute('mkdir -p '..sh_escape(path)) end function openurl(url) -- 跳转到一个链接 assert(type(url)==\"string\" and url~=\"\", 'openurl 参数异常') os.execute('uiopen '..sh_escape(url)) end -- 以上是封装好的函数，拷贝到自己脚本前就可以用。 -- 以下是使用方式 (不用拷贝) -- 删除 /var/mobile/1.png fdelete(\"/var/mobile/1.png\") -- 将 /var/mobile/2.png 重命名为 /var/mobile/1.png frename(\"/var/mobile/2.png\", \"/var/mobile/1.png\") -- 将 /var/mobile/1.png 移动到 /var/mobile/Media/1ferver/res/3.png frename(\"/var/mobile/1.png\", \"/var/mobile/Media/1ferver/res/3.png\") -- 将 /var/mobile/1.png 拷贝到 /var/mobile/Media/1ferver/res/4.png fcopy(\"/var/mobile/1.png\", \"/var/mobile/Media/1ferver/res/4.png\") -- 建立 /var/mobile/1/2/3/4/ 目录 mkdir(\"/var/mobile/1/2/3/4\") -- 跳转到 www.google.com openurl(\"http://www.google.com\") "},"Handbook/supplement/string-samples.html":{"url":"Handbook/supplement/string-samples.html","title":"string 库的相关应用","keywords":"","body":"string 库的相关应用 基本函数 函数 描述 示例 结果 len 计算字符串长度 string.len(\"abcd\") 4 rep 返回字符串s的n个拷贝 string.rep(\"abcd\",2) abcdabcd lower 返回字符串全部字母小写 string.lower(\"AbcD\") abcd upper 返回字符串全部字母大写 string.upper(\"AbcD\") ABCD format 格式化字符串 string.format(\"the value is:%d\",4) the value is:4 sub 从字符串里截取字符串 string.sub(\"abcd\",2) bcd string.sub(\"abcd\",-2) cd string.sub(\"abcd\",2,-2) bc string.sub(\"abcd\",2,3) bc find 在字符串中查找(显示位置) string.find(\"cdcdcdcd\",\"ab\") nil string.find(\"cdcdcdcd\",\"cd\") 1 2 string.find(\"cdcdcdcd\",\"cd\",7) 7 8 match 在字符串中查找(显示内容) string.match(\"cdcdcdcd\",\"ab\") nil string.match(\"cdcdcdcd\",\"cd\") cd gsub 在字符串中替换 string.gsub(\"abcdabcd\",\"a\",\"z\") zbcdzbcd 2 string.gsub(\"aaaa\",\"a\",\"z\",3) zzza 3 byte 返回字符的整数形式 string.byte(\"ABCD\",4) 68 char 将整型数字转成字符并连接 string.char(97,98,99,100) abcd 基本模式串 字符类 描述 示例 结果 . 任意字符 string.find(\"\",\".\") nil %s 空白符 string.find(\"ab cd\",\"%s%s\") 3 4 %S 非空白符 string.find(\"ab cd\",\"%S%S\") 1 2 %p 标点字符 string.find(\"ab,.cd\",\"%p%p\") 3 4 %P 非标点字符 string.find(\"ab,.cd\",\"%P%P\") 1 2 %c 控制字符 string.find(\"abcd\\t\\n\",\"%c%c\") 5 6 %C 非控制字符 string.find(\"\\t\\nabcd\",\"%C%C\") 3 4 %d 数字 string.find(\"abcd12\",\"%d%d\") 5 6 %D 非数字 string.find(\"12abcd\",\"%D%D\") 3 4 %x 十六进制数字 string.find(\"efgh\",\"%x%x\") 1 2 %X 非十六进制数字 string.find(\"efgh\",\"%X%X\") 3 4 %a 字母 string.find(\"AB12\",\"%a%a\") 1 2 %A 非字母 string.find(\"AB12\",\"%A%A\") 3 4 %l 小写字母 string.find(\"ABab\",\"%l%l\") 3 4 %L 大写字母 string.find(\"ABab\",\"%L%L\") 1 2 %u 大写字母 string.find(\"ABab\",\"%u%u\") 1 2 %U 非大写字母 string.find(\"ABab\",\"%U%U\") 3 4 %w 字母和数字 string.find(\"a1()\",\"%w%w\") 1 2 %W 非字母非数字 string.find(\"a1()\",\"%W%W\") 3 4 转义字符% 字符类 描述 示例 结果 % 转义字符 string.find(\"abc%..\",\"%%\") 4 4 string.find(\"abc..d\",\"%.%.\") 4 5 用[]创建字符集，\"-\"为连字符，\"^\"表示字符集的补集 字符类 描述 示例 结果 [01] 匹配二进制数 string.find(\"32123\",\"[01]\") 3 3 [AB][CD] 匹配AC、AD、BC、BD string.find(\"ABCDEF\",\"[AB][CD]\") 2 3 [[]] 匹配一对方括号[] string.find(\"ABC[]D\",\"[[]]\") 4 5 [1-3] 匹配数字1-3 string.find(\"312\",\"[1-3][1-3][1-3]\") 1 3 [b-d] 匹配字母b-d string.find(\"dbc\",\"[b-d][b-d][b-d]\") 1 3 [^%s] 匹配任意非空字符 string.find(\" a \",\"[^%s]\") 3 3 [^%d] 匹配任意非数字字符 string.find(\"123a\",\"[^%d]\") 4 4 [^%a] 匹配任意非字母字符 string.find(\"abc1\",\"[^%a]\") 4 4 用\"()\"进行捕获 字符类 描述 示例 结果 () 捕获字符串 string.find(\"12ab\",\"(%a%a)\") 3 4 ab string.find(\"ab12\",\"(%d%d)\") 3 4 12 模式修饰符 修饰符 描述 示例 结果 + 表示1个或多个，匹配最多个 string.find(\"aaabbb\",\"(a+b)\") 1 4 aaab string.find(\"cccbbb\",\"(a+b)\") nil - 表示0个或多个，匹配最少个 string.find(\"zzxyyy\",\"(xy-)\") 3 3 x string.find(\"zzzyyy\",\"(x-y)\") 4 4 y * 表示0个或多个，匹配最多个 string.find(\"mmmnnn\",\"(m*n)\") 1 4 mmmb string.find(\"lllnnn\",\"(m*n)\") 4 4 n ? 表示0个或1个 string.find(\"aaabbb\",\"(a?b)\") 3 4 ab string.find(\"cccbbb\",\"(a?b)\") 4 4 b match的常见用法 描述 示例 结果 匹配中文 string.match(\"男女abc123\",\"(%w%p+)\") 男女 匹配英文 string.match(\"男女abc123\",\"(%a+)\") abc 匹配数字 string.match(\"男女abc123\",\"(%d+)\") 123 匹配英文和数字 string.match(\"男女abc123\",\"(%w+)\") abc123 "},"Handbook/supplement/math-samples.html":{"url":"Handbook/supplement/math-samples.html","title":"math 库的相关应用","keywords":"","body":"math 库的相关应用 函数名 描述 示例 结果 pi 圆周率 math.pi 3.1415926535898 abs 取绝对值 math.abs(-2012) 2012 ceil 向上取整 math.ceil(9.1) 10 floor 向下取整 math.floor(9.9) 9 max 取参数最大值 math.max(2,4,6,8) 8 min 取参数最小值 math.min(2,4,6,8) 2 pow 计算x的y次幂 math.pow(2,16) 65536.0 sqrt 开平方 math.sqrt(65536) 256.0 modf 取整数和小数部分 math.modf(20.12) 20 0.12 randomseed 设随机数种子 math.randomseed(os.time()) random 取随机数 math.random(5,90) 5~90 rad 角度转弧度 math.rad(180) 3.1415926535898 deg 弧度转角度 math.deg(math.pi) 180.0 exp e的x次方 math.exp(4) 54.598150033144 log 计算x的自然对数 math.log(54.598150033144) 4.0 log10 计算10为底，x的对数 math.log10(1000) 3.0 frexp 将参数拆成x * (2 ^ y)的形式 math.frexp(160) 0.625 8 ldexp 计算x * (2 ^ y) math.ldexp(0.625,8) 160.0 sin 正弦 math.sin(math.rad(30)) 0.5 cos 余弦 math.cos(math.rad(60)) 0.5 tan 正切 math.tan(math.rad(45)) 1.0 asin 反正弦 math.deg(math.asin(0.5)) 30.0 acos 反余弦 math.deg(math.acos(0.5)) 60.0 atan 反正切 math.deg(math.atan(1)) 45.0 "},"Handbook/supplement/abc.html":{"url":"Handbook/supplement/abc.html","title":"学习 Lua 注意避开的坑","keywords":"","body":"学习 Lua 注意避开的坑 数组下标是从 1 开始的 (区别于 C 语言系的 0 开始) string.len 不是取字符串的字符个数，而是取字节数 所有未初始化的变量都是 nil，对一个表中的值赋 nil 会从表中删除它 只有 nil 和 false 是逻辑假，其它值都是逻辑真，包括 0 字符串和数字在做数学运算和对比大小时会自动转换，比如 a = '1' + 2 两个浮点数 (带小数点的数) 不能用全等号 (==) 做对比，错误用法比如 if 89.7 == (3 * 29.9) then 一个可以完全表示为整数的浮点数和对应的整数相等 (例如：1.0 == 1) "},"Handbook/supplement/runtime-errors.html":{"url":"Handbook/supplement/runtime-errors.html","title":"开发常见运行期错误参考","keywords":"","body":"开发常见运行期错误参考 错误描述片段 原因 处理方式 attempt to perform arithmetic on a 尝试对非数值进行了数学运算 (+、-、*、/) 数学运算之前，检查运算输入是否都为数字 attempt to compare 尝试对非法值进行了比较运算 (>、=、 比较运算之前，检查运算输入是否双方可以进行比较运算 attempt to concatenate a 尝试对非字符串值进行了连接 (..) 在进行字符串连接之前，先确定连接双方都为字符串 attempt to call a 尝试调用了一个不是函数的变量 调用一个函数之前，先确定其是否为一个函数 attempt to index a 尝试对一个非表变量进行索引 (下标运算) 在从数组变量或关联数组变量中取值前，先确定其是否为一个表 attempt to yield across a C-call boundary 尝试在不能让出的调用块中让出 require 一个模块的时候，请确认被 require 的模块返回之前没有调用会让出的函数 (手册上函数前带叹号) 。还有就是不要尝试在带 C 回调的函数中使用会让出的函数 (手册上函数前带叹号) 。 invalid order function for sorting 非法的排序函数，通常发生在排序函数的规则逻辑不够明确的情况下 调用排序函数时，明确排序规则，不要出现 a 大于 b 成立同时小于 b 也成立的规则 bad argument #1 to 'xxx' (number expected, got nil) 调用 xxx 函数时，第 #1 个参数的类型不正确，需要 number 却传入了 nil 参数错误，传入合适的参数就不会出错了 bad argument #2 to 'xxx' (number has no integer representation) 调用 xxx 函数时，第 #2 个参数无法转换成整数 参数错误，传入合适的参数就不会出错了 bad argument #3 to 'xxx' 调用 xxx 函数时，第 #3 个参数非法 参数错误，传入合适的参数就不会出错了 使用 require 的时候抛出 attempt to yield across a C-call boundary 错误的权宜解决方案 1、在被 require 的模块代码前加上一行 return function() 2、在被 require 的模块代码最后加上一行 end 3、require 的时候，后面多加一对括号，例如 require('A') 改成 require('A')() 看完上面仍然不会操作的下载参考例子 像dofile一样使用require.zip "},"XPP/index.html":{"url":"XPP/index.html","title":"XPP 脚本包","keywords":"","body":"XPP 脚本包 简介 XPP 格式 元信息 BundleIdentifier (包标识符) BundleVersion (脚本应用包的版本号) BundleName (短名称) BundleDisplayName (显示名称) BundleIconFile (图标文件) Executable (可执行入口脚本文件) MainInterfaceFile (主界面配置入口文件) MinimumSystemVersion/MaximumSystemVersion (最低/最高 iOS 版本要求) MinimumXXTVersion (最低 XXTouch 服务版本要求) SupportedResolutions (支持的设备屏幕物理尺寸数组) PackageControl (附加信息) 本地化 XPA 打包格式 "},"XPP/INTRO.html":{"url":"XPP/INTRO.html","title":"简介","keywords":"","body":"简介 在 XXTouch 1.2 之前，我们采用 Lua 作为开发语言，采用 .lua 作为源代码，.xxt 作为编译加密后的可执行脚本。然而，单一的源代码或可执行脚本，需要引用一些模块、配置和资源文件，往往不能独立发布，不便于打包、版本管理、资源调用。因此我们引入了 XPP 脚本包与 XPA 脚本包存档的概念。 我们为 XPP 脚本包的制作及分发, 编写了 简易图文教程. "},"XPP/Layout.html":{"url":"XPP/Layout.html","title":"XPP 格式","keywords":"","body":"XPP 格式 XPP ( 以下称作“脚本应用包” ) 是可以被 XXTouch 解析、查看与执行的一种 Bundle ( 包 ) 结构，以单一文件的形式出现在用户面前。这个“文件”实际上是一个以 .xpp 为扩展名的目录 ( 文件夹 ) ，其目录结构如下： 文件 描述 Info.lua 信息文件结构化存储了脚本应用包的配置。XXTouch 依赖此文件辨识 XPP 及相关文件的信息。 可执行脚本 每个脚本应用包都必须包含至少一个可执行脚本 ( .xxt, .lua ) 。 界面配置 可选，脚本应用包中可以包含 XUI 配置 ( .xui, .xuic ) ，为该应用提供配置界面。 资源文件 可选，可执行脚本以外所需的数据文件。通常，资源文件包含了图像、图标、声音、本地化串、配置文件及其它数据。大多数资源文件是为特定的一些语言或地区准备的，亦可为通用资源。 什么是 Bundle (包)？ Bundle ( 包 ) 是一种特定结构、特定扩展名的目录 ( 文件夹 ) ，这种结构允许将相关资源（例如可执行文件，本地化资源，图片等）组合在一起，成为在概念上独立的项目。 多数类型的 Bundle ( 包 ) 在使用时与常规文件类似，从而减少了其内部文件意外更改或丢失的风险。同时，Bundle ( 包 ) 的另一个意义在于可以使用文件夹简化组织资源的方式，避免使用资源分支导致的额外的复杂性。 "},"XPP/Layout/Info.html":{"url":"XPP/Layout/Info.html","title":"元信息","keywords":"","body":"元信息 XPP 脚本包中需要一个名为 Info.lua 的脚本，返回一个用于描述当前脚本应用包元信息的 Lua 表常量。它通常不应该包含常量值以外的 Lua 代码。 以下是一个典型的 Info.lua 示例： return { BundleIdentifier = \"com.yourcompany.yourscript\"; BundleVersion = \"0.0.1\"; BundleName = \"Your Name\"; BundleDisplayName = \"\\U4f60\\U7684\\U540d\\U5b57\"; BundleIconFile = \"appicon.png\"; Executable = \"xui-script.lua\"; MainInterfaceFile = \"xui-demo.xui\"; MinimumSystemVersion = \"10.0\"; MaximumSystemVersion = \"10.2\"; MinimumXXTVersion = \"1.1.2\"; SupportedResolutions = { { width = 640; height = 1136; }; }; PackageControl = { AuthorName = \"i_82\"; AuthorEmail = \"i.82@me.com\"; Description = \"\"; Homepage = \"https://82flex.com\"; }; }; Info.lua 返回的表通常包含以下键值对，各键值对的详细解释参见各子章节： 键 必选 建议 描述 BundleIdentifier * * 唯一标识符 BundleVersion * * 版本号 BundleName * * 名称 Executable * 可执行入口脚本文件名 ( .lua, .xxt ) BundleDisplayName * 显示名称 BundleIconFile * 应用图标 MainInterfaceFile * XUI 入口配置文件名 ( .xui, .xuic ) MinimumSystemVersion 最低系统版本要求 MaximumSystemVersion 最高系统版本要求 MinimumXXTVersion 最低 XXTouch 版本要求 SupportedResolutions 设备分辨率支持数组 PackageControl 附加信息 你应当尽可能完善这些信息，完善的显示名称、应用图标、配置界面有助于你的脚本观感更好，获得更高的认可度。 在脚本中，获取 Info.lua 中的常量信息，可通过 XPP 脚本包模块 获取。 XPP 脚本包支持哪些脚本？ XPP 脚本包中支持的可执行服务脚本格式有: .lua 与 .xxt. 脚本从脚本包中获取资源与配置, 与单独运行并无太大区别. 如需指定 XPP 脚本包的入口脚本, 参见 Info.lua 的 Executable 字段. 如何指定 XPP 的配置界面？ 如需指定 XPP 脚本包配置时的配置界面文件, 参见 Info.lua 的 MainInterfaceFile 字段. 如需编写配置界面 XUI 文件, 参见 XUI 界面库使用手册. 如何处理 XPP 中的资源？ XPP 脚本包中的脚本/资源/模块/数据需放置于 XPP 目录中, 通过相对路径访问. XPP 脚本包运行时所产生的临时文件/数据, 请勿存放在 XPP 脚本包中, 应存放于 XXTouch 缓存目录、临时目录等位置. 在脚本中，XPP 脚本包中的资源路径，可通过 XPP 脚本包模块 获取。 "},"XPP/Layout/Info/BundleIdentifier.html":{"url":"XPP/Layout/Info/BundleIdentifier.html","title":"BundleIdentifier (包标识符)","keywords":"","body":"BundleIdentifier (包标识符) 包标识符 用来精确、唯一地表示一个独立脚本应用包。当开发者创建了一个脚本应用包并设置了 包标识符 后，该应用的 包标识符 在其整个生命周期内不能被更改。 包标识符 字符串必须为通用类型标识符 ( UTI )，只允许包含数字与字母 ( A-Z, a-z, 0-9 )、短横线 ( - ) 和点 ( . )。该字符串通常应该以倒序 DNS 格式呈现。举个例子，如果开发者组织的域名为 82flex.com，并且该脚本应用包名称为 Hello，开发者应该以 com.82flex.hello 作为其 包标识符。 "},"XPP/Layout/Info/BundleVersion.html":{"url":"XPP/Layout/Info/BundleVersion.html","title":"BundleVersion (脚本应用包的版本号)","keywords":"","body":"BundleVersion (脚本应用包的版本号) 脚本应用包的版本号，用于表示脚本应用包副本每一次的更新迭代，其格式为： 1.1.0 主版本.副版本.发布号 这种定义虽然并不严格，但是值得注意的是，主版本、副版本、发布号均为整数，且它们之间以点分隔，其中，发布号可省略 ( 默认为 0 )： 1.1 主版本.副版本 在脚本应用包的生命周期中，每次发布版本号必须递增，其比较规则为：先比较主版本的数值，再比较副版本的数值，最后比较发布号的数值。 "},"XPP/Layout/Info/BundleName.html":{"url":"XPP/Layout/Info/BundleName.html","title":"BundleName (短名称)","keywords":"","body":"BundleName (短名称) 短名称，该名称不应超过 16 个字符，也可用于在脚本中显示和读取，用于菜单、推送。 "},"XPP/Layout/Info/BundleDisplayName.html":{"url":"XPP/Layout/Info/BundleDisplayName.html","title":"BundleDisplayName (显示名称)","keywords":"","body":"BundleDisplayName (显示名称) 显示名称，该名称可以超过 16 个字符，仅用于显示在 XXTouch 应用程序中的脚本列表，不应该用于逻辑判断。 若不设置，则使用 BundleName ( 短名称 ) 的值。 "},"XPP/Layout/Info/BundleIconFile.html":{"url":"XPP/Layout/Info/BundleIconFile.html","title":"BundleIconFile (图标文件)","keywords":"","body":"BundleIconFile (图标文件) 图标文件，指定用于显示在 XXTouch 应用程序中的脚本列表中的图标在脚本应用包中的相对位置，图标文件必须为 .png 格式，若图标名为 appicon.png，则需要提供以下图标： 文件名 尺寸 appicon.png 64 × 64 appicon@2x.png 128 × 128 appicon@3x.png 192 × 192 若不设置，则显示默认图标。 "},"XPP/Layout/Info/Executable.html":{"url":"XPP/Layout/Info/Executable.html","title":"Executable (可执行入口脚本文件)","keywords":"","body":"Executable (可执行入口脚本文件) 可执行入口脚本文件，指定直接运行将会执行的脚本文件在脚本应用包中的相对位置，必须为 .lua 或 .xxt 格式。 1.2-10 更新 若不设置，该 XPP 不显示启动按钮，且轻按时不能选中，如果设置了 MainInterfaceFile，则轻按将会进入配置界面。你可以从 XUI 配置界面中启动不同的入口脚本。 "},"XPP/Layout/Info/MainInterfaceFile.html":{"url":"XPP/Layout/Info/MainInterfaceFile.html","title":"MainInterfaceFile (主界面配置入口文件)","keywords":"","body":"MainInterfaceFile (主界面配置入口文件) 主界面配置入口文件，指定在 XXTouch 应用程序的脚本列表中选择配置脚本应用包时，将打开该 XUI 配置，必须为 .xui 或 .xuic 格式。.xuic 为 .xui 特有的一种加密格式, 可在 App 中对 .xui 文件直接进行加密. 若不设置，该 XPP 不显示配置按钮。 "},"XPP/Layout/Info/SystemVersion.html":{"url":"XPP/Layout/Info/SystemVersion.html","title":"MinimumSystemVersion/MaximumSystemVersion (最低/最高 iOS 版本要求)","keywords":"","body":"MinimumSystemVersion/MaximumSystemVersion (最低/最高 iOS 版本要求) 最低/最高 iOS 版本要求，如不在该区间，则安装/配置/运行时提示不兼容的 iOS 版本。 在 XXTouch 脚本中获取当前系统版本： ver = sys.version() "},"XPP/Layout/Info/MinimumXXTVersion.html":{"url":"XPP/Layout/Info/MinimumXXTVersion.html","title":"MinimumXXTVersion (最低 XXTouch 服务版本要求)","keywords":"","body":"MinimumXXTVersion (最低 XXTouch 服务版本要求) 最低 XXTouch 服务版本要求，如不满足最低版本，则运行时提示不兼容的 XXTouch 版本。 若不设置，则默认兼容所有 XXTouch v1.2-1 及以上所有版本。 在 XXTouch 脚本中获取当前 XXTouch 版本： xver = sys.xtversion() "},"XPP/Layout/Info/SupportedResolutions.html":{"url":"XPP/Layout/Info/SupportedResolutions.html","title":"SupportedResolutions (支持的设备屏幕物理尺寸数组)","keywords":"","body":"SupportedResolutions (支持的设备屏幕物理尺寸数组) 支持的设备屏幕物理尺寸数组。如运行设备的屏幕尺寸不在该数组中，则安装/配置/运行时提示不兼容的设备屏幕尺寸。 若不设置，则默认兼容所有设备屏幕尺寸。 在 XXTouch 脚本中获取设备屏幕物理尺寸： width, height = screen.size() "},"XPP/Layout/Info/PackageControl.html":{"url":"XPP/Layout/Info/PackageControl.html","title":"PackageControl (附加信息)","keywords":"","body":"PackageControl (附加信息) 附加信息，字典。用于存放该脚本应用包的作者信息、发布者信息、发布时间、版权信息等等。支持的键值对有： 键 说明 AuthorName 作者名 AuthorEmail 作者电子邮件地址 Homepage 首页 Description 描述 Category 分类 Tags 标签 Copyright 版权信息 这些信息将会在脚本包的项目属性以及安装时显示. "},"XPP/Layout/Localizable.html":{"url":"XPP/Layout/Localizable.html","title":"本地化","keywords":"","body":"本地化 XPP 脚本包支持本地化元信息、本地化资源调用. 其策略与 iOS 本地化 所声明的策略一致, 你可以将脚本包的 Info.plist 或 .strings 文件放置于多语言文件夹 .lproj 中, 实现脚本包的多语言化. 具体使用方法在此不作过多叙述, 有需要的开发者可自行了解 iOS 本地化的相关细节. "},"XPP/XPA.html":{"url":"XPP/XPA.html","title":"XPA 打包格式","keywords":"","body":"XPA 打包格式 XPP 脚本包目录可以打包为 XPA 格式进行分发, 分发到用户的客户端上进行安装, 还原为 XPP 脚本包目录. XPA 格式实质上是 .zip 压缩文件, 其内部目录结构非常简单: Demo.xpa (zipped) - Payload - A-Script-Bundle.xpp 你只需要将准备好的 .xpp 脚本包放置于一个名为 Payload 的空白目录下, 并对 Payload 目录压缩为 .zip 压缩文件, 并将该压缩文件的后缀名更改为 .xpa 即可. "},"XUI/index.html":{"url":"XUI/index.html","title":"XUI 界面库使用手册","keywords":"","body":"XUI 界面库使用手册 前言 示例 创建 根 主题 通用属性 读取配置 组件 Group 分组 Link 链接子界面 Switch 开关 Button 动作按钮 TextField 单行文本框 Radio / Checkbox 单选框 / 复选框组 Segment 适合少量选项的单项选择 Option 单项选择列表 MultipleOption 多项选择列表 OrderedOption 多项有序选择列表 EditableList 可编辑列表 Slider 数值拖拽滑块 Stepper 数值调节按钮 DateTime 时间日期选择器 TitleValue 键值对显示; 代码片段选择器 StaticText 静态文本框 Textarea 多行文本域 Image / AnimatedImage 图片 / 动态图片 File 文件选择器 About 关于 XUI 支持的 API 代码片段 前言 创建 应用程序选择器 虚拟按键选择器 地理位置选择器 图像位置与颜色选择器 图像区域选择器 "},"XUI/START.html":{"url":"XUI/START.html","title":"前言","keywords":"","body":"前言 在阅读本文前, 您需要对 Lua 语法有所了解, 并能理解 数值/布尔型/字符串/表 等基本数据类型. 适用于 v1.2-1 及以上平台版本 支持 iPhone/iPad 横竖屏, 支持 iOS 7 及以上系统版本 XUI 不与原有的对话框 ( dialog ) 和 WebView UI 冲突 XUI 为 XPP 脚本包 提供界面扩展 XUI 用于在 XXTouch 上提供配置界面, 采用 iOS 系统原生组件, 本手册提供了 XUI 界面布局的规范. 我们提供了 XUI 完善的 示例脚本包, 这将有助于你理解本手册中各章节的内容. XUI 是 XPP 脚本包 的一部分, 用来为脚本包创建配置, 不能独立使用. 如需使用 XUI, 您需要 创建 指定格式的 .xui 脚本, 放置在 XPP 脚本包中, 并在 Info.lua 脚本中设置 MainInterfaceFile 字段, 详情请参见 XPP 脚本包. 配置项可以通过 XUI 脚本配置界面模块 进行读取、写入和更新. "},"XUI/Demo.html":{"url":"XUI/Demo.html","title":"示例","keywords":"","body":"示例 脚本开发者可以从 XXTouch “找脚本” 下载示例包, 在 XXTouch 中安装并运行. "},"XUI/Creation.html":{"url":"XUI/Creation.html","title":"创建","keywords":"","body":"创建 .xui 脚本是一种特定格式的 .lua 脚本 (即以 UTF-8 编码的纯文本文件), 使用这种格式创建 XUI 界面, 需要使 Lua 执行后返回一个包含各组件及属性的表. .xui 可以使用 App 内置的加密功能, 加密为 .xuic, 这样就没有那么容易被非法篡改了. 尽管可以, 但不推荐您使用 .json 或 .plist 格式, 来创建 XUI 界面. "},"XUI/Creation/Root.html":{"url":"XUI/Creation/Root.html","title":"根","keywords":"","body":"根 XUI 配置的根（顶层）为字典. 键 类型 描述 条件 title 字符串 导航栏标题 可选, 可本地化 header 字符串 主标题 可选, 可本地化 subheader 字符串 副标题 可选, 可本地化 defaults 字符串 配置分区标识符, 即全局配置文件存储的名称 - items 包含字典的数组 组件列表 - theme 字典 界面主题样式 可选 stringsTable 字符串 多语言表名称, 默认为 Localizable 可选 defaults 为配置分区标识符, 指定了各组件配置项存储的位置, 例如设置 defaults 为 com.yourcompany.A-Script-Bundle, 则该 XUI 配置文件将保存到 uicfg/com.yourcompany.A-Script-Bundle.plist 当中. 同时, 也可为各组件分别设置 defaults 字段. items 是组件列表数组, 所有的 组件字典 按顺序存放在该数组中, 即可在界面上显示. 关于 组件字典 的说明, 参见通用属性. stringsTable 仅当你需要为 XUI 启用多语言支持时使用, 标记为“可本地化”的属性, 将按照 iOS 国际化支持的方式, 在多语言表中解析出对应语言的内容进行显示. return { title = \"一个脚本包\"; header = \"脚本配置演示\"; subheader = \"由 XXTouch 提供的优雅的脚本配置界面\"; defaults = \"com.yourcompany.A-Script-Bundle\"; -- 配置存储的位置，读取配置的时候需要用到 theme = { style = \"Grouped\"; -- 组显示风格，如果为 Plain 则为平铺显示风格 }; items = { { }; -- 组件 1 { }; -- 组件 2 { }; -- 组件 3 }; -- 该表中存放各个组件的字典 }; "},"XUI/Creation/Theme.html":{"url":"XUI/Creation/Theme.html","title":"主题","keywords":"","body":"主题 在根层级设置 theme 字典, 能为界面配置统一的样式, 所有的组件以及子页面都将继承根层级主题字典的所有字段. 如需要为组件单独设置样式, 可以在各组件字典中设置 theme 字典. 组件 theme 字典中的字段将覆盖根层级的 theme 字典, 从而发生主题样式的合并. 不同的组件可以有它们自身特有的主题属性, 参见每个组件的 主题键 表格. 如果组件链接到一个非 XUI 子页面, 如 Option/MultipleOption/OrderedOption/EditableList 组件, 则子页面的主题样式将使用组件的 theme 字典; 如果组件链接到另一个 XUI 子页面, 如 Link 组件, 则子页面中可以单独设置 theme 字典, 并与父页面的发生主题样式的合并. 界面 键 类型 描述 style 风格 界面风格 tintColor 颜色 前景颜色 backgroundColor 颜色 背景颜色 separatorColor 颜色 组件分隔线颜色 backgroundImage 字符串 背景图片相对路径 导航栏 键 类型 描述 navigationBarColor 颜色 导航栏背景颜色 navigationTitleColor 颜色 导航栏标题颜色 页首与页尾 键 类型 描述 headerTextColor 颜色 header 文字颜色 subheaderTextColor 颜色 subheader 文字颜色 footerTextColor 颜色 页尾文字颜色 headerBackgroundColor 颜色 header 背景颜色 footerBackgroundColor 颜色 页尾背景颜色 通用组件 键 类型 描述 cellBackgroundColor 颜色 组件背景颜色 disclosureIndicatorColor 颜色 组件指示器颜色 selectedColor 颜色 选中颜色 highlightedColor 颜色 高亮颜色 labelColor 颜色 标题文字颜色 valueColor 颜色 值文字颜色 状态 键 类型 描述 dangerColor 颜色 错误颜色 warningColor 颜色 警告颜色 successColor 颜色 成功颜色 风格 style 描述 Grouped 组风格 (默认) Plain 平铺风格 类型 颜色, 即以 # 开头的, 十六进制 RGB/RGBA 字符串形式, 如 #FF0000 代表红色. "},"XUI/Creation/General.html":{"url":"XUI/Creation/General.html","title":"通用属性","keywords":"","body":"通用属性 各组件均可使用如下通用属性, 为组件添加标题, 图标, 指定配置保存位置等. 这些通用属性在具体的组件中可能有不同的作用. 键 类型 描述 条件 cell 字符串 组件类型 - label 字符串 显示标签 可选, 可本地化 defaults 字符串 配置分区标识符, 即该组件配置存储的名称 - key 字符串 配置键名 defaults != nil default 字符串 配置默认值 - value 基本类型 配置值 可选 icon 字符串 图标文件名 可选 readonly 布尔型 组件是否只读 可选 height 数值 组件的高度 可选 cell 为组件类型, 不同类型代表不同的 XUI 组件, 如 Button, Switch, Link 等. label 为组件标题, 通常显示在组件左侧. default 为组件默认值, 若 value 为 nil, 则使用 default 的值填充 value. icon 为图标, 显示在 label 左侧. 若设置为 res/16.png, 建议同时准备 res/16@2x.png 和 res/16@3x.png, 实际尺寸须分别为原来的 2 倍和 3 倍. readonly 如果为 true, 则组件的值只读, 不能被修改和置空. 也不能链接到子界面. "},"XUI/Creation/ReadSettings.html":{"url":"XUI/Creation/ReadSettings.html","title":"读取配置","keywords":"","body":"读取配置 配置完成后, 在 defaults 指定的保存位置, 读取 plist 中键 key == \"switch1\" 的值, 即为开关 \"switch1\" 的状态. 读取、写入及更新 XUI 配置, 可参见 XUI 脚本配置界面模块. local switch1 = xui.get(\"com.yourcompany.A-Script-Bundle\", \"switch-1\") if (switch1) then -- ... end "},"XUI/Modules/index.html":{"url":"XUI/Modules/index.html","title":"组件","keywords":"","body":"组件 Group 分组 Link 链接子界面 Switch 开关 Button 动作按钮 TextField 单行文本框 Radio / Checkbox 单选框 / 复选框组 Segment 适合少量选项的单项选择 Option 单项选择列表 MultipleOption 多项选择列表 OrderedOption 多项有序选择列表 EditableList 可编辑列表 Slider 数值拖拽滑块 Stepper 数值调节按钮 DateTime 时间日期选择器 TitleValue 键值对显示; 代码片段选择器 StaticText 静态文本框 Textarea 多行文本域 Image / AnimatedImage 图片 / 动态图片 File 文件选择器 About 关于 "},"XUI/Modules/Group.html":{"url":"XUI/Modules/Group.html","title":"Group 分组","keywords":"","body":"Group 分组 此组件在界面上显示一个分组区域, 包含到下一个分组组件之间的所有组件. 通常用于功能划分, 也经常用于对某一组件的补充描述. 通常情况下, 列表中第一个组件必须是 Group, 如果不是, XUI 会自动在列表的第一个位置添加一个 Group 组件. 键 类型 描述 必选 默认值 最低版本需求 label 字符串 分组标题 可本地化 \"\" - footerText 字符串 在当前组之后添加一行小字 可本地化 \"\" - 此组件不支持 icon/height. 主题 主题键 类型 描述 groupHeaderTextColor 颜色 分组首部标题颜色, 即 label 的颜色 groupFooterTextColor 颜色 分组尾部文字颜色, 即 footerText 的颜色 groupHeaderBackgroundColor 颜色 分组首部背景颜色 groupFooterBackgroundColor 颜色 分组尾部背景颜色 示例 -- 分组组件 { cell = \"Group\"; label = \"开关\"; -- 分组标题 footerText = \"这是一组开关\"; -- 分组底部描述 }; -- 下面的两个组件是两个开关，会包含在该分组内 { default = true; label = \"启用某功能\"; cell = \"Switch\"; key = \"enabled\"; -- 该项存储的键，读取该键配置时需要用到 }; { default = false; label = \"带图标的开关\"; cell = \"Switch\"; key = \"enabled1\"; -- 该项存储的键，读取该键配置时需要用到 icon = \"res/16.png\"; -- 其它有些组件也可以设置图标 readonly = true; -- 所有组件都支持禁用 }; -- 另一分组 { cell = \"Group\"; label = \"另一组\"; }; -- ... "},"XUI/Modules/Link.html":{"url":"XUI/Modules/Link.html","title":"Link 链接子界面","keywords":"","body":"Link 链接子界面 此组件在界面上显示一个子菜单项, 通常用于链接子界面. 键 类型 描述 必选 默认值 最低版本需求 url 字符串 子界面文件名 * - - url 可以为普通文件名、XUI 文件名或网络地址. 普通文件将使用默认打开方式打开, xui/xuic 文件将作为子界面打开, 网络地址将使用内置浏览器打开. 示例 { cell = \"Group\"; label = \"子页面\"; }; { url = \"sub/xui-sub.xuic\"; -- 相对于 xpp 的路径 cell = \"Link\"; label = \"更多组件演示\"; }; { url = \"sub/xui-dynamic.xui\"; cell = \"Link\"; label = \"动态联动通知演示\"; }; { cell = \"Group\"; label = \"资源浏览\"; }; { url = \"https://www.xxtouch.com\"; cell = \"Link\"; label = \"打开 XXTouch.com\"; }; { url = \"res/b6d21727a66f856f79dc9b6ef8e7b4d6.gif\"; cell = \"Link\"; label = \"打开一个图片\"; }; { url = \"res/SmartSelect.mp4\"; cell = \"Link\"; label = \"打开一个视频\"; }; { url = \"https://www.apple.com/apple-events/september-2015/\"; cell = \"Link\"; label = \"在线视频\"; }; "},"XUI/Modules/Switch.html":{"url":"XUI/Modules/Switch.html","title":"Switch 开关","keywords":"","body":"Switch 开关 此组件在界面上显示一个开关. 键 类型 描述 必选 默认值 最低版本需求 negate 布尔型 反转开关显示情况 - false - trueValue 基本类型 当结果为 true 时保存的值若不填则保存 true - true - falseValue 基本类型 当结果为 false 时保存的值若不填则保存 false - false - 返回类型 描述 基本类型 与开关状态一致, 但若 negate 为真, 配置值为开关状态取反.若存在, 配置值会被 trueValue 或 falseValue 代替. 主题 主题键 类型 描述 offTintColor 颜色 关闭时开关底色 onTintColor 颜色 开启时开关底色 thumbTintColor 颜色 开关中心色 示例 { default = true; label = \"启用某功能\"; cell = \"Switch\"; key = \"enabled\"; -- 该项存储的键，读取该键配置时需要用到 }; { default = false; label = \"带图标的开关\"; cell = \"Switch\"; key = \"enabled1\"; -- 该项存储的键，读取该键配置时需要用到 icon = \"res/16.png\"; -- 其它有些组件也可以设置图标 readonly = true; -- 所有组件都支持禁用 }; "},"XUI/Modules/Button.html":{"url":"XUI/Modules/Button.html","title":"Button 动作按钮","keywords":"","body":"Button 动作按钮 此组件在界面上显示一个按钮, 用于执行一个动作. 键 类型 描述 必选 默认值 最低版本需求 action 字符串 动作标识 * - - args 字典 传递给动作的参数 * - - alignment 字符串 对齐方式 - Left 1.2-10 alignment 描述 Left 左对齐 Center 居中 Right 右对齐 Natural 自然对齐 Justified 两边对齐 动作说明 动作执行完成后, 会将动作的返回值保存到该组件的配置对中, 因此需要正确设置该组件的 key 和 defaults 属性. 不同的 action 动作需要传递不同的参数字典 args. Reload: 刷新 XUI，重新加载所有运行中的 XUI 实例, 需要 XXT v1.2-10 及更高版本. 无参数, 无返回值 RunCommand: 调用 system/posix_spawn 执行命令行, 需要 XXT v1.2-10 及更高版本. 键 类型 描述 必选 默认值 最低版本需求 command 字符串 欲执行的命令行字符串 * - 1.2-10 返回值类型 描述 整数 命令行执行的返回值 Exit Status LaunchScript: 运行服务脚本. 键 类型 描述 必选 默认值 最低版本需求 path 字符串 服务脚本路径 * - - 无返回值 OpenURL: 在第三方应用中打开URL. 键 类型 描述 必选 默认值 最低版本需求 url 字符串 欲打开的URL * - - 无返回值 ScanQRCode: 调起相机, 扫描二维码. 无参数 返回值类型 描述 字符串 二维码扫描结果 SendMail: 在应用中, 发送邮件. 键 类型 描述 必选 默认值 最低版本需求 subject 字符串 邮件主题 * - - toRecipients 包含字符串的数组 收件邮箱地址数组 * - - ccRecipients 包含字符串的数组 抄送邮箱地址数组 - {} - bccRecipients 包含字符串的数组 密送邮箱地址数组 - {} - attachments 包含字符串的数组 携带附件的路径数组 - {} - 无返回值 Null: 无动作, 一般用于重置一个特定的配置值, 并发出相应通知给脚本, 需要 XXT v1.2-10 及更高版本. 无参数, 无返回值 示例 { cell = \"Button\"; action = \"OpenURL:\"; label = \"联系 info@xxtouch.com\"; args = { url = \"mailto://info@xxtouch.com\"; } }; "},"XUI/Modules/TextField.html":{"url":"XUI/Modules/TextField.html","title":"TextField 单行文本框","keywords":"","body":"TextField 单行文本框 此组件在界面上显示一个文本框, 用于字符串输入. 键 类型 描述 必选 默认值 最低版本需求 alignment 字符串 对齐方式 - Left - keyboard 字符串 键盘类型 - Default - placeholder 字符串 文本框占位符 可本地化 \"\" - isSecure 布尔型 字符是否显示为小圆点 - false - clearButtonMode 字符串 是否显示清除小黑叉 - Never - maxLength 整数 最大文本长度 - INT_MAX - validationRegex 字符串 用于验证字符串条目的正则表达式 - nil 1.2-10 prompt 字符串 提示框标题 可本地化 nil 1.2-10 message 字符串 提示框信息 可本地化 nil 1.2-10 okTitle 字符串 提示框确定按钮标题 可本地化 \"好\" 1.2-10 cancelTitle 字符串 提示框取消按钮标题 可本地化 \"取消\" 1.2-10 此组件不支持 icon. 若设置 title 属性, 建议将 alignment 属性设为 \"Right\". 修改或添加字符串条目时, 若字符串无法通过正则表达式 validationRegex 验证, 则无法保存当前条目. prompt 或 message 不为空时, 轻按 TextField, 会弹出提示框, 并要求在提示框中输入值, 此特性需要 XXT v1.2-10 及更高版本与 iOS 8.0 及更高版本. alignment 描述 Left 左对齐 Center 居中 Right 右对齐 Natural 自然对齐 Justified 两边对齐 keyboard 描述 Default 标准及第三方键盘 Alphabet 标准 ASCII ASCIICapable 标准 ASCII NumbersAndPunctuation 数字与标点 URL 网址 NumberPad 数字 PhonePad 电话号码 NamePhonePad 姓名与电话号码 EmailAddress 电子邮箱 DecimalPad 带小数点的数字 clearButtonMode 描述 Never 从不显示 Always 一直显示 WhileEditing 仅编辑时显示 UnlessEditing 仅不编辑时显示 返回类型 描述 字符串 文本框内容 主题 主题键 类型 描述 textColor 颜色 文字颜色 caretColor 颜色 光标颜色 placeholderColor 颜色 占位符颜色 示例 { default = \"\"; label = \"用户名\"; cell = \"TextField\"; key = \"username\"; keyboard = \"Default\"; -- 默认键盘 alignment = \"Right\"; -- 右对齐 placeholder = \"输入用户名\"; -- 占位符 maxLength = 21; -- 最大长度 validationRegex = \"^[0-9a-zA-Z]+$\"; -- 正则验证 }; { isSecure = true; -- 显示为小圆点密码输入 default = \"\"; label = \"密码\"; cell = \"TextField\"; key = \"password\"; keyboard = \"NumberPad\"; -- 数字小键盘 alignment = \"Right\"; -- 右对齐 placeholder = \"输入密码\"; -- 占位符 prompt = \"请输入密码\"; -- 弹框标题 message = \"请在提示框中输入 6 位数字密码\"; -- 弹框信息 validationRegex = \"^[0-9]{6}$\"; -- 正则验证 okTitle = \"保存\"; -- 提交按钮标题 cancelTitle = \"取消\"; -- 取消按钮标题 }; "},"XUI/Modules/Radio_Checkbox.html":{"url":"XUI/Modules/Radio_Checkbox.html","title":"Radio / Checkbox 单选框 / 复选框组","keywords":"","body":"Radio / Checkbox 单选框 / 复选框组 此组件在界面上显示若干单选框 / 复选框. 点选单选框会选中当前选择的单选框, 取消同组其它单选框的选中状态. 点选复选框会切换其选中 / 未选状态. 键 类型 描述 必选 默认值 最低版本需求 备注 options 包含字典的数组 选项列表数组 * - - - numPerLine 整数 每行选项个数 - iPhone 为 2, iPad 为 4 1.2-10 最大值为 12 minCount 整数 最少选择项目数 - 0 - cell = 'Checkbox' maxCount 整数 最多选择项目数 - INT_MAX - cell = 'Checkbox' options 包含若干 选项, 选项 为字典, 有如下属性: 键 类型 描述 条件 title 字符串 选项标题 可本地化 value 基本类型 选项配置值若不填, 则与 title 一致. 可选 此组件不支持 label/icon/height, 如需要设置标题或备注, 请结合 Group 组件进行设计. 返回类型 描述 包含基本类型的数组 包含所有选中项 value 的数组 主题 主题键 类型 描述 tagTextColor 颜色 标签文字颜色 tagSelectedTextColor 颜色 选中标签文字颜色 tagBackgroundColor 颜色 标签背景颜色 tagSelectedBackgroundColor 颜色 选中标签背景颜色 tagBorderColor 颜色 标签边框颜色 tagSelectedBorderColor 颜色 选中标签边框颜色 示例 { cell = \"Group\"; label = \"多选框组\"; footerText = \"轻按以选中标签，再次轻按以取消选中，最多选择 4 项\"; }; { default = { \"红色\"; \"绿帽\"; }; cell = \"Checkbox\"; key = \"checkbox\"; maxCount = 4; numPerLine = 4; -- 每行选项数量 options = { { title = \"红色\"; }; { title = \"绿帽\"; }; { title = \"蓝色\"; }; { title = \"黄色\"; }; \"紫色\"; \"黑色\"; \"白色\"; \"咖啡色\"; \"卡其色\"; \"灰色\"; }; }; { cell = \"Group\"; label = \"单选框组\"; footerText = \"轻按以选中标签\"; }; { default = \"Fifth\"; cell = \"Radio\"; key = \"radio\"; options = { { title = \"第一\"; }; { title = \"第二\"; }; { title = \"第三\"; }; { title = \"第四\"; -- 如果选项未设置 value，则该选项配置值为 title }; { title = \"第五\"; value = \"Fifth\"; -- 如果选项设置了 value，则该选项配置值为 value }; \"倒数第一\"; -- 选项可以简写 }; }; "},"XUI/Modules/Segment.html":{"url":"XUI/Modules/Segment.html","title":"Segment 适合少量选项的单项选择","keywords":"","body":"Segment 适合少量选项的单项选择 此组件在界面上显示一个选项组. 用于选择单个选项 (总选项数一般少于 6 个). 键 类型 描述 必选 默认值 最低版本需求 options 包含字典的数组 选项列表数组 * - - options 包含若干 选项, 选项 为字典, 有如下属性: 键 类型 描述 条件 title 字符串 选项标题 可本地化 value 基本类型 选项配置值若不填, 则与 title 一致. 可选 此组件不支持 icon. 返回类型 描述 基本类型 选中项的 value 示例 { default = \"绿帽\"; label = \"分块选项列表\"; cell = \"Segment\"; key = \"list-segment\"; options = { { title = \"红色\"; }; { title = \"绿帽\"; }; { title = \"不撸\"; }; { title = \"液漏\"; }; }; }; "},"XUI/Modules/Option.html":{"url":"XUI/Modules/Option.html","title":"Option 单项选择列表","keywords":"","body":"Option 单项选择列表 此组件在界面上显示一个子菜单项, 用于链接包含一些选项的子菜单. 键 类型 描述 必选 默认值 最低版本需求 options 包含字典的数组 选项列表数组 * - - footerText 字符串 显示在列表选项下方的小字 可本地化 \"\" - popoverMode 布尔型 采用悬浮样式 - false 1.2-4 options 包含若干 选项, 选项 为字典, 有如下属性: 键 类型 描述 条件 title 字符串 选项标题 可本地化 value 基本类型 选项配置值若不填, 则与 title 一致. 可选 icon 字符串 选项图标文件名 可选 shortTitle 字符串 显示在父级菜单右侧的标题 可选, 可本地化 返回类型 描述 基本类型 选中项的 value 示例 { default = \"绿帽，你懂的！\"; -- 默认值 label = \"单选列表\"; cell = \"Option\"; key = \"list-1\"; options = { { title = \"红色，姨妈色！\"; shortTitle = \"红色\"; -- 显示在父级入口右侧 }; { title = \"绿帽，你懂的！\"; shortTitle = \"绿帽\"; }; { title = \"蓝色，嗯！\"; shortTitle = \"蓝色\"; }; }; popoverMode = false; -- 设为 true 可使用悬浮模式 -- footerText = \"只能选择一项\"; -- 底部提示信息 }; "},"XUI/Modules/MultipleOption.html":{"url":"XUI/Modules/MultipleOption.html","title":"MultipleOption 多项选择列表","keywords":"","body":"MultipleOption 多项选择列表 此组件在界面上显示一个子菜单项, 用于链接包含一些选项的子菜单. 键 类型 描述 必选 默认值 最低版本需求 options 包含字典的数组 选项列表数组 * - - footerText 字符串 显示在列表选项下方的小字 可本地化 \"\" - maxCount 整数 最多选择项目数 - INT_MAX - popoverMode 布尔型 采用悬浮样式 - false 1.2-4 options 包含若干 选项, 选项 为字典, 有如下属性: 键 类型 描述 条件 title 字符串 选项标题 可本地化 value 基本类型 选项配置值若不填, 则与 title 一致. 可选 icon 字符串 选项图标文件名 可选 返回类型 描述 包含基本类型的数组 包含所有选中项 value 的数组 示例 { default = { \"红色，姨妈色！\"; \"绿帽，你懂的！\"; }; label = \"多选列表\"; cell = \"MultipleOption\"; key = \"list-2\"; maxCount = 2; -- 最大选项数量 options = { { title = \"红色，姨妈色！\"; icon = \"res/red.png\"; -- 为选项设置图标 }; { title = \"绿帽，你懂的！\"; icon = \"res/green.png\"; }; { title = \"蓝色，嗯！\"; icon = \"res/blue.png\"; }; }; popoverMode = false; -- 设为 true 可使用悬浮模式 footerText = \"最多可以选择两项\"; -- 底部提示信息 }; "},"XUI/Modules/OrderedOption.html":{"url":"XUI/Modules/OrderedOption.html","title":"OrderedOption 多项有序选择列表","keywords":"","body":"OrderedOption 多项有序选择列表 此组件在界面上显示一个子菜单项, 用于链接包含一些选项的子菜单. 键 类型 描述 必选 默认值 最低版本需求 options 包含字典的数组 选项列表数组 * - - footerText 字符串 显示在列表选项下方的小字 可本地化 \"\" - popoverMode 布尔型 采用悬浮样式 - false 1.2-4 minCount 整数 最少选择项目数 - 0 - maxCount 整数 最多选择项目数 - INT_MAX - options 包含若干 选项, 选项 为字典, 有如下属性: 键 类型 描述 条件 title 字符串 选项标题 可本地化 value 基本类型 选项配置值若不填, 则与 title 一致. 可选 icon 字符串 选项图标文件名 可选 返回类型 描述 包含基本类型的数组 包含所有选中项 value 的数组 示例 { default = { \"红色\"; }; label = \"有序选项列表\"; cell = \"OrderedOption\"; key = \"list-3\"; maxCount = 2; -- 最大选项数量 minCount = 1; -- 最小选项数量 options = { { title = \"红色\"; -- value = \"Red\"; -- 如果设置了 value，则配置项会保存 value icon = \"res/red.png\"; }; { title = \"绿帽\"; -- value = \"Green\"; icon = \"res/green.png\"; }; { title = \"蓝色\"; -- value = \"Blue\"; icon = \"res/blue.png\"; }; }; popoverMode = false; -- 设为 true 可使用悬浮模式 footerText = \"最多选择两项，最少选择一项\"; -- 底部提示信息 }; "},"XUI/Modules/EditableList.html":{"url":"XUI/Modules/EditableList.html","title":"EditableList 可编辑列表","keywords":"","body":"EditableList 可编辑列表 此组件在界面上显示一个子菜单项, 用于链接一个可编辑的字符串列表. 键 类型 描述 必选 默认值 最低版本需求 footerText 字符串 显示在列表选项下方的小字 可本地化 \"\" - itemFooterText 字符串 显示在添加新项目页面下方的小字 可本地化 \"\" - maxCount 整数 最多选择项目数 - INT_MAX - validationRegex 字符串 用于验证字符串条目的正则表达式 - nil 1.2-10 修改或添加字符串条目时, 若字符串无法通过正则表达式 validationRegex 验证, 则无法保存当前条目. 返回类型 描述 包含字符串的数组 列表内容 主题 主题键 类型 描述 textColor 颜色 文字颜色 caretColor 颜色 光标颜色 placeholderColor 颜色 占位符颜色 示例 { maxCount = 10; cell = \"EditableList\"; label = \"可编辑列表\"; key = \"list-4\"; default = { \"Default\"; }; validationRegex = \"^[0-9a-zA-Z]+$\"; }; "},"XUI/Modules/Slider.html":{"url":"XUI/Modules/Slider.html","title":"Slider 数值拖拽滑块","keywords":"","body":"Slider 数值拖拽滑块 此组件在界面上显示一个滑块, 用于浮点数值的选择和调整. 键 类型 描述 必选 默认值 最低版本需求 min 数值 滑块最小值 - 0.0 - max 数值 滑块最大值 - 1.0 - step 数值 调节歩长, 滑块会自动紧贴最近的步长值 - 0 1.2-10 showValue 布尔型 是否显示当前滑块的值 - false - 此组件不支持 label/icon, 如需要设置标题或备注, 请结合 Group 组件进行设计. 返回类型 描述 数值 组件数值 主题 主题键 类型 描述 tintColor 颜色 滑块进度底色 thumbColor 颜色 开关中心色 示例 { showValue = true; -- 是否显示当前值 min = 1; -- 最小值 default = 5; -- 默认值 max = 10; -- 最大值 step = 0.5; -- 可以设置步进间隔 label = \"滑动控件\"; cell = \"Slider\"; key = \"slider\"; }; "},"XUI/Modules/Stepper.html":{"url":"XUI/Modules/Stepper.html","title":"Stepper 数值调节按钮","keywords":"","body":"Stepper 数值调节按钮 此组件在界面上显示一个调节器, 用于数值的选择和调整. 键 类型 描述 必选 默认值 最低版本需求 min 数值 调节最小值 - 1 - max 数值 调节最大值 - 100 - step 数值 调节歩长 - 1 - isInteger 布尔型 值是否显示为整数 - false - autoRepeat 布尔型 长按是否连续调整 - true - 此组件不支持 icon. 返回类型 描述 数值 组件数值 示例 { min = 1; default = 25; max = 100; autoRepeat = true; -- 长按自动重复触发 label = \"步进控件\"; cell = \"Stepper\"; key = \"stepper\"; isInteger = true; -- 是否显示为整数 }; "},"XUI/Modules/DateTime.html":{"url":"XUI/Modules/DateTime.html","title":"DateTime 时间日期选择器","keywords":"","body":"DateTime 时间日期选择器 此组件在界面上显示一个时间日期选择器, 用于日期、时间的选择及时间间隔的调整. 键 类型 描述 必选 默认值 最低版本需求 min 数值 时间间隔最小值 - 0 - max 数值 时间间隔最大值 - FLOAT_MAX - minuteInterval 整数 时间间隔歩长, 单位分钟 - 1 - mode 字符串 选择器模式 - datetime - format 字符串 时间格式 (ISO8601) - nil - 此组件不支持 label/icon, 如需要设置标题和描述, 请配合 Group 组件进行设计. mode 描述 datetime 日期时间选择器 date 日期选择器 time 时间选择器 interval 时间间隔选择器 返回类型 条件 描述 整数 format == nil 组件所选时间的 Unix 时间戳, 或时间间隔的秒数 字符串 #format > 0 组件所选时间按 format 进行格式化后的结果 format 时间日期格式请参见 Unicode: Date Format Patterns 示例 { cell = \"DateTime\"; key = \"datetime1\"; }; "},"XUI/Modules/TitleValue.html":{"url":"XUI/Modules/TitleValue.html","title":"TitleValue 键值对显示; 代码片段选择器","keywords":"","body":"TitleValue 键值对显示; 代码片段选择器 此组件在界面上显示 key, value 对, 类似 设置 -> 通用 -> 关于中系统参数键值对的显示. 键 类型 描述 必选 默认值 最低版本需求 value 基本类型 右侧显示值 - nil - snippet 字符串 选择器脚本文件名 - nil - 此组件可以左划将已存的配置值置空, 但不能覆盖 XUI 中提供的 value. 如果为此组件设置了配置分区文件名 defaults 和配置键名 key, 则此组件可用来显示某一 XUI 配置项的实际值；若同时设置 .snippet 代码片段模板文件名, 则能够为此组件增加 XUI 内 代码片段选择器 的功能, 点击该组件能够唤起选择器队列, 队列处理完成后, 会将返回结果存入此组件的配置项内, 具体使用方法参见 代码片段. 示例 { cell = \"Group\"; label = \"二维码\"; footerText = \"扫描结果会出现在扫码内容中\"; }; { cell = \"Button\"; label = \"打开二维码扫描器\"; key = \"qr1\"; action = \"ScanQRCode:\"; kwargs = {}; }; { cell = \"TitleValue\"; label = \"扫码内容\"; key = \"qr1\"; }; "},"XUI/Modules/StaticText.html":{"url":"XUI/Modules/StaticText.html","title":"StaticText 静态文本框","keywords":"","body":"StaticText 静态文本框 此组件在界面上显示一段静态文本, 即其 label 属性中的文本. 键 类型 描述 必选 默认值 最低版本需求 label 字符串 显示的文本 * - - alignment 字符串 对齐方式 - Left - selectable 布尔型 是否允许选择文本 - false - alignment 描述 Left 左对齐 Center 居中 Right 右对齐 Natural 自然对齐 Justified 两边对齐 此组件不支持 icon/height, 且暂不支持更改文本字体、尺寸等属性. 示例 { cell = \"Group\"; label = \"静态文本\"; }; { cell = \"StaticText\"; label = \"这里是一条静态文本\"; }; { cell = \"StaticText\"; label = \"这里是一条可以被选中文字的静态文本\"; selectable = true; -- 允许选中 }; "},"XUI/Modules/Textarea.html":{"url":"XUI/Modules/Textarea.html","title":"Textarea 多行文本域","keywords":"","body":"Textarea 多行文本域 此组件在界面上显示一个子菜单项, 用于链接到一个多行文本输入界面. 键 类型 描述 必选 默认值 最低版本需求 maxLength 整数 最大文本长度 - INT_MAX - keyboard 字符串 键盘类型 - Default - autoCapitalization 字符串 自动大写模式 - None - autoCorrection 字符串 自动更正模式 - Default - keyboard 描述 Default 标准及第三方键盘 Alphabet 标准 ASCII ASCIICapable 标准 ASCII NumbersAndPunctuation 数字与标点 URL 网址 NumberPad 数字 PhonePad 电话号码 NamePhonePad 姓名与电话号码 EmailAddress 电子邮箱 DecimalPad 带小数点的数字 autoCapitalization 描述 None 无 Sentences 按句自动大写 Words 按单词自动大写 AllCharacters 全部大写 autoCorrection 描述 Default 默认 No 关闭自动更正 Yes 打开自动更正 暂不支持更改文本字体、尺寸等属性 返回类型 描述 字符串 文本内容 主题 主题键 类型 描述 textColor 颜色 文字颜色 caretColor 颜色 光标颜色 placeholderColor 颜色 占位符颜色 示例 { default = \"You can enter any text here...\"; cell = \"Textarea\"; key = \"textarea\"; label = \"一个文本域\"; }; "},"XUI/Modules/Image_AnimatedImage.html":{"url":"XUI/Modules/Image_AnimatedImage.html","title":"Image / AnimatedImage 图片 / 动态图片","keywords":"","body":"Image / AnimatedImage 图片 / 动态图片 此组件在界面上显示图片. Image 组件仅支持本地静态图片, 如 .png 和 .jpg 等. AnimatedImage 组件支持 .gif 动态图. 键 类型 描述 必选 默认值 最低版本需求 path 字符串 本地图片名称, 或在线图片的 URL * - - 此组件必须设定通用属性 height, 以确定图片高度, 宽度将保持比例自动适应. AnimatedImage 在 XXTouch v1.2-11 及更高版本中, 还支持加载在线静态或动态图片, 并且在加载完成后进行缓存. 在 path 中填写在线图片的 URL 即可 (仅支持 http/https 协议). 示例 { cell = \"Image\"; path = \"res/bd_logo1_31bdc765.png\"; height = 128.0; }; { cell = \"AnimatedImage\"; path = \"https://www.baidu.com/img/540%20258_c622d80176946df7f7b8d1997edf57d4.gif\"; height = 128.0; }; "},"XUI/Modules/File.html":{"url":"XUI/Modules/File.html","title":"File 文件选择器","keywords":"","body":"File 文件选择器 此组件在界面上显示文件选择区域, 可显示文件类型图标、文件名称与文件修改时间, 点击可选择新文件. 通常用于选择数据文件, 提供路径给服务脚本使用. 键 类型 描述 必选 默认值 最低版本需求 initialPath 字符串 文件选择初始顶层目录 - XPP 根路径 - allowedExtensions 包含字符串的数组 允许的文件扩展名列表 - [] - label 字符串 未选择文件时的提示标题 可本地化 \"\" 1.2-10 footerText 字符串 未选择文件时的提示信息 可本地化 \"\" 1.2-10 isFile 布尔型 是否选择文件, 如果为 false 则选择目录 - true 1.2-10 此组件可以左划会显示删除按钮, 轻按删除按钮可将已存的配置值置空. initialPath 是相对于 XPP 脚本包的相对路径. 若不填, 则为当前脚本包路径. allowedExtensions 中包含允许选择的文件名列表, 不符合扩展名要求的项目将不会被显示, 更无法被选择. 返回类型 描述 字符串 所选文件完整绝对路径 主题 主题键 类型 描述 labelColor 颜色 文件名颜色 valueColor 颜色 文件描述颜色 示例 { cell = \"File\"; key = \"file1\"; initialPath = \"scripts\"; isFile = true; -- 选择文件 label = \"请选择一个脚本\"; -- 标题 -- footerText = \"可选择所有 XXT 支持的脚本格式\"; -- 描述 allowedExtensions = { \"lua\"; \"xxt\"; \"xpp\" }; -- 只允许选择这些扩展名的文件 }; "},"XUI/Modules/About.html":{"url":"XUI/Modules/About.html","title":"About 关于","keywords":"","body":"About 关于 此组件在界面上显示一个关于区域. 键 类型 描述 必选 默认值 最低版本需求 icon 字符串 关于图标的相对路径 - \"\" - 此组件需要设定通用属性 label/value, 分别显示为标题/副标题. 主题 主题键 类型 描述 tintColor 颜色 标题颜色 labelColor 颜色 副标题颜色 示例 { cell = \"About\"; imagePath = \"res/xxt-icon.png\"; -- 中间图标 label = \"XUI 示例\\nv1.2-10\"; -- 标题 value = \"适用于 XXTouch v1.2-10 及以上版本, 示例内容仅供参考, 请勿直接用于生产环境.\\n2016-2018 (c) XXTouch Team.\\nAll Rights Reserved.\"; -- 副标题 }; "},"XUI/Internal_Lua_Module.html":{"url":"XUI/Internal_Lua_Module.html","title":"XUI 支持的 API","keywords":"","body":"XUI 支持的 API .xui 脚本是一个特殊的 Lua 脚本，同时还支持调用很少一部分的服务模块，主要用于设备类型判断、界面重载、配置数据读写等目的。以下是 .xui 脚本中支持的 API 列表，未在此列表中列出的 API 均不能在 .xui 脚本中使用： XPP 与 XUI 模块 (v1.2-10) XPP 脚本包模块 xpp (v1.2-10) XUI 脚本配置界面模块 xui 扩展字符串模块 (string) (v1.2-10) 比较两个版本号大小 string.compare_version 应用程序模块 (app) (v1.2-10) 前台打开一个 URL app.open_url 屏幕模块（screen） 获取屏幕尺寸 screen.size 系统模块（sys） 获取系统版本 sys.version 获取 XXTouch 版本 sys.xtversion 设备相关模块（device） 获取设备类型 device.type 获取设备名 device.name PLIST 文件读写模块 (plist) 读取 plist 文件 plist.read 写入 plist 文件 plist.write JSON 模块 (json) 将 Lua 值转成 JSON 字符串 json.encode 将 JSON 字符串转换成 Lua 值 json.decode JSON 中的 NULL 常量 json.null "},"XUI/Snippet/index.html":{"url":"XUI/Snippet/index.html","title":"代码片段","keywords":"","body":"代码片段 前言 创建 应用程序选择器 虚拟按键选择器 地理位置选择器 图像位置与颜色选择器 图像区域选择器 "},"XUI/Snippet/START.html":{"url":"XUI/Snippet/START.html","title":"前言","keywords":"","body":"前言 代码片段模板 .snippet 是一个特殊的 Lua 文件, 描述了如何使用一个或多个「代码片段选择器」产生的结果生成纯文本代码片段或其它对象。生成的对象，可以保存到 XUI 配置当中，如果是文本对象，亦可以快速插入代码编辑器。 「代码片段选择器」，指的是一系列用于生成「代码片段」的预置选择器组件，选择器类型包括： 单个应用程序选择器 app 多个应用程序选择器 apps 地理位置选择器 loc 虚拟按键选择器 key 单个图像位置选择器 pos 单个图像颜色选择器 color 单个图像位置与颜色选择器 poscolor 多个图像位置与颜色选择器 poscolors 图像区域选择器 rect "},"XUI/Snippet/Creation.html":{"url":"XUI/Snippet/Creation.html","title":"创建","keywords":"","body":"创建 通常，「代码片段模板」.snippet 文件需要直接返回一个表，如： return { name = '测试片段'; -- 代码片段名称 description = '用于测试各选择器的功能'; -- 代码片段描述 arguments = { -- 代码片段选择器列表 { -- 选择器 1 type = 'app', -- 选择器类型 title = '选择应用', -- 选择器标题 subtitle = '请选择一个应用', -- 选择器副标题 default = 'com.xxtouch.XXTExplorer', -- 选择器默认值 }, { -- 选择器 2 type = 'loc', title = '选择地理位置', subtitle = '请随便选择一个地理位置', default = xui.get(\"com.darwindev.XXTExplorer\", \"location1\"), -- 代码片段 .snippet 中可以使用 .xui 支持的所有 API }, { -- 选择器 3 }, -- ... }; generator = function (...) -- 可变参数生成器 -- 处理参数并返回生成的结果 local result return result end; } 根层级 键 类型 描述 name 字符串 代码片段名称 description 字符串 代码片段描述 arguments 数组 代码片段选择器列表 generator 函数 代码片段生成器 output 字符串 代码片段独立输出文件名 name 和 description 分别为代码片段模板的显示名称与显示描述, 会显示在文件管理器、代码片段的入口处。 arguments 为包含了一个或多个 选择器参数字典 的数组。App 将根据该数组中约定的选择器顺序，创建出一个选择器队列，依次让用户进行选择操作。用户完成选择器队列后，App 会将各选择器的返回值作为可变传入参数，依次传入生成器 generator 并调用它，最后将 generator 的返回值返回给调用方。 代码片段模板 .snippet 是可以独立使用的。如果需要允许它独立使用，可为其设置 output 字段，generator 生成的结果文本将保存到同一目录下 output 所标识的文件中。 选择器参数字典 键 类型 描述 type 字符串 选择器类型 title 字符串 选择器标题, 显示在选择器页面下方 subtitle 字符串 选择器副标题, 显示在选择器页面下方 default 基本类型 选择器默认值 有关各类型选择器 选择器参数字典 的详细介绍，参见后文内容。 在 XUI 中使用 如果代码片段模板 .snippet 在 XUI 的 TitleValue 组件中使用，即可从 XUI 中唤起选择器队列，并将结果保存到 XUI 组件的配置项中。同时该 .snippet 可调用 XUI 支持的所有 API，如 xui.get/xui.set/xpp.bundle_path 等。 在代码编辑器中使用 将代码片段模板 .snippet 放置到主目录的 snippets 目录中，即可被 App 的代码编辑器所调用。轻按键盘工具类右上角的星形按钮，即可快速生成代码片段，并插入到编辑的代码中。 作为独立文件使用 为代码片段模板 .snippet 设置 output 字段，并将代码片段放置在主目录的 lua/scripts 目录中，即可从 App 中直接点击，开始选择器队列，generator 生成的结果文本将保存到同一目录下 output 所标识的文件中。 "},"XUI/Snippet/app.html":{"url":"XUI/Snippet/app.html","title":"应用程序选择器","keywords":"","body":"应用程序选择器 「应用程序选择器」提供了一个应用程序预览列表，提供了允许用户选择一个或多个应用程序的能力。 类型为 app 的「单个应用程序选择器」只允许用户勾选一个应用程序，其返回值为 字符串，是用户所选应用程序的 Bundle ID。 而类型为 apps 的「多个应用程序选择器」允许用户拖选多个应用程序并为其排序，其返回值为 包含字符串的数组，是用户所选应用程序 Bundle ID 的有序集合。 示例 local group, name group = 'App' name = 'app.bundle_path(bid)' return { name = string.format('%s - %s', group, name), description = \"获取 App 的应用程序包路径\", arguments = { {type = 'app'}, }, default = \"com.darwindev.XXTExplorer\", -- 默认选中的应用 Bundle ID generator = function(bid) return string.format('app.bundle_path(%q)', bid) end, } "},"XUI/Snippet/key.html":{"url":"XUI/Snippet/key.html","title":"虚拟按键选择器","keywords":"","body":"虚拟按键选择器 「虚拟按键选择器」提供了一个虚拟按键列表，如 HOME 键、音量 + 键、音量 - 键、电源键等等，并允许用户选择其中一种虚拟按键。 「虚拟按键选择器」类型为 key，其返回值为 字符串，是用户所选虚拟按键的键码，键码列表参见 示例及支持的键码列表。 示例 local group, name group = '模拟' name = 'key.press(key)' return { name = string.format('%s - %s', group, name), description = \"松开按下的物理按键\", arguments = { {type = 'key'}, }, default = \"HOME\", -- 默认选择的键码 generator = function(key) return string.format('key.press(%q)', key) end, } "},"XUI/Snippet/loc.html":{"url":"XUI/Snippet/loc.html","title":"地理位置选择器","keywords":"","body":"地理位置选择器 「地理位置选择器」提供了系统地图组件，允许用户使用大头钉定位一个地理位置。 「地理位置选择器」类型为 loc，其返回值为 字典，包含了所选地理位置的经纬度信息。 键 类型 描述 latitude 数值 纬度 longitude 数值 经度 示例 local group, name group = '辅助' name = 'gps.fake(bid, latitude, longitude)' return { name = string.format('%s - %s', group, name), description = \"地理位置伪装\", arguments = { {type = 'app', hint = '选择需要伪装的应用'}, {type = 'loc', hint = '选择需要伪装的位置'}, }, default = { latitude = 39.92, longitude = 116.46 }, -- 默认所在的位置 generator = function(bid, loc) return string.format('gps.fake(%q, %f, %f)', bid, loc.latitude, loc.longitude) end, } "},"XUI/Snippet/poscolor.html":{"url":"XUI/Snippet/poscolor.html","title":"图像位置与颜色选择器","keywords":"","body":"图像位置与颜色选择器 「图像位置与颜色选择器」提供了从系统相机胶卷与主目录选择截图，并在截图上标注一个或多个像素点，以获取其位置或颜色的能力。 类型为 pos 的「单个图像位置选择器」允许用户选择一个像素点，并获取它的位置，其返回值为 包含两个数值的数组，两个数值分别为像素点的 x 坐标和 y 坐标，如： { 512, 373 } 类型为 color 的「单个图像颜色选择器」允许用户选择一个像素点，并获取它的颜色，其返回值为像素点颜色 RGB 的数值形式，如： 0x3c1f8b 类型为 poscolor 的「单个图像位置与颜色选择器」允许用户选择一个像素点，并获取它的位置与颜色，其返回值为 包含三个数值的数组，三个数值分别为像素点的 x 坐标、像素点的 y 坐标、像素点颜色 RGB 的数值形式，如： { 512, 373, 0x3c1f8b } 类型为 poscolors 的「多个图像位置与颜色选择器」允许用户选择一个或多个像素点，并获取它们的位置与颜色，其返回值为 二维数组，包含了所有所选各像素点的 x 坐标、像素点的 y 坐标、像素点颜色 RGB 的数值形式，如： { { 512, 373, 0x3c1f8b }, { 512, 374, 0x3c1f7c }, { 512, 375, 0x3c1f89 }, -- ... } 示例 local group, name group = '图色' name = 'if (screen.is_colors(poscolors, 90)) then ... end' return { name = string.format('%s - %s', group, name), description = \"屏幕多点颜色匹配\", arguments = { {type = 'poscolors'}, }, -- default = nil, -- 该选择器暂不支持默认值 generator = function(poscolors) local pcs = {} for i, pc in ipairs(poscolors) do pcs[#pcs + 1] = string.format('\\t{ %4d, %4d, 0x%06x}, -- %3d\\n', pc[1], pc[2], pc[3] & 0x00ffffff, i) end return string.format([[ if (screen.is_colors({ %s}, 90)) then @@ end]], table.concat(pcs)) -- 在返回的文本代码段中插入 @@，可以使编辑器光标自动移动到此处。 end, } "},"XUI/Snippet/rect.html":{"url":"XUI/Snippet/rect.html","title":"图像区域选择器","keywords":"","body":"图像区域选择器 「图像区域选择器」提供了从系统相机胶卷与主目录选择截图，并在截图上标注一个矩形区域，以获取其顶点与尺寸的能力。 「图像区域选择器」类型为 rect，其返回值为 包含四个数值的数组，这四个数值分别为矩形区域左上角顶点的 x 坐标和 y 坐标、右下角顶点的 x 坐标和 y 坐标，如： { 0, 534, 295, 626 } 示例 local group, name group = '图色' name = 'text = screen.ocr_text(rect)' return { name = string.format('%s - %s', group, name), description = \"屏幕区域文字识别\", arguments = { {type = 'rect'}, }, generator = function(rect) return string.format('text = screen.ocr_text(%d, %d, %d, %d)', rect[1], rect[2], rect[3], rect[4]) end, } "},"OpenAPI/index.html":{"url":"OpenAPI/index.html","title":"OpenAPI 使用手册","keywords":"","body":"OpenAPI 使用手册 开始之前 示例 文件相关 获取文件列表 选择一个脚本文件 获取当前已经选择的脚本文件 运行已经选择的脚本 删除一个脚本文件 新建一个脚本文件 写入内容到脚本文件 新建一个目录 删除一个目录 读取脚本文件 重命名一个文件或目录（RAW） 删除一个文件或空目录（RAW） 读取一个文件（RAW） 写入一个文件（RAW） 跳转下载一个文件 状态相关 对明文脚本内容进行语法检测 获得脚本运行状态 获得前台应用画面旋转方向 设置相关 获取录制设置 录制设置开关 获取音量键事件设置 音量键事件设置开关 获取开机启动设置 开机启动设置开关 选择开机启动脚本 获得用户偏好配置 设置用户偏好配置 禁弹出 “无 SIM 卡” 弹窗开关 禁弹出 “低电量” 弹窗开关 禁弹出 “使用推送通知来连接 iTunes” 弹窗开关 设置设备名 设置设备的屏幕背光度 设置设备全局音量 系统相关 获取设备已安装应用程序信息 获取设备信息 锁定屏幕 解锁屏幕 重启服务 注销设备 重启设备 关机 清理 UI 缓存 清理 GPS 伪装信息 全清设备 清理应用程序存档 导入一张照片到系统相册 更新自己 打开远程访问 关闭远程访问 获取远程服务开启状态 加密脚本相关 加密一个设备上的脚本文件 加密一段明文脚本 加密一段明文脚本并返回下载 URI 授权相关 绑定一个授权码 获得当前设备的授权信息 控制相关 UDP 扫描局域网的设备 远程启动脚本接口 停止脚本接口 暂停脚本接口 继续脚本接口 远程截图接口 设置进程词典条目的值 查看进程词典条目的值 推入条目到进程词典队列 从进程词典队列弹出条目 弹出进程词典队列所有条目 "},"OpenAPI/START.html":{"url":"OpenAPI/START.html","title":"开始之前","keywords":"","body":"开始之前 XXTouch OpenAPI 是 XXTouch 服务端在设备进行监听, 执行传入命令的开放式接口, 开发者可利用 OpenAPI 对 XXTouch 进行远程控制. OpenAPI 是集成中控, 远程调试, 上传文件到设备的一种便捷方式. 在开始之前, 你需要作出如下准备: 打开远程服务 首先，如果是做电脑端，需要从设备端打开远程服务 具体的步骤是：打开应用 --> 更多 --> 远程服务 --> 打开 这里有图文：使用手册 远程服务的协议 HTTP/1.1 远程服务默认端口 46952 如果没做特殊说明 接口文本参数都应该用 UTF-8 编码 接口文本返回值是 UTF-8 编码的文本 接口返回的 HTTP 状态码为 200 没有打开远程服务所有接口统一返回的 HTTP 状态码为 400 "},"OpenAPI/Demo.html":{"url":"OpenAPI/Demo.html","title":"示例","keywords":"","body":"示例 XXT局域网控制器简易示例[aardio版]-0.0.0.56.zip-32.8kB 注: aardio 是一款 Windows 端的快速开发工具 "},"OpenAPI/FileSystem/index.html":{"url":"OpenAPI/FileSystem/index.html","title":"文件相关","keywords":"","body":"文件相关 获取文件列表 选择一个脚本文件 获取当前已经选择的脚本文件 运行已经选择的脚本 删除一个脚本文件 新建一个脚本文件 写入内容到脚本文件 新建一个目录 删除一个目录 读取脚本文件 重命名一个文件或目录（RAW） 删除一个文件或空目录（RAW） 读取一个文件（RAW） 写入一个文件（RAW） 跳转下载一个文件 "},"OpenAPI/FileSystem/file_list.html":{"url":"OpenAPI/FileSystem/file_list.html","title":"获取文件列表","keywords":"","body":"获取文件列表 接口描述 POST /file_list HTTP/1.1 {\"directory\":\"/lua/scripts/\"} 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"list\":[ { \"name\":\"文件名\", \"change\":1446566100, \"size\":144, \"access\":1442128726, \"gid\":20, \"blksize\":4096, \"uid\":0, \"rdev\":0, \"blocks\":8, \"nlink\":1, \"permissions\":\"rw-r--r--\", \"mode\":\"file\", \"dev\":16777219, \"ino\":4887321, \"modification\":1443063784 }, { \"name\":\"文件夹名\", \"change\":1464135126, \"size\":102, \"access\":1464135114, \"gid\":20, \"blksize\":4096, \"uid\":0, \"rdev\":0, \"blocks\":0, \"nlink\":2, \"permissions\":\"rwxr-xr-x\", \"mode\":\"directory\", \"dev\":16777219, \"ino\":9407305, \"modification\":1464135126 }, ... ] } } 电脑端获取脚本列表示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/file_list\", json.dumps({ \"directory\" : \"/lua/scripts/\" })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) if ret['code']==0: for finfo in ret['data']['list']: if finfo['name']!='.' and finfo['name']!='..': print(finfo['name']) else: print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ 开源脚本模块存放目录为 /var/mobile/Media/1ferver/lua/ 脚本存放目录为 /var/mobile/Media/1ferver/lua/scripts/ 插件存放目录为 /var/mobile/Media/1ferver/lib/ 资源存放目录为 /var/mobile/Media/1ferver/res/ 日志存放目录为 /var/mobile/Media/1ferver/log/ UI配置存放目录为 /var/mobile/Media/1ferver/uicfg/ 文字识别字库存放目录为 /var/mobile/Media/1ferver/tessdata/ "},"OpenAPI/FileSystem/select_script_file.html":{"url":"OpenAPI/FileSystem/select_script_file.html","title":"选择一个脚本文件","keywords":"","body":"选择一个脚本文件 接口描述 POST /select_script_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\"} {\"code\":4,\"message\":\"无法读取文件\"} {\"code\":8,\"message\":\"参数错误\"} 电脑端选择脚本列表示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/select_script_file\", json.dumps({ \"filename\" : \"123.lua\" })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ "},"OpenAPI/FileSystem/get_selected_script_file.html":{"url":"OpenAPI/FileSystem/get_selected_script_file.html","title":"获取当前已经选择的脚本文件","keywords":"","body":"获取当前已经选择的脚本文件 接口描述 POST /get_selected_script_file HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"filename\":\"当前选择的文件名\" } } 电脑端选择脚本示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/get_selected_script_file\", '') response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] if ret['code'] == 0: print ret['data']['filename'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ "},"OpenAPI/FileSystem/launch_script_file.html":{"url":"OpenAPI/FileSystem/launch_script_file.html","title":"运行已经选择的脚本","keywords":"","body":"运行已经选择的脚本 接口描述 POST /launch_script_file HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"脚本运行开始\"} {\"code\":1,\"message\":\"操作失败\"} {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} {\"code\":3,\"message\":\"已有脚本正在运行中\"} {\"code\":4,\"message\":\"无法读取文件\"} {\"code\":8,\"message\":\"参数错误\"} {\"code\":9,\"message\":\"脚本已损坏\"} {\"code\":10,\"message\":\"软件需要更新方能支持使用这个脚本\"} 电脑端获取已经选择脚本示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/launch_script_file\", '') response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() "},"OpenAPI/FileSystem/remove_script_file.html":{"url":"OpenAPI/FileSystem/remove_script_file.html","title":"删除一个脚本文件","keywords":"","body":"删除一个脚本文件 接口描述 POST /remove_script_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":4,\"message\":\"无法读取文件\"} {\"code\":8,\"message\":\"参数错误\"} 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ "},"OpenAPI/FileSystem/new_script_file.html":{"url":"OpenAPI/FileSystem/new_script_file.html","title":"新建一个脚本文件","keywords":"","body":"新建一个脚本文件 接口描述 POST /new_script_file HTTP/1.1 {\"filename\":\"文件名\", \"data\":\"文件内容\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":4,\"message\":\"无法写入文件\"} {\"code\":11,\"message\":\"文件或目录已存在\"} {\"code\":8,\"message\":\"参数错误\"} 电脑端新建一个脚本文件示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json, base64 luaf = open('r:/123.lua', 'r') # 脚本文件路径 luatext = luaf.read() conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/new_script_file\", json.dumps({ \"filename\":\"123.lua\", \"data\":base64.b64encode(luatext) })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ 如果脚本是二进制数据比如加密的脚本，则需要将脚本内容使用 base64 算法编码 "},"OpenAPI/FileSystem/write_script_file.html":{"url":"OpenAPI/FileSystem/write_script_file.html","title":"写入内容到脚本文件","keywords":"","body":"写入内容到脚本文件 接口描述 POST /write_script_file HTTP/1.1 {\"filename\":\"文件名\", \"data\":\"文件内容\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":4,\"message\":\"无法写入文件\"} {\"code\":8,\"message\":\"参数错误\"} 电脑端写入内容到脚本文件示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json, base64 luaf = open('r:/123.lua', 'r') # 脚本文件路径 luatext = luaf.read() conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/write_script_file\", json.dumps({ \"filename\":\"123.lua\", \"data\":base64.b64encode(luatext) })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ 如果脚本是二进制数据比如加密的脚本，则需要将脚本内容使用 base64 算法编码 如果文件不存在，则会创建文件 "},"OpenAPI/FileSystem/mkdir.html":{"url":"OpenAPI/FileSystem/mkdir.html","title":"新建一个目录","keywords":"","body":"新建一个目录 接口描述 POST /mkdir HTTP/1.1 {\"directory\":\"目录名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\",\"detail\":\"详细的错误信息\"} {\"code\":8,\"message\":\"参数错误\"} 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/FileSystem/rmdir.html":{"url":"OpenAPI/FileSystem/rmdir.html","title":"删除一个目录","keywords":"","body":"删除一个目录 接口描述 POST /rmdir HTTP/1.1 {\"directory\":\"目录名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":8,\"message\":\"参数错误\"} 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ 这个函数无条件删除目录，不会管目录是不是空的 "},"OpenAPI/FileSystem/read_script_file.html":{"url":"OpenAPI/FileSystem/read_script_file.html","title":"读取脚本文件","keywords":"","body":"读取脚本文件 接口描述 POST /read_script_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"data\":\"脚本内容\"} {\"code\":4,\"message\":\"无法读取文件\"}、{\"code\":4,\"message\":\"加密脚本无法编辑\"} {\"code\":8,\"message\":\"参数错误\"} 电脑端从设备读取脚本文件示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json, base64 conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/read_script_file\", json.dumps({ \"filename\":\"123.lua\" })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] if ret['code'] == 0: print ret['data'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/lua/scripts/ "},"OpenAPI/FileSystem/rename_file.html":{"url":"OpenAPI/FileSystem/rename_file.html","title":"重命名一个文件或目录（RAW）","keywords":"","body":"重命名一个文件或目录（RAW） 接口描述 POST /rename_file HTTP/1.1 {\"filename\":\"文件名\",\"newfilename\":\"新文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\",\"detail\":\"具体的错误信息\"} {\"code\":4,\"message\":\"文件或目录不存在\"} {\"code\":11,\"message\":\"文件或目录已存在\"} {\"code\":8,\"message\":\"参数错误\"} 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/FileSystem/remove_file.html":{"url":"OpenAPI/FileSystem/remove_file.html","title":"删除一个文件或空目录（RAW）","keywords":"","body":"删除一个文件或空目录（RAW） 接口描述 POST /remove_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\",\"detail\":\"具体的错误信息\"} {\"code\":4,\"message\":\"文件或目录不存在\"} {\"code\":8,\"message\":\"参数错误\"} 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/FileSystem/read_file.html":{"url":"OpenAPI/FileSystem/read_file.html","title":"读取一个文件（RAW）","keywords":"","body":"读取一个文件（RAW） 接口描述 POST /read_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"data\":\"文件内容的 base64 编码字符串\"} {\"code\":4,\"message\":\"无法读取文件\"} {\"code\":8,\"message\":\"参数错误\"} 电脑端从设备读取脚本文件示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json, base64 conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/read_file\", json.dumps({ \"filename\":\"lua/scripts/123.lua\" })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] if ret['code'] == 0: print base64.b64decode(ret['data']) else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/FileSystem/write_file.html":{"url":"OpenAPI/FileSystem/write_file.html","title":"写入一个文件（RAW）","keywords":"","body":"写入一个文件（RAW） 接口描述 POST /write_file HTTP/1.1 {\"filename\":\"文件名\",\"data\":\"内容的 base64 编码字符串\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":4,\"message\":\"无法写入文件\"} 电脑端写入内容到脚本文件示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json, base64 luaf = open('r:/123.lua', 'r') # 脚本文件路径 luatext = luaf.read() conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/write_file\", json.dumps({ \"filename\":\"lua/scripts/123.lua\", \"data\":base64.b64encode(luatext) })) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/FileSystem/download_file.html":{"url":"OpenAPI/FileSystem/download_file.html","title":"跳转下载一个文件","keywords":"","body":"跳转下载一个文件 接口描述 GET /download_file?filename=[UTF8-URIEncoded 文件的路径] 可能的返回 200 [文件二进制内容] 400 {\"code\":4,\"message\":\"文件或目录不存在\"} 说明 这个接口在 1.1.2-6 版以上方可使用 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ 该接口支持绝对路径，路径第一个字符是 / 则判定为绝对路径 "},"OpenAPI/Status/index.html":{"url":"OpenAPI/Status/index.html","title":"状态相关","keywords":"","body":"状态相关 对明文脚本内容进行语法检测 获得脚本运行状态 获得前台应用画面旋转方向 "},"OpenAPI/Status/check_syntax.html":{"url":"OpenAPI/Status/check_syntax.html","title":"对明文脚本内容进行语法检测","keywords":"","body":"对明文脚本内容进行语法检测 接口描述 POST /check_syntax HTTP/1.1 明文脚本内容 可能的返回 {\"code\":0,\"message\":\"语法检测已通过\"} {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} "},"OpenAPI/Status/is_running.html":{"url":"OpenAPI/Status/is_running.html","title":"获得脚本运行状态","keywords":"","body":"获得脚本运行状态 接口描述 POST /is_running HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} // 代表没有脚本在运行也没有在录制 {\"code\":3,\"message\":\"已经有脚本正在运行中\"} {\"code\":9,\"message\":\"当前正在录制\"} "},"OpenAPI/Status/device_front_orien.html":{"url":"OpenAPI/Status/device_front_orien.html","title":"获得前台应用画面旋转方向","keywords":"","body":"获得前台应用画面旋转方向 接口描述 POST /device_front_orien HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"data\":{\"orien\":0}} // 0 为 home 在下; 1 为 home 在右; 2 为 home 在左; 3 为 home 在上; 4 未知 "},"OpenAPI/Config/index.html":{"url":"OpenAPI/Config/index.html","title":"设置相关","keywords":"","body":"设置相关 获取录制设置 录制设置开关 获取音量键事件设置 音量键事件设置开关 获取开机启动设置 开机启动设置开关 选择开机启动脚本 获得用户偏好配置 设置用户偏好配置 禁弹出 “无 SIM 卡” 弹窗开关 禁弹出 “低电量” 弹窗开关 禁弹出 “使用推送通知来连接 iTunes” 弹窗开关 设置设备名 设置设备的屏幕背光度 设置设备全局音量 "},"OpenAPI/Config/get_record_conf.html":{"url":"OpenAPI/Config/get_record_conf.html","title":"获取录制设置","keywords":"","body":"获取录制设置 接口描述 POST /get_record_conf HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"record_volume_up\":true, // 录制是否也包括音量上键 \"record_volume_down\":true // 录制是否也包括音量下键 } } "},"OpenAPI/Config/set_record_conf.html":{"url":"OpenAPI/Config/set_record_conf.html","title":"录制设置开关","keywords":"","body":"录制设置开关 接口描述 设置录制包含音量加键 POST /set_record_volume_up_on HTTP/1.1 设置录制不包含音量加键 POST /set_record_volume_up_off HTTP/1.1 设置录制包含音量减键 POST /set_record_volume_down_on HTTP/1.1 设置录制不包含音量减键 POST /set_record_volume_down_off HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/Config/get_volume_action_conf.html":{"url":"OpenAPI/Config/get_volume_action_conf.html","title":"获取音量键事件设置","keywords":"","body":"获取音量键事件设置 接口描述 POST /get_volume_action_conf HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"hold_volume_up\":\"0\", // 0 代表 “脚本启/停（有弹窗）”、1 代表 “脚本启/停”、2 代表 “无动作”；下同 \"hold_volume_down\":\"0\", \"click_volume_up\":\"0\", \"click_volume_down\":\"0\", \"activator_installed\":true, // 是否安装了 Activator，如果安装了 Activator 则这里设置不生效 } } "},"OpenAPI/Config/set_volume_action_conf.html":{"url":"OpenAPI/Config/set_volume_action_conf.html","title":"音量键事件设置开关","keywords":"","body":"音量键事件设置开关 接口描述 设置长按音量加键的动作 POST /set_hold_volume_up_action HTTP/1.1 0|1|2 设置长按音量减键的动作 POST /set_hold_volume_down_action HTTP/1.1 0|1|2 设置按一下音量加键的动作 POST /set_click_volume_up_action HTTP/1.1 0|1|2 设置按一下音量减键的动作 POST /set_click_volume_down_action HTTP/1.1 0|1|2 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/Config/get_startup_conf.html":{"url":"OpenAPI/Config/get_startup_conf.html","title":"获取开机启动设置","keywords":"","body":"获取开机启动设置 接口描述 POST /get_startup_conf HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"startup_run\":true, // true - 已启用开机启动；false - 未启用开机启动 \"startup_script\":\"开机启动的脚本名\" } } {\"code\":5,\"message\":\"配置文件有误\"} "},"OpenAPI/Config/set_startup_conf.html":{"url":"OpenAPI/Config/set_startup_conf.html","title":"开机启动设置开关","keywords":"","body":"开机启动设置开关 接口描述 启用开机启动 POST /set_startup_run_on HTTP/1.1 禁用开机启动 POST /set_startup_run_off HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"脚本运行的过程中无法做出该操作\"} "},"OpenAPI/Config/select_startup_script_file.html":{"url":"OpenAPI/Config/select_startup_script_file.html","title":"选择开机启动脚本","keywords":"","body":"选择开机启动脚本 接口描述 POST /select_startup_script_file HTTP/1.1 {\"filename\":\"文件名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"脚本运行的过程中无法做出该操作\"} "},"OpenAPI/Config/get_user_conf.html":{"url":"OpenAPI/Config/get_user_conf.html","title":"获得用户偏好配置","keywords":"","body":"获得用户偏好配置 接口描述 POST /get_user_conf HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"no_nosim_alert\":true|false, // “无 SIM 卡” 弹窗设置，true 为不弹，默认 false \"no_low_power_alert\":true|false, // “低电量” 弹窗设置，true 为不弹，默认 false \"no_idle\":true|false, // 失眠模式，true 为不休眠，默认 false （该设置只在远程开启的情况下生效） \"script_on_daemon\":true|false, // 守护模式，true 为服务非正常死亡复活会启动最后正在运行的脚本，默认 false \"script_end_hint\":true|false, // 脚本停止提示文字开关，true 为提示，默认为 false } } 说明 no_idle、script_on_daemon 字段在 1.0.3-3 以上版本方可使用 script_end_hint 字段在 1.0.5-1 以上版本方可使用 "},"OpenAPI/Config/set_user_conf.html":{"url":"OpenAPI/Config/set_user_conf.html","title":"设置用户偏好配置","keywords":"","body":"设置用户偏好配置 接口描述 POST /set_user_conf HTTP/1.1 { \"no_nosim_alert\":true|false, // “无 SIM 卡” 弹窗设置，true 为不弹，默认 false \"no_low_power_alert\":true|false, // “低电量” 弹窗设置，true 为不弹，默认 false \"no_idle\":true|false, // 失眠模式，true 为不休眠，默认 false （该设置只在远程开启的情况下生效） \"script_on_daemon\":true|false, // 守护模式，true 为服务非正常死亡复活会启动最后正在运行的脚本，默认 false，无法在脚本运行的过程中打开此开关 \"script_end_hint\":true|false, // 脚本停止提示文字开关，true 为提示，默认为 false } 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"脚本运行的过程中无法做出该操作\"} {\"code\":8,\"message\":\"参数错误\"} 说明 这个接口在 1.0.3-3 版以上方可使用 script_end_hint 字段在 1.0.5-1 以上版本方可使用 "},"OpenAPI/Config/set_no_nosim_alert.html":{"url":"OpenAPI/Config/set_no_nosim_alert.html","title":"禁弹出 “无 SIM 卡” 弹窗开关","keywords":"","body":"禁弹出 “无 SIM 卡” 弹窗开关 接口描述 禁止 “无 SIM 卡” 弹窗弹出 POST /set_no_nosim_alert_on HTTP/1.1 不禁止 “无 SIM 卡” 弹窗弹出 POST /set_no_nosim_alert_off HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} 说明 在 1.0.4-1 版以上, 支持 iOS 9 "},"OpenAPI/Config/set_no_low_power_alert.html":{"url":"OpenAPI/Config/set_no_low_power_alert.html","title":"禁弹出 “低电量” 弹窗开关","keywords":"","body":"禁弹出 “低电量” 弹窗开关 接口描述 禁止 “低电量” 弹窗弹出 POST /set_no_low_power_alert_on HTTP/1.1 不禁止 “低电量” 弹窗弹出 POST /set_no_low_power_alert_off HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/Config/set_no_need_pushid_alert.html":{"url":"OpenAPI/Config/set_no_need_pushid_alert.html","title":"禁弹出 “使用推送通知来连接 iTunes” 弹窗开关","keywords":"","body":"禁弹出 “使用推送通知来连接 iTunes” 弹窗开关 接口描述 禁止 “使用推送通知来连接 iTunes” 弹窗弹出 POST /set_no_need_pushid_alert_on HTTP/1.1 不禁止 “使用推送通知来连接 iTunes” 弹窗弹出 POST /set_no_need_pushid_alert_off HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/Config/set_device_name.html":{"url":"OpenAPI/Config/set_device_name.html","title":"设置设备名","keywords":"","body":"设置设备名 接口描述 POST /set_device_name HTTP/1.1 {\"name\":\"设备名\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":8,\"message\":\"参数错误\"} "},"OpenAPI/Config/set_brightness.html":{"url":"OpenAPI/Config/set_brightness.html","title":"设置设备的屏幕背光度","keywords":"","body":"设置设备的屏幕背光度 接口描述 POST /set_brightness HTTP/1.1 {\"level\":范围0.0~1.0} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":8,\"message\":\"参数错误\"} 说明 这个接口在 1.0.2-1 版以上方可使用 "},"OpenAPI/Config/set_volume.html":{"url":"OpenAPI/Config/set_volume.html","title":"设置设备全局音量","keywords":"","body":"设置设备全局音量 接口描述 POST /set_volume HTTP/1.1 {\"level\":范围0.0~1.0} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":8,\"message\":\"参数错误\"} 说明 这个接口在 1.0.2-1 版以上方可使用 "},"OpenAPI/System/index.html":{"url":"OpenAPI/System/index.html","title":"系统相关","keywords":"","body":"系统相关 获取设备已安装应用程序信息 获取设备信息 锁定屏幕 解锁屏幕 重启服务 注销设备 重启设备 关机 清理 UI 缓存 清理 GPS 伪装信息 全清设备 清理应用程序存档 导入一张照片到系统相册 更新自己 打开远程访问 关闭远程访问 获取远程服务开启状态 "},"OpenAPI/System/applist.html":{"url":"OpenAPI/System/applist.html","title":"获取设备已安装应用程序信息","keywords":"","body":"获取设备已安装应用程序信息 接口描述 POST /applist HTTP/1.1 {\"no_icon\": true|false} 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":[ { \"bid\":\"com.xxx.xxx.1\", \"name\":\"应用本地化名字\", \"bundle_path\":\"应用包路径\", \"data_path\":\"应用数据路径\", \"icon\":\"应用程序图标数据（base64 编码）\" }, { \"bid\":\"com.xxx.xxx.2\", \"name\":\"应用本地化名字\", \"bundle_path\":\"应用包路径\", \"data_path\":\"应用数据路径\", \"icon\":\"应用程序图标数据（base64 编码）\" }, ] } {\"code\":8,\"message\":\"参数错误\"} 说明 no_icon 参数可选，在 1.1.3-1 版以上方可使用，用于获取除 icon 数据以外所有的信息 "},"OpenAPI/System/deviceinfo.html":{"url":"OpenAPI/System/deviceinfo.html","title":"获取设备信息","keywords":"","body":"获取设备信息 接口描述 POST /deviceinfo HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"操作成功\", \"data\":{ \"devsn\":\"XXXXXXXXXXXX\", // 设备序列号 \"zeversion\":\"0.0.1.733\", // 服务程序版本 \"sysversion\":\"7.1.2\", // 系统版本 \"devname\":\"蛤蛤蛤蛤\", // 设备名 \"devmac\":\"10:11:12:13:14:15\", // 设备 MAC 地址 \"deviceid\":\"1234567890123456789012345678901234567890\", // 设备 UDID \"devtype\":\"iPhone5,3\", // 设备类型 \"wifi_ip\":\"192.168.1.100\", // WIFI IP 地址 \"ipaddr\":\"127.0.0.1\", // 当前访问的本机地址 \"port\":46952 // 端口 } } "},"OpenAPI/System/lock_screen.html":{"url":"OpenAPI/System/lock_screen.html","title":"锁定屏幕","keywords":"","body":"锁定屏幕 接口描述 POST /lock_screen HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/unlock_screen.html":{"url":"OpenAPI/System/unlock_screen.html","title":"解锁屏幕","keywords":"","body":"解锁屏幕 接口描述 POST /unlock_screen HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/restart.html":{"url":"OpenAPI/System/restart.html","title":"重启服务","keywords":"","body":"重启服务 接口描述 POST /restart HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/respring.html":{"url":"OpenAPI/System/respring.html","title":"注销设备","keywords":"","body":"注销设备 接口描述 POST /respring HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/reboot2.html":{"url":"OpenAPI/System/reboot2.html","title":"重启设备","keywords":"","body":"重启设备 接口描述 POST /reboot2 HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/halt.html":{"url":"OpenAPI/System/halt.html","title":"关机","keywords":"","body":"关机 接口描述 POST /halt HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/uicache.html":{"url":"OpenAPI/System/uicache.html","title":"清理 UI 缓存","keywords":"","body":"清理 UI 缓存 接口描述 POST /uicache HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/clear_gps.html":{"url":"OpenAPI/System/clear_gps.html","title":"清理 GPS 伪装信息","keywords":"","body":"清理 GPS 伪装信息 接口描述 POST /clear_gps HTTP/1.1 {\"bid\": \"com.xxx.xxx\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":8,\"message\":\"参数错误\"} 说明 bid 参数可选，在 1.1.3-1 版以上方可使用，用于清除指定应用的 GPS 伪装信息 "},"OpenAPI/System/clear_all.html":{"url":"OpenAPI/System/clear_all.html","title":"全清设备","keywords":"","body":"全清设备 接口描述 POST /clear_all HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"清理已经完成\"} "},"OpenAPI/System/clear_app_data.html":{"url":"OpenAPI/System/clear_app_data.html","title":"清理应用程序存档","keywords":"","body":"清理应用程序存档 接口描述 POST /clear_app_data HTTP/1.1 {\"bid\":\"应用包名\"} 可能的返回 {\"code\":0,\"message\":\"清理已经完成\"} {\"code\":1,\"message\":\"操作失败\"} {\"code\":8,\"message\":\"参数错误\"} {\"code\":11,\"message\":\"这个应用程序的存档不能清理\"} 说明 这个接口在 1.0.3-2 版以上方可使用 "},"OpenAPI/System/image_to_album.html":{"url":"OpenAPI/System/image_to_album.html","title":"导入一张照片到系统相册","keywords":"","body":"导入一张照片到系统相册 接口描述 POST /image_to_album HTTP/1.1 [图像数据] 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\"} 电脑端导入图片到设备相册示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json imgf = open('r:/1.png', 'rb') # 图片文件路径 imgdata = imgf.read() conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/image_to_album\", imgdata) response = conn.getresponse() if response.status == 200: ret = json.loads(response.read()) print ret['message'] else: print response.status, response.reason print response.read() conn.close() 说明 这个接口在 1.0.6-1 版以上方可使用 支持的数据格式有 PNG、JPG "},"OpenAPI/System/update_deb.html":{"url":"OpenAPI/System/update_deb.html","title":"更新自己","keywords":"","body":"更新自己 接口描述 POST /update_deb HTTP/1.1 [deb 数据] 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\"} 说明 这个接口不会返回安装结果 返回操作成功只是上传成功了而已，安装是异步进行的 这个接口或许还可以安装其它 deb，不过不做保证 "},"OpenAPI/System/open_remote_access.html":{"url":"OpenAPI/System/open_remote_access.html","title":"打开远程访问","keywords":"","body":"打开远程访问 接口描述 POST /open_remote_access HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":1,\"message\":\"操作失败\"} 说明 这个 API 只有设备本机可以调用 "},"OpenAPI/System/close_remote_access.html":{"url":"OpenAPI/System/close_remote_access.html","title":"关闭远程访问","keywords":"","body":"关闭远程访问 接口描述 POST /close_remote_access HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} "},"OpenAPI/System/is_remote_access_opened.html":{"url":"OpenAPI/System/is_remote_access_opened.html","title":"获取远程服务开启状态","keywords":"","body":"获取远程服务开启状态 接口描述 POST /is_remote_access_opened HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"data\":{\"opened\":true|false}} 说明 这个 API 只有设备本机可以调用 "},"OpenAPI/Encrypt/index.html":{"url":"OpenAPI/Encrypt/index.html","title":"加密脚本相关","keywords":"","body":"加密脚本相关 加密一个设备上的脚本文件 加密一段明文脚本 加密一段明文脚本并返回下载 URI "},"OpenAPI/Encrypt/encript_file.html":{"url":"OpenAPI/Encrypt/encript_file.html","title":"加密一个设备上的脚本文件","keywords":"","body":"加密一个设备上的脚本文件 接口描述 POST /encript_file HTTP/1.1 { \"no_strip\": true|false, // 是否保留调试信息，默认 false，也就是不保留调试信息 \"in_file\": \"lua/scripts/xxx.lua\", // 输入文件名，可以为绝对路径 \"out_file\": \"lua/scripts/xxx.xxt\", // 输出文件名，可以为绝对路径 } 可能的返回 {\"code\":0,\"message\":\"操作成功\"} {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} {\"code\":4,\"message\":\"文件或目录不存在\"} // 输入文件无法被读取 {\"code\":4,\"message\":\"无法写入文件\"} {\"code\":8,\"message\":\"参数错误\"} {\"code\":13,\"message\":\"另外一项加密正在进行...\"} 说明 这个接口在 1.1.2-6 版以上方可使用 该接口文件操作的根目录为 /var/mobile/Media/1ferver/ "},"OpenAPI/Encrypt/encript.html":{"url":"OpenAPI/Encrypt/encript.html","title":"加密一段明文脚本","keywords":"","body":"加密一段明文脚本 接口描述 POST /encript HTTP/1.1 args: {\"no_strip\":true|false} [脚本内容] 可能的返回 成功返回状态码 200 并附带内容： [加密好的脚本内容] 失败返回状态码 400 并附带内容： {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} {\"code\":13,\"message\":\"另外一项加密正在进行...\"} 说明 这个接口在 1.1.2-6 版以上方可使用 args 参数说明： no_strip 当这个参数为 true 的时候，则保留调试信息加密（也就是报错会有行信息）。默认为 false "},"OpenAPI/Encrypt/encript_2.html":{"url":"OpenAPI/Encrypt/encript_2.html","title":"加密一段明文脚本并返回下载 URI","keywords":"","body":"加密一段明文脚本并返回下载 URI 接口描述 POST /encript HTTP/1.1 args: {\"no_strip\":true|false,\"filename\":\"UTF8-URIEncoded 文件名\"} [脚本内容] 可能的返回 成功返回状态码 200 并附带内容： { \"code\":0, \"message\":\"操作成功\", \"download_uri\":\"/download_encript\", // 可以通过跳转到这个 URI 来下载加密好的文件 } 失败返回状态码 400 并附带内容： {\"code\":2,\"message\":\"操作失败\"} {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} {\"code\":13,\"message\":\"另外一项加密正在进行...\"} 说明 这个接口在 1.1.2-6 版以上方可使用 args 参数说明： no_strip 当这个参数为 true 的时候，则保留调试信息加密（也就是报错会有行信息）。默认为 false filename 返回的 URI 跳转之后供下载的文件名，注意要 URIEncode 处理 "},"OpenAPI/License/index.html":{"url":"OpenAPI/License/index.html","title":"授权相关","keywords":"","body":"授权相关 绑定一个授权码 获得当前设备的授权信息 "},"OpenAPI/License/bind_code.html":{"url":"OpenAPI/License/bind_code.html","title":"绑定一个授权码","keywords":"","body":"绑定一个授权码 接口描述 POST /bind_code HTTP/1.1 XXXXXXXXXXXXXXXX 可能的返回 {\"code\":0,\"message\":\"充值成功，新增授权时间 XX 天 XX 小时 XX 分钟\"} // 表示绑定成功 {\"code\":1,\"message\":\"操作失败\"} // 连接服务器失败 {\"code\":-1,\"message\":\"...\"} // 其它任何非 0 值原因都用 message 描述 "},"OpenAPI/License/device_auth_info.html":{"url":"OpenAPI/License/device_auth_info.html","title":"获得当前设备的授权信息","keywords":"","body":"获得当前设备的授权信息 接口描述 POST /device_auth_info HTTP/1.1 可能的返回 { \"code\":0, \"message\":\"ok\", \"data\":{ \"nowDate\": 1517149407, \"expireDate\": 1517149407 // 过期时间 - 现在时间 小于等于 0 的话，也是过期 } } {\"code\":1,\"message\":\"操作失败\"} // 连接服务器失败 {\"code\":-1,\"message\":\"...\"} // 其它任何非 0 值原因都用 message 描述 "},"OpenAPI/Control/index.html":{"url":"OpenAPI/Control/index.html","title":"控制相关","keywords":"","body":"控制相关 UDP 扫描局域网的设备 远程启动脚本接口 停止脚本接口 暂停脚本接口 继续脚本接口 远程截图接口 设置进程词典条目的值 查看进程词典条目的值 推入条目到进程词典队列 从进程词典队列弹出条目 弹出进程词典队列所有条目 "},"OpenAPI/Control/udp_scan.html":{"url":"OpenAPI/Control/udp_scan.html","title":"UDP 扫描局域网的设备","keywords":"","body":"UDP 扫描局域网的设备 首先需要在电脑上打开一个 UDP 收消息的端口 然后发送如下 UDP 广播内容到局域网的 46953 端口 {\"ip\":\"电脑端的ip地址\",\"port\":50000} // port 为电脑端的监听端口 设备收到这个广播后会做出如下回复到电脑的收消息端口 { \"ip\":\"192.168.31.99\", \"port\":\"46952\", \"devname\":\"设备名\", \"deviceid\":\"123456789012345678901234567890123456790\", // 设备 UDID \"devsn\":\"XXXXXXXXXXXX\", // 设备序列号 \"devmac\":\"02:03:04:05:06:07\", // 设备 WiFi MAC 地址 \"devtype\":\"iPhone8,1\", // 设备型号 \"zeversion\":\"0.0.1.738\", // 服务版本 \"sysversion\":\"9.0.2\" // 系统版本 } 电脑端 UDP 扫描局域网设备示例（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import socket, json local_ip = '192.168.31.13' # 电脑端地址 local_port = 31500 local = (local_ip, local_port) remote = (\"255.255.255.255\", 46953) s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.bind(local) s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) s.sendto(json.dumps({\"ip\":local_ip, \"port\": local_port}), remote) while True: data, addr = s.recvfrom(2048) if not data: print \"client has exist\" break print \"received:\", data, \"from\", addr s.close() 电脑端 UDP 扫描局域网设备示例（适用于 Node.js）： var http = require('http'); //HTTP服务 var dgram = require('dgram'); //UDP模块 var server_Port = 31500; //服务端口 var client_Port = 31501; //发信端口 var device_List = {}; //设备列表 //创建收信服务 var server_Socket = dgram.createSocket('udp4'); server_Socket.on('message', function(msg, rinfo){ console.log('收到消息：%s', msg); var device_Info = JSON.parse(msg) //过滤重复 if(device_Info.deviceid){ device_List[device_Info.deviceid] = device_Info; } }); server_Socket.bind(server_Port); //创建发信服务 var client_Socket = dgram.createSocket('udp4'); client_Socket.bind(client_Port); var search = function(){ var server_List = new Array(); var os = require('os'); var ifaces = os.networkInterfaces(); for (var dev in ifaces) { var alias = 0; ifaces[dev].forEach(function(details){ if (details.family=='IPv4') { server_List.push(details.address); ++alias; } }); }; for(var address in server_List) { var ip_ar = server_List[address].split(\".\"); var send2ip = ip_ar[0] + \".\" + ip_ar[1] + \".\" + ip_ar[2] + \".255\"; var client_Socket = dgram.createSocket('udp4'); var msg = JSON.stringify({ip: server_List[address], port: server_Port}); client_Socket.send(msg, 0, msg.length, 46953, send2ip); }; } http.createServer(function (request, response) { response.writeHead(200, {'Content-Type': 'application/json'}); search() response.end( JSON.stringify(device_List) ); }).listen(22222); search() console.log('Web服务地址：http://127.0.0.1:22222/'); "},"OpenAPI/Control/spawn.html":{"url":"OpenAPI/Control/spawn.html","title":"远程启动脚本接口","keywords":"","body":"远程启动脚本接口 接口描述 POST /spawn HTTP/1.1 spawn_args: {\"脚本启动参数\":...} [脚本正文] 可能的返回 {\"code\":1,\"message\":\"操作失败\"} {\"code\":2,\"message\":\"脚本有语法错误\",\"detail\":\"具体的错误信息\"} {\"code\":3,\"message\":\"已经有脚本正在运行中\"} {\"code\":233,\"message\":\"什么情况？\"} 说明 [脚本启动参数] 是一个不包含换行符的可打印字符串 [脚本正文] 是脚本内容，可以是文本也可以是加密的二进制数据 脚本端可以通过 proc_get 或是 proc_take 获取脚本启动参数 脚本将不会作为文件存到设备上，只是会运行 上一条的例外，设备启用 脚本守护模式 的情况下，设备会缓存与设备相关的脚本数据 示例 例如可以构造如下请求发送到设备 POST /spawn HTTP/1.1 spawn_args: {\"server_ip\":\"192.168.31.13\",\"port\":55555} Content-Length: 123 local args = proc_get(\"spawn_args\") args = json.decode(args) sys.alert(\"帐号服务器的 IP 为：\"..args.server_ip..\"\\n端口为：\"..args.port) 设备将会弹出一个提示框 -> 账号服务器的 IP 为：192.168.31.13 端口为：55555 例子的 Python 语言实现（适用于 Python 2.7.x）： # -*- coding: utf-8 -*- import httplib, json spawn_args = { \"server_ip\": \"192.168.31.13\", # 电脑端 IP 地址 \"port\": 55555, # 电脑端端口 } data = r''' local args = proc_get(\"spawn_args\") args = json.decode(args) sys.alert(\"帐号服务器的 IP 为：\"..args.server_ip..\"\\n端口为：\"..args.port) ''' headers = { \"Content-type\": \"text/lua\", \"spawn_args\": json.dumps(spawn_args), } conn = httplib.HTTPConnection(\"192.168.31.72:46952\") # 设备端地址及端口 conn.request(\"POST\", \"/spawn\", data, headers) response = conn.getresponse() print response.status, response.reason data = response.read() print data conn.close() "},"OpenAPI/Control/recycle.html":{"url":"OpenAPI/Control/recycle.html","title":"停止脚本接口","keywords":"","body":"停止脚本接口 接口描述 POST /recycle HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"脚本即将停止\"} 说明 这个接口返回之时不保证脚本已完全停止，可以通过 /is_running 接口检测 "},"OpenAPI/Control/pause_script.html":{"url":"OpenAPI/Control/pause_script.html","title":"暂停脚本接口","keywords":"","body":"暂停脚本接口 接口描述 POST /pause_script HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} 说明 会在任何可能让出或等待的时候中断脚本，强烈建议不要使用此 API 重复调用不会有任何多余效果 该 API 会在按音量键弹出选择的时候调用，如要使用注意避开冲突 "},"OpenAPI/Control/resume_script.html":{"url":"OpenAPI/Control/resume_script.html","title":"继续脚本接口","keywords":"","body":"继续脚本接口 接口描述 POST /resume_script HTTP/1.1 可能的返回 {\"code\":0,\"message\":\"操作成功\"} 说明 使用暂停脚本后可以用此 API 恢复被暂停的脚本，强烈建议不要使用此 API 重复调用不会有任何多余效果 该 API 会在按音量键弹出选择被按取消的时候调用，如要使用注意避开冲突 "},"OpenAPI/Control/snapshot.html":{"url":"OpenAPI/Control/snapshot.html","title":"远程截图接口","keywords":"","body":"远程截图接口 接口描述 GET /snapshot?ext=[扩展名]&compress=[压缩率]&orient=[旋转方向]&zoom=[缩放比例]&left=[左]&top=[上]&right=[右]&bottom=[下] HTTP/1.1 可能的返回 图片数据 说明 [扩展名] 可以是 png 或是 jpg [压缩率] 范围 0~1，如果压缩率小于 1 则自动用 jpg 格式 [旋转方向] 范围 0~3；0 - 竖屏 home 在下；1 - 横屏 home 在右；2 - 横屏 home 在左；3 - 竖屏 home 在上 [缩放比例] 范围 0~3；默认 1；1.0.7-1 版以上有效 [左]、[上]、[右]、[下] 用于设定一个截图区域；区域无效则为全屏；1.0.7-1 版以上有效 "},"OpenAPI/Control/proc_put.html":{"url":"OpenAPI/Control/proc_put.html","title":"设置进程词典条目的值","keywords":"","body":"设置进程词典条目的值 接口描述 POST /proc_put HTTP/1.1 {\"key\":\"[键]\",\"value\":\"[值]\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"key\":\"[键]\",\"old_value\":\"[旧值]\",\"value\":\"[新值]\"} {\"code\":1,\"message\":\"操作失败\"} 说明 存储一个以 [键] 为键，值为 [值] 的条目到设备正在运行的 XXTouch 服务进程中 [键] 用于提取值 [值] 一个字符串 示例代码 例如可以构造如下请求发送到设备 POST /proc_put HTTP/1.1 Content-Length: 45 {\"key\":\"havonz\",\"value\":\"苏泽是个好人\"} 然后设备的脚本中如果有如下代码 sys.alert(proc_get(\"havonz\")) 设备将弹出一个提示框 -> 苏泽是个好人 "},"OpenAPI/Control/proc_get.html":{"url":"OpenAPI/Control/proc_get.html","title":"查看进程词典条目的值","keywords":"","body":"查看进程词典条目的值 接口描述 POST /proc_get HTTP/1.1 {\"key\":\"[键]\"} 可能的返回 {\"code\":0,\"key\":\"[键]\",\"value\":\"[值]\"} {\"code\":1,\"message\":\"操作失败\"} 说明 查看一个设备正在运行的 XXTouch 服务进程中以 [键] 为键的条目的值 当设备正在运行的 XXTouch 服务进程中以 [键] 为键的条目没有值的时候，返回失败 示例代码 例如当设备的脚本中执行如下代码 proc_put(\"taozi\", \"桃子是个好人\") 然后构造如下请求发送到设备 POST /proc_get HTTP/1.1 Content-Length: 15 {\"key\":\"taozi\"} 则会返回的数据如下 {\"code\":0,\"key\":\"taozi\",\"value\":\"桃子是个好人\"} "},"OpenAPI/Control/proc_queue_push.html":{"url":"OpenAPI/Control/proc_queue_push.html","title":"推入条目到进程词典队列","keywords":"","body":"推入条目到进程词典队列 接口描述 POST /proc_queue_push HTTP/1.1 {\"key\":\"[键]\",\"value\":\"[值]\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"size\":10} // size 表示词典队列中的现存的条目数 说明 压入一个以 [值] 为值的条目到键为 [键] 进程词典队列中 [键] 标识队列，用于从队列中提取值 [值] 一个字符串 "},"OpenAPI/Control/proc_queue_pop.html":{"url":"OpenAPI/Control/proc_queue_pop.html","title":"从进程词典队列弹出条目","keywords":"","body":"从进程词典队列弹出条目 接口描述 POST /proc_queue_pop HTTP/1.1 {\"key\":\"[键]\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"key\":\"[键]\",\"value\":\"[值]\"} 说明 从进程词典队列中弹出一个值，如果队列为空，则会取出空字符串 [键] 标识队列，用于从队列中提取值 "},"OpenAPI/Control/proc_queue_clear.html":{"url":"OpenAPI/Control/proc_queue_clear.html","title":"弹出进程词典队列所有条目","keywords":"","body":"弹出进程词典队列所有条目 接口描述 POST /proc_queue_clear HTTP/1.1 {\"key\":\"[键]\"} 可能的返回 {\"code\":0,\"message\":\"操作成功\",\"key\":\"[键]\",\"values\":[\"条目1\", \"条目2\", ...]} 说明 从进程词典队列弹出所有值 [键] 标识队列，用于从队列中提取值 "},"URLScheme/index.html":{"url":"URLScheme/index.html","title":"URL Scheme 与二维码协议","keywords":"","body":"URL Scheme 与二维码协议 简介 打开扫一扫 运行脚本 停止脚本 绑定授权 XUI 相关 下载相关 恢复工作区 软猫云 "},"URLScheme/INTRO.html":{"url":"URLScheme/INTRO.html","title":"简介","keywords":"","body":"简介 该协议规定了 XXTouch App 的 URL Scheme 所支持的动作及参数. 打开 xxt:// 形式的 URL 扫描包含 xxt:// 形式 URL 的二维码 扫描包含动作及参数字典的二维码 以上三种方式将会唤醒 XXTouch App, 做出相应行为. "},"URLScheme/Scan.html":{"url":"URLScheme/Scan.html","title":"打开扫一扫","keywords":"","body":"打开扫一扫 xxt://scan/ 唤醒扫一扫功能. 二维码字典 { \"event\":\"scan\" } "},"URLScheme/Launch.html":{"url":"URLScheme/Launch.html","title":"运行脚本","keywords":"","body":"运行脚本 xxt://launch/ xxt://launch/?path=%@ path 为欲运行的脚本绝对路径, 若不指定 path 参数, 则运行当前选中脚本. 二维码字典 { \"event\":\"launch\", \"path\":\"[欲运行的脚本绝对路径]\" } "},"URLScheme/Stop.html":{"url":"URLScheme/Stop.html","title":"停止脚本","keywords":"","body":"停止脚本 xxt://stop/ 停止当前运行的脚本. 二维码字典 { \"event\":\"stop\" } "},"URLScheme/License.html":{"url":"URLScheme/License.html","title":"绑定授权","keywords":"","body":"绑定授权 xxt://license/ xxt://license/?code=%@ 唤醒授权界面, 并填写授权码. code 为 12 或 16 位授权码文本. 二维码字典 { \"event\":\"license\", \"code\":\"[授权码文本]\" } "},"URLScheme/XUI.html":{"url":"URLScheme/XUI.html","title":"XUI 相关","keywords":"","body":"XUI 相关 xxt://xui/?bundle=%@&name=%@ 配置一个脚本包, 并唤醒其中的某个 XUI 文件. bundle 为脚本包的绝对路径, name 为 XUI 文件在脚本包中的相对路径. 二维码字典 { \"event\":\"xui\", \"bundle\":\"[脚本包的绝对路径]\", \"name\":\"[XUI 文件在脚本包中的相对路径]\" } "},"URLScheme/Download.html":{"url":"URLScheme/Download.html","title":"下载相关","keywords":"","body":"下载相关 xxt://download/?path=%@&url=%@ 从指定 URL 下载文件. path 为欲保存的文件名, url 为指定的 URL. 说明 如果不指定 path, 文件名将自动从目标 URL 猜测, 或选取 URL 的最后一部分作为文件名. path 可指定为绝对路径或相对路径, 若指定为相对路径, 则其路径是相对于 App 文件浏览器当前所在的目录而言的. 二维码字典 { \"event\":\"download\", \"path\":\"[需要保存的文件名.lua]\", \"url\":\"[下载地址]\" } "},"URLScheme/Workspace.html":{"url":"URLScheme/Workspace.html","title":"恢复工作区","keywords":"","body":"恢复工作区 xxt://workspace/ 将 XXTouch App 恢复到刚启动应用时的状态, 退出所有打开的界面. 二维码字典 { \"event\":\"workspace\" } "},"URLScheme/Cloud.html":{"url":"URLScheme/Cloud.html","title":"软猫云","keywords":"","body":"软猫云 xxt://cloud/ xxt://cloud/?project=%@ 打开软猫云标签页, 若指定了 project 参数, 则一并打开指定 ID 的项目详情页面. 二维码字典 { \"event\":\"cloud\", \"project\": \"[软猫云项目ID]\" } "}}